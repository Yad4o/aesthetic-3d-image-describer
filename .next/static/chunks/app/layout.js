/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Space_Grotesk%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-display%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22spaceGrotesk%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-sans%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Csrc%5C%5Ccomponents%5C%5Cproviders%5C%5Cblink-provider.tsx%22%2C%22ids%22%3A%5B%22BlinkProvider%22%5D%7D&server=false!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Space_Grotesk%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-display%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22spaceGrotesk%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-sans%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Csrc%5C%5Ccomponents%5C%5Cproviders%5C%5Cblink-provider.tsx%22%2C%22ids%22%3A%5B%22BlinkProvider%22%5D%7D&server=false! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Space_Grotesk\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-display\"}],\"variableName\":\"spaceGrotesk\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Space_Grotesk\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-display\\\"}],\\\"variableName\\\":\\\"spaceGrotesk\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-sans\"}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-sans\\\"}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/providers/blink-provider.tsx */ \"(app-pages-browser)/./src/components/providers/blink-provider.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q29tJTVDJTVDdnMlMjBjb2RlJTIwc2NyaXB0cyU1QyU1Q2Flc3RoZXRpYy0zZC1pbWFnZS1kZXNjcmliZXIlNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZm9udCU1QyU1Q2dvb2dsZSU1QyU1Q3RhcmdldC5jc3MlM0YlN0IlNUMlMjJwYXRoJTVDJTIyJTNBJTVDJTIyYXBwJTVDJTVDJTVDJTVDbGF5b3V0LnRzeCU1QyUyMiUyQyU1QyUyMmltcG9ydCU1QyUyMiUzQSU1QyUyMlNwYWNlX0dyb3Rlc2slNUMlMjIlMkMlNUMlMjJhcmd1bWVudHMlNUMlMjIlM0ElNUIlN0IlNUMlMjJzdWJzZXRzJTVDJTIyJTNBJTVCJTVDJTIybGF0aW4lNUMlMjIlNUQlMkMlNUMlMjJ2YXJpYWJsZSU1QyUyMiUzQSU1QyUyMi0tZm9udC1kaXNwbGF5JTVDJTIyJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIyc3BhY2VHcm90ZXNrJTVDJTIyJTdEJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNvbSU1QyU1Q3ZzJTIwY29kZSUyMHNjcmlwdHMlNUMlNUNhZXN0aGV0aWMtM2QtaW1hZ2UtZGVzY3JpYmVyJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2ZvbnQlNUMlNUNnb29nbGUlNUMlNUN0YXJnZXQuY3NzJTNGJTdCJTVDJTIycGF0aCU1QyUyMiUzQSU1QyUyMmFwcCU1QyU1QyU1QyU1Q2xheW91dC50c3glNUMlMjIlMkMlNUMlMjJpbXBvcnQlNUMlMjIlM0ElNUMlMjJJbnRlciU1QyUyMiUyQyU1QyUyMmFyZ3VtZW50cyU1QyUyMiUzQSU1QiU3QiU1QyUyMnN1YnNldHMlNUMlMjIlM0ElNUIlNUMlMjJsYXRpbiU1QyUyMiU1RCUyQyU1QyUyMnZhcmlhYmxlJTVDJTIyJTNBJTVDJTIyLS1mb250LXNhbnMlNUMlMjIlN0QlNUQlMkMlNUMlMjJ2YXJpYWJsZU5hbWUlNUMlMjIlM0ElNUMlMjJpbnRlciU1QyUyMiU3RCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJEJTNBJTVDJTVDb20lNUMlNUN2cyUyMGNvZGUlMjBzY3JpcHRzJTVDJTVDYWVzdGhldGljLTNkLWltYWdlLWRlc2NyaWJlciU1QyU1Q2FwcCU1QyU1Q2dsb2JhbHMuY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNvbSU1QyU1Q3ZzJTIwY29kZSUyMHNjcmlwdHMlNUMlNUNhZXN0aGV0aWMtM2QtaW1hZ2UtZGVzY3JpYmVyJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q3Byb3ZpZGVycyU1QyU1Q2JsaW5rLXByb3ZpZGVyLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMkJsaW5rUHJvdmlkZXIlMjIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxnaEJBQWtUO0FBQ2xUO0FBQ0EsNGVBQWdTO0FBQ2hTO0FBQ0EsNEpBQTRHO0FBQzVHO0FBQ0Esb05BQTZLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZDc0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG9tXFxcXHZzIGNvZGUgc2NyaXB0c1xcXFxhZXN0aGV0aWMtM2QtaW1hZ2UtZGVzY3JpYmVyXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGZvbnRcXFxcZ29vZ2xlXFxcXHRhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwiYXBwXFxcXFxcXFxsYXlvdXQudHN4XFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiU3BhY2VfR3JvdGVza1xcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJ2YXJpYWJsZVxcXCI6XFxcIi0tZm9udC1kaXNwbGF5XFxcIn1dLFxcXCJ2YXJpYWJsZU5hbWVcXFwiOlxcXCJzcGFjZUdyb3Rlc2tcXFwifVwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcb21cXFxcdnMgY29kZSBzY3JpcHRzXFxcXGFlc3RoZXRpYy0zZC1pbWFnZS1kZXNjcmliZXJcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZm9udFxcXFxnb29nbGVcXFxcdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJhcHBcXFxcXFxcXGxheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJJbnRlclxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJ2YXJpYWJsZVxcXCI6XFxcIi0tZm9udC1zYW5zXFxcIn1dLFxcXCJ2YXJpYWJsZU5hbWVcXFwiOlxcXCJpbnRlclxcXCJ9XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJEOlxcXFxvbVxcXFx2cyBjb2RlIHNjcmlwdHNcXFxcYWVzdGhldGljLTNkLWltYWdlLWRlc2NyaWJlclxcXFxhcHBcXFxcZ2xvYmFscy5jc3NcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIkJsaW5rUHJvdmlkZXJcIl0gKi8gXCJEOlxcXFxvbVxcXFx2cyBjb2RlIHNjcmlwdHNcXFxcYWVzdGhldGljLTNkLWltYWdlLWRlc2NyaWJlclxcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxwcm92aWRlcnNcXFxcYmxpbmstcHJvdmlkZXIudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Space_Grotesk%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-display%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22spaceGrotesk%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-sans%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Csrc%5C%5Ccomponents%5C%5Cproviders%5C%5Cblink-provider.tsx%22%2C%22ids%22%3A%5B%22BlinkProvider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/MzE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz8yNTExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz80YzM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/M2Q1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={592:(e,r,t)=>{var n=t(722);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},722:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(592);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz9mYTAyIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1OTI6KGUscix0KT0+e3ZhciBuPXQoNzIyKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDcyMjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTkyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz80NzFlIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"93675f4de1aa\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzRmZjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI5MzY3NWY0ZGUxYWFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/providers/blink-provider.tsx":
/*!*****************************************************!*\
  !*** ./src/components/providers/blink-provider.tsx ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlinkProvider: function() { return /* binding */ BlinkProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _blinkdotnew_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @blinkdotnew/react */ \"(app-pages-browser)/./node_modules/@blinkdotnew/react/dist/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ BlinkProvider auto */ \n\nfunction BlinkProvider(param) {\n    let { children } = param;\n    // Use public env vars for client-side\n    const projectId = process.env.NEXT_PUBLIC_BLINK_PROJECT_ID || \"demo-project\";\n    const publishableKey = process.env.NEXT_PUBLIC_BLINK_PUBLISHABLE_KEY;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_blinkdotnew_react__WEBPACK_IMPORTED_MODULE_1__.BlinkProvider, {\n        projectId: projectId,\n        publishableKey: publishableKey,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_blinkdotnew_react__WEBPACK_IMPORTED_MODULE_1__.BlinkAuthProvider, {\n            children: children\n        }, void 0, false, {\n            fileName: \"D:\\\\om\\\\vs code scripts\\\\aesthetic-3d-image-describer\\\\src\\\\components\\\\providers\\\\blink-provider.tsx\",\n            lineNumber: 15,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\om\\\\vs code scripts\\\\aesthetic-3d-image-describer\\\\src\\\\components\\\\providers\\\\blink-provider.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, this);\n}\n_c = BlinkProvider;\nvar _c;\n$RefreshReg$(_c, \"BlinkProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3Byb3ZpZGVycy9ibGluay1wcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFMEY7QUFFbkYsU0FBU0EsY0FBYyxLQUEyQztRQUEzQyxFQUFFRyxRQUFRLEVBQWlDLEdBQTNDO0lBQzVCLHNDQUFzQztJQUN0QyxNQUFNQyxZQUFZQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLDRCQUE0QixJQUFJO0lBQzlELE1BQU1DLGlCQUFpQkgsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyxpQ0FBaUM7SUFFcEUscUJBQ0UsOERBQUNSLDZEQUFpQkE7UUFDaEJHLFdBQVdBO1FBQ1hJLGdCQUFnQkE7a0JBRWhCLDRFQUFDTixpRUFBaUJBO3NCQUNmQzs7Ozs7Ozs7Ozs7QUFJVDtLQWZnQkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvcHJvdmlkZXJzL2JsaW5rLXByb3ZpZGVyLnRzeD84YjEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgQmxpbmtQcm92aWRlciBhcyBCYXNlQmxpbmtQcm92aWRlciwgQmxpbmtBdXRoUHJvdmlkZXIgfSBmcm9tICdAYmxpbmtkb3RuZXcvcmVhY3QnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmxpbmtQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XHJcbiAgLy8gVXNlIHB1YmxpYyBlbnYgdmFycyBmb3IgY2xpZW50LXNpZGVcclxuICBjb25zdCBwcm9qZWN0SWQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CTElOS19QUk9KRUNUX0lEIHx8ICdkZW1vLXByb2plY3QnXHJcbiAgY29uc3QgcHVibGlzaGFibGVLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CTElOS19QVUJMSVNIQUJMRV9LRVlcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxCYXNlQmxpbmtQcm92aWRlciBcclxuICAgICAgcHJvamVjdElkPXtwcm9qZWN0SWR9XHJcbiAgICAgIHB1Ymxpc2hhYmxlS2V5PXtwdWJsaXNoYWJsZUtleX1cclxuICAgID5cclxuICAgICAgPEJsaW5rQXV0aFByb3ZpZGVyPlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgPC9CbGlua0F1dGhQcm92aWRlcj5cclxuICAgIDwvQmFzZUJsaW5rUHJvdmlkZXI+XHJcbiAgKVxyXG59XHJcbiJdLCJuYW1lcyI6WyJCbGlua1Byb3ZpZGVyIiwiQmFzZUJsaW5rUHJvdmlkZXIiLCJCbGlua0F1dGhQcm92aWRlciIsImNoaWxkcmVuIiwicHJvamVjdElkIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JMSU5LX1BST0pFQ1RfSUQiLCJwdWJsaXNoYWJsZUtleSIsIk5FWFRfUFVCTElDX0JMSU5LX1BVQkxJU0hBQkxFX0tFWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/providers/blink-provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-sans\"}],\"variableName\":\"inter\"}":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.tsx","import":"Inter","arguments":[{"subsets":["latin"],"variable":"--font-sans"}],"variableName":"inter"} ***!
  \**********************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Inter_f367f3', '__Inter_Fallback_f367f3'\",\"fontStyle\":\"normal\"},\"className\":\"__className_f367f3\",\"variable\":\"__variable_f367f3\"};\n    if(true) {\n      // 1770610809223\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC50c3hcIixcImltcG9ydFwiOlwiSW50ZXJcIixcImFyZ3VtZW50c1wiOlt7XCJzdWJzZXRzXCI6W1wibGF0aW5cIl0sXCJ2YXJpYWJsZVwiOlwiLS1mb250LXNhbnNcIn1dLFwidmFyaWFibGVOYW1lXCI6XCJpbnRlclwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLGdGQUFnRjtBQUMzRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3TUFBd0ksY0FBYyxzREFBc0Q7QUFDMU8sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP2MwYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fSW50ZXJfZjM2N2YzJywgJ19fSW50ZXJfRmFsbGJhY2tfZjM2N2YzJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2YzNjdmM1wiLFwidmFyaWFibGVcIjpcIl9fdmFyaWFibGVfZjM2N2YzXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NzA2MTA4MDkyMjNcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiRDovb20vdnMgY29kZSBzY3JpcHRzL2Flc3RoZXRpYy0zZC1pbWFnZS1kZXNjcmliZXIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-sans\"}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Space_Grotesk\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-display\"}],\"variableName\":\"spaceGrotesk\"}":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.tsx","import":"Space_Grotesk","arguments":[{"subsets":["latin"],"variable":"--font-display"}],"variableName":"spaceGrotesk"} ***!
  \****************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Space_Grotesk_dd5b2f', '__Space_Grotesk_Fallback_dd5b2f'\",\"fontStyle\":\"normal\"},\"className\":\"__className_dd5b2f\",\"variable\":\"__variable_dd5b2f\"};\n    if(true) {\n      // 1770610809220\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC50c3hcIixcImltcG9ydFwiOlwiU3BhY2VfR3JvdGVza1wiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXSxcInZhcmlhYmxlXCI6XCItLWZvbnQtZGlzcGxheVwifV0sXCJ2YXJpYWJsZU5hbWVcIjpcInNwYWNlR3JvdGVza1wifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLGdHQUFnRztBQUMzSCxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3TUFBd0ksY0FBYyxzREFBc0Q7QUFDMU8sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP2I0N2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fU3BhY2VfR3JvdGVza19kZDViMmYnLCAnX19TcGFjZV9Hcm90ZXNrX0ZhbGxiYWNrX2RkNWIyZidcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV9kZDViMmZcIixcInZhcmlhYmxlXCI6XCJfX3ZhcmlhYmxlX2RkNWIyZlwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzcwNjEwODA5MjIwXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkQ6L29tL3ZzIGNvZGUgc2NyaXB0cy9hZXN0aGV0aWMtM2QtaW1hZ2UtZGVzY3JpYmVyL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Space_Grotesk\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-display\"}],\"variableName\":\"spaceGrotesk\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9iNTVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZWE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@blinkdotnew/react/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@blinkdotnew/react/dist/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.Agent; },\n/* harmony export */   AsyncStorageAdapter: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.AsyncStorageAdapter; },\n/* harmony export */   BlinkAIImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkAIImpl; },\n/* harmony export */   BlinkAnalyticsImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkAnalyticsImpl; },\n/* harmony export */   BlinkAuthProvider: function() { return /* binding */ BlinkAuthProvider; },\n/* harmony export */   BlinkConnectorsImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkConnectorsImpl; },\n/* harmony export */   BlinkDataImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkDataImpl; },\n/* harmony export */   BlinkDatabase: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkDatabase; },\n/* harmony export */   BlinkProvider: function() { return /* binding */ BlinkProvider; },\n/* harmony export */   BlinkRAGImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkRAGImpl; },\n/* harmony export */   BlinkRealtimeChannel: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkRealtimeChannel; },\n/* harmony export */   BlinkRealtimeImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkRealtimeImpl; },\n/* harmony export */   BlinkSandboxImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkSandboxImpl; },\n/* harmony export */   BlinkStorageImpl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkStorageImpl; },\n/* harmony export */   BlinkTable: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkTable; },\n/* harmony export */   NoOpStorageAdapter: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.NoOpStorageAdapter; },\n/* harmony export */   SANDBOX_TEMPLATES: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.SANDBOX_TEMPLATES; },\n/* harmony export */   SandboxConnectionError: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.SandboxConnectionError; },\n/* harmony export */   WebStorageAdapter: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.WebStorageAdapter; },\n/* harmony export */   coreTools: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.coreTools; },\n/* harmony export */   createClient: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.createClient; },\n/* harmony export */   dbDelete: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbDelete; },\n/* harmony export */   dbGet: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbGet; },\n/* harmony export */   dbInsert: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbInsert; },\n/* harmony export */   dbList: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbList; },\n/* harmony export */   dbTools: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbTools; },\n/* harmony export */   dbUpdate: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbUpdate; },\n/* harmony export */   editImage: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.editImage; },\n/* harmony export */   fetchUrl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.fetchUrl; },\n/* harmony export */   generateImage: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.generateImage; },\n/* harmony export */   generateVideo: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.generateVideo; },\n/* harmony export */   getDefaultClient: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.getDefaultClient; },\n/* harmony export */   getDefaultStorageAdapter: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.getDefaultStorageAdapter; },\n/* harmony export */   getHost: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.getHost; },\n/* harmony export */   globFileSearch: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.globFileSearch; },\n/* harmony export */   grep: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.grep; },\n/* harmony export */   imageToVideo: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.imageToVideo; },\n/* harmony export */   isBrowser: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isBrowser; },\n/* harmony export */   isDeno: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isDeno; },\n/* harmony export */   isNode: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isNode; },\n/* harmony export */   isReactNative: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isReactNative; },\n/* harmony export */   isServer: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isServer; },\n/* harmony export */   isWeb: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isWeb; },\n/* harmony export */   listDir: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.listDir; },\n/* harmony export */   mediaTools: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.mediaTools; },\n/* harmony export */   platform: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.platform; },\n/* harmony export */   ragSearch: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.ragSearch; },\n/* harmony export */   ragTools: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.ragTools; },\n/* harmony export */   readFile: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.readFile; },\n/* harmony export */   runCode: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.runCode; },\n/* harmony export */   runTerminalCmd: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.runTerminalCmd; },\n/* harmony export */   sandboxTools: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.sandboxTools; },\n/* harmony export */   searchReplace: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.searchReplace; },\n/* harmony export */   serializeTools: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.serializeTools; },\n/* harmony export */   stepCountIs: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.stepCountIs; },\n/* harmony export */   storageCopy: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageCopy; },\n/* harmony export */   storageDelete: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageDelete; },\n/* harmony export */   storageDownload: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageDownload; },\n/* harmony export */   storageList: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageList; },\n/* harmony export */   storageMove: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageMove; },\n/* harmony export */   storagePublicUrl: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storagePublicUrl; },\n/* harmony export */   storageTools: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageTools; },\n/* harmony export */   storageUpload: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageUpload; },\n/* harmony export */   useAgent: function() { return /* binding */ useAgent; },\n/* harmony export */   useBlink: function() { return /* binding */ useBlink; },\n/* harmony export */   useBlinkAuth: function() { return /* binding */ useBlinkAuth; },\n/* harmony export */   useBlinkClient: function() { return /* binding */ useBlinkClient; },\n/* harmony export */   webSearch: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.webSearch; },\n/* harmony export */   writeFile: function() { return /* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.writeFile; }\n/* harmony export */ });\n/* harmony import */ var _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @blinkdotnew/sdk */ \"(app-pages-browser)/./node_modules/@blinkdotnew/sdk/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n// src/index.ts\n\n\n// src/context.tsx\n\n\n\nvar BlinkContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction BlinkProvider({\n  projectId,\n  publishableKey,\n  secretKey,\n  auth,\n  children\n}) {\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => (0,_blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.createClient)({\n      projectId,\n      publishableKey,\n      secretKey,\n      auth\n    }),\n    [projectId, publishableKey, secretKey, auth]\n  );\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => ({\n      client,\n      projectId\n    }),\n    [client, projectId]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlinkContext.Provider, { value, children });\n}\nfunction useBlink() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BlinkContext);\n  if (!context) {\n    throw new Error(\"useBlink must be used within a BlinkProvider\");\n  }\n  return context;\n}\nfunction useBlinkClient() {\n  return useBlink().client;\n}\nvar BlinkAuthContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction BlinkAuthProvider({ children }) {\n  const { client } = useBlink();\n  const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_1__.useState(true);\n  const [user, setUser] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    let mounted = true;\n    const initAuth = async () => {\n      try {\n        const currentUser = await client.auth.me();\n        if (mounted) {\n          setUser(currentUser);\n        }\n      } catch {\n        if (mounted) {\n          setUser(null);\n        }\n      } finally {\n        if (mounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n    initAuth();\n    const unsubscribe = client.auth.onAuthStateChanged((state) => {\n      setUser(state.user);\n    });\n    return () => {\n      mounted = false;\n      unsubscribe();\n    };\n  }, [client]);\n  const signIn = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    async (email, password) => {\n      const result = await client.auth.signInWithEmail(email, password);\n      setUser(result);\n    },\n    [client]\n  );\n  const signUp = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    async (email, password) => {\n      const result = await client.auth.signUp({ email, password });\n      setUser(result);\n    },\n    [client]\n  );\n  const signOut = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(async () => {\n    await client.auth.signOut();\n    setUser(null);\n  }, [client]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => ({\n      isAuthenticated: !!user,\n      isLoading,\n      user,\n      signIn,\n      signUp,\n      signOut\n    }),\n    [isLoading, user, signIn, signUp, signOut]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlinkAuthContext.Provider, { value, children });\n}\nfunction useBlinkAuth() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BlinkAuthContext);\n  if (!context) {\n    throw new Error(\"useBlinkAuth must be used within a BlinkAuthProvider\");\n  }\n  return context;\n}\n\n// src/use-agent.ts\n\nfunction useAgent(options) {\n  const client = useBlinkClient();\n  const { agent: agentInput, initialMessages = [], sandbox, onFinish, onError } = options;\n  const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialMessages);\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n  const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const agent = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return client.ai.bindAgent(agentInput);\n  }, [agentInput, client]);\n  const agentModel = agent.model;\n  const generateId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    return `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;\n  }, []);\n  const parseStream = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    async (response, assistantMessageId) => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = \"\";\n      let currentText = \"\";\n      let currentParts = [];\n      let finishData = null;\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split(\"\\n\");\n          buffer = lines.pop() || \"\";\n          for (const line of lines) {\n            const trimmedLine = line.trim();\n            if (!trimmedLine || !trimmedLine.startsWith(\"data:\")) continue;\n            if (trimmedLine === \"data: [DONE]\" || trimmedLine === \"data:[DONE]\") continue;\n            try {\n              const jsonStr = trimmedLine.startsWith(\"data: \") ? trimmedLine.slice(6) : trimmedLine.slice(5);\n              if (!jsonStr.trim()) continue;\n              const json = JSON.parse(jsonStr);\n              switch (json.type) {\n                // Handle text events (AI SDK v5 uses 'text-delta' with 'delta' property)\n                case \"text-delta\":\n                case \"text\": {\n                  const textChunk = json.delta || json.textDelta || json.value || json.text || \"\";\n                  currentText += textChunk;\n                  setMessages(\n                    (prev) => prev.map(\n                      (m) => m.id === assistantMessageId ? { ...m, content: currentText, parts: [...currentParts.filter((p) => p.type !== \"text\"), { type: \"text\", text: currentText }] } : m\n                    )\n                  );\n                  break;\n                }\n                // Handle tool call events\n                case \"tool-call\":\n                case \"tool-call-start\": {\n                  const existingTool = currentParts.find(\n                    (p) => p.type === \"tool-invocation\" && p.toolCallId === json.toolCallId\n                  );\n                  if (!existingTool) {\n                    const toolPart = {\n                      type: \"tool-invocation\",\n                      toolCallId: json.toolCallId,\n                      toolName: json.toolName,\n                      state: \"pending\",\n                      input: json.args || {}\n                    };\n                    currentParts = [...currentParts.filter((p) => p.type !== \"text\"), toolPart];\n                    setMessages(\n                      (prev) => prev.map(\n                        (m) => m.id === assistantMessageId ? { ...m, parts: [...currentParts, { type: \"text\", text: currentText }] } : m\n                      )\n                    );\n                  }\n                  break;\n                }\n                // Handle tool result events\n                case \"tool-result\": {\n                  currentParts = currentParts.map(\n                    (p) => p.type === \"tool-invocation\" && p.toolCallId === json.toolCallId ? { ...p, state: \"result\", output: json.result } : p\n                  );\n                  setMessages(\n                    (prev) => prev.map(\n                      (m) => m.id === assistantMessageId ? { ...m, parts: [...currentParts.filter((p) => p.type !== \"text\"), { type: \"text\", text: currentText }] } : m\n                    )\n                  );\n                  break;\n                }\n                // Handle finish event\n                case \"finish\":\n                case \"done\": {\n                  finishData = json;\n                  break;\n                }\n                // Ignore other event types (start, text-start, text-end, etc.)\n                default:\n                  break;\n              }\n            } catch {\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n      return { text: currentText, finishData };\n    },\n    []\n  );\n  const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    async (content) => {\n      const messageContent = content ?? input;\n      if (!messageContent.trim() && messages.length === 0) return;\n      setError(null);\n      setIsLoading(true);\n      abortControllerRef.current = new AbortController();\n      try {\n        let newMessages = [...messages];\n        if (messageContent.trim()) {\n          const userMessage = {\n            id: generateId(),\n            role: \"user\",\n            content: messageContent.trim()\n          };\n          newMessages = [...newMessages, userMessage];\n          setMessages(newMessages);\n          setInput(\"\");\n        }\n        const assistantMessageId = generateId();\n        const assistantMessage = {\n          id: assistantMessageId,\n          role: \"assistant\",\n          content: \"\",\n          parts: []\n        };\n        setMessages([...newMessages, assistantMessage]);\n        const response = await agent.stream({\n          messages: newMessages,\n          sandbox,\n          signal: abortControllerRef.current.signal\n        });\n        const { text, finishData } = await parseStream(response, assistantMessageId);\n        setMessages(\n          (prev) => prev.map(\n            (m) => m.id === assistantMessageId ? { ...m, content: text } : m\n          )\n        );\n        if (onFinish && finishData) {\n          onFinish({\n            text,\n            finishReason: finishData.finishReason || \"stop\",\n            steps: [],\n            usage: finishData.usage || { inputTokens: 0, outputTokens: 0 },\n            _billing: finishData._billing || { model: agentModel, creditsCharged: 0, costUSD: 0 }\n          });\n        }\n      } catch (err) {\n        const error2 = err instanceof Error ? err : new Error(String(err));\n        if (error2.name !== \"AbortError\") {\n          setError(error2);\n          onError?.(error2);\n        }\n      } finally {\n        setIsLoading(false);\n        abortControllerRef.current = null;\n      }\n    },\n    [agent, agentModel, messages, input, sandbox, generateId, parseStream, onFinish, onError]\n  );\n  const append = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((message) => {\n    setMessages((prev) => [...prev, { ...message, id: message.id || generateId() }]);\n  }, [generateId]);\n  const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (e) => {\n      setInput(e.target.value);\n    },\n    []\n  );\n  const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (e) => {\n      e?.preventDefault();\n      sendMessage();\n    },\n    [sendMessage]\n  );\n  const addToolOutput = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    ({ toolCallId, tool, output }) => {\n      setMessages(\n        (prev) => prev.map((m) => {\n          if (m.role !== \"assistant\" || !m.parts) return m;\n          const updatedParts = m.parts.map(\n            (p) => p.type === \"tool-invocation\" && p.toolCallId === toolCallId && p.toolName === tool ? { ...p, state: \"output-available\", output } : p\n          );\n          return { ...m, parts: updatedParts };\n        })\n      );\n    },\n    []\n  );\n  const clearMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    setMessages(initialMessages);\n    setError(null);\n  }, [initialMessages]);\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    abortControllerRef.current?.abort();\n  }, []);\n  const reload = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async () => {\n    let lastUserIndex = -1;\n    for (let i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].role === \"user\") {\n        lastUserIndex = i;\n        break;\n      }\n    }\n    if (lastUserIndex === -1) return;\n    const messagesUpToLastUser = messages.slice(0, lastUserIndex + 1);\n    setMessages(messagesUpToLastUser);\n    await sendMessage();\n  }, [messages, sendMessage]);\n  return {\n    messages,\n    input,\n    setInput,\n    isLoading,\n    error,\n    sendMessage,\n    append,\n    handleInputChange,\n    handleSubmit,\n    addToolOutput,\n    clearMessages,\n    stop,\n    reload\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmxpbmtkb3RuZXcvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDaUM7O0FBRWpDO0FBQ2tFO0FBQ2xCO0FBQ1I7QUFDeEMsbUJBQW1CLG9EQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsOENBQU87QUFDeEIsVUFBVSw4REFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLHNEQUFHLDBCQUEwQixpQkFBaUI7QUFDdkU7QUFDQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9EQUFhO0FBQ3BDLDZCQUE2QixVQUFVO0FBQ3ZDLFVBQVUsU0FBUztBQUNuQixvQ0FBb0MsMkNBQWM7QUFDbEQsMEJBQTBCLDJDQUFjO0FBQ3hDLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLDhDQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0Is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QUNILGlCQUFpQixrREFBVztBQUM1QjtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BibGlua2RvdG5ldy9yZWFjdC9kaXN0L2luZGV4Lm1qcz8xZWM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcIkBibGlua2RvdG5ldy9zZGtcIjtcblxuLy8gc3JjL2NvbnRleHQudHN4XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkBibGlua2RvdG5ldy9zZGtcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEJsaW5rQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBCbGlua1Byb3ZpZGVyKHtcbiAgcHJvamVjdElkLFxuICBwdWJsaXNoYWJsZUtleSxcbiAgc2VjcmV0S2V5LFxuICBhdXRoLFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VNZW1vKFxuICAgICgpID0+IGNyZWF0ZUNsaWVudCh7XG4gICAgICBwcm9qZWN0SWQsXG4gICAgICBwdWJsaXNoYWJsZUtleSxcbiAgICAgIHNlY3JldEtleSxcbiAgICAgIGF1dGhcbiAgICB9KSxcbiAgICBbcHJvamVjdElkLCBwdWJsaXNoYWJsZUtleSwgc2VjcmV0S2V5LCBhdXRoXVxuICApO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGNsaWVudCxcbiAgICAgIHByb2plY3RJZFxuICAgIH0pLFxuICAgIFtjbGllbnQsIHByb2plY3RJZF1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQmxpbmtDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlLCBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZUJsaW5rKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChCbGlua0NvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VCbGluayBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmxpbmtQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZUJsaW5rQ2xpZW50KCkge1xuICByZXR1cm4gdXNlQmxpbmsoKS5jbGllbnQ7XG59XG52YXIgQmxpbmtBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBCbGlua0F1dGhQcm92aWRlcih7IGNoaWxkcmVuIH0pIHtcbiAgY29uc3QgeyBjbGllbnQgfSA9IHVzZUJsaW5rKCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG1vdW50ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGluaXRBdXRoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3VycmVudFVzZXIgPSBhd2FpdCBjbGllbnQuYXV0aC5tZSgpO1xuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgIHNldFVzZXIoY3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICBzZXRVc2VyKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXRBdXRoKCk7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBjbGllbnQuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZWQoKHN0YXRlKSA9PiB7XG4gICAgICBzZXRVc2VyKHN0YXRlLnVzZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtjbGllbnRdKTtcbiAgY29uc3Qgc2lnbkluID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGVtYWlsLCBwYXNzd29yZCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LmF1dGguc2lnbkluV2l0aEVtYWlsKGVtYWlsLCBwYXNzd29yZCk7XG4gICAgICBzZXRVc2VyKHJlc3VsdCk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xuICBjb25zdCBzaWduVXAgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICBhc3luYyAoZW1haWwsIHBhc3N3b3JkKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuYXV0aC5zaWduVXAoeyBlbWFpbCwgcGFzc3dvcmQgfSk7XG4gICAgICBzZXRVc2VyKHJlc3VsdCk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xuICBjb25zdCBzaWduT3V0ID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGNsaWVudC5hdXRoLnNpZ25PdXQoKTtcbiAgICBzZXRVc2VyKG51bGwpO1xuICB9LCBbY2xpZW50XSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgaXNBdXRoZW50aWNhdGVkOiAhIXVzZXIsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICB1c2VyLFxuICAgICAgc2lnbkluLFxuICAgICAgc2lnblVwLFxuICAgICAgc2lnbk91dFxuICAgIH0pLFxuICAgIFtpc0xvYWRpbmcsIHVzZXIsIHNpZ25Jbiwgc2lnblVwLCBzaWduT3V0XVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChCbGlua0F1dGhDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlLCBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZUJsaW5rQXV0aCgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQmxpbmtBdXRoQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUJsaW5rQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmxpbmtBdXRoUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8vIHNyYy91c2UtYWdlbnQudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VNZW1vIGFzIHVzZU1lbW8yIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VBZ2VudChvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUJsaW5rQ2xpZW50KCk7XG4gIGNvbnN0IHsgYWdlbnQ6IGFnZW50SW5wdXQsIGluaXRpYWxNZXNzYWdlcyA9IFtdLCBzYW5kYm94LCBvbkZpbmlzaCwgb25FcnJvciB9ID0gb3B0aW9ucztcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZShpbml0aWFsTWVzc2FnZXMpO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFnZW50ID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiBjbGllbnQuYWkuYmluZEFnZW50KGFnZW50SW5wdXQpO1xuICB9LCBbYWdlbnRJbnB1dCwgY2xpZW50XSk7XG4gIGNvbnN0IGFnZW50TW9kZWwgPSBhZ2VudC5tb2RlbDtcbiAgY29uc3QgZ2VuZXJhdGVJZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gYG1zZ18ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOSl9YDtcbiAgfSwgW10pO1xuICBjb25zdCBwYXJzZVN0cmVhbSA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChyZXNwb25zZSwgYXNzaXN0YW50TWVzc2FnZUlkKSA9PiB7XG4gICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVzcG9uc2UgYm9keVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICAgIGxldCBjdXJyZW50VGV4dCA9IFwiXCI7XG4gICAgICBsZXQgY3VycmVudFBhcnRzID0gW107XG4gICAgICBsZXQgZmluaXNoRGF0YSA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgXCJcIjtcbiAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRMaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRyaW1tZWRMaW5lIHx8ICF0cmltbWVkTGluZS5zdGFydHNXaXRoKFwiZGF0YTpcIikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRyaW1tZWRMaW5lID09PSBcImRhdGE6IFtET05FXVwiIHx8IHRyaW1tZWRMaW5lID09PSBcImRhdGE6W0RPTkVdXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QganNvblN0ciA9IHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoXCJkYXRhOiBcIikgPyB0cmltbWVkTGluZS5zbGljZSg2KSA6IHRyaW1tZWRMaW5lLnNsaWNlKDUpO1xuICAgICAgICAgICAgICBpZiAoIWpzb25TdHIudHJpbSgpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoanNvblN0cik7XG4gICAgICAgICAgICAgIHN3aXRjaCAoanNvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRleHQgZXZlbnRzIChBSSBTREsgdjUgdXNlcyAndGV4dC1kZWx0YScgd2l0aCAnZGVsdGEnIHByb3BlcnR5KVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENodW5rID0ganNvbi5kZWx0YSB8fCBqc29uLnRleHREZWx0YSB8fCBqc29uLnZhbHVlIHx8IGpzb24udGV4dCB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQgKz0gdGV4dENodW5rO1xuICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZXMoXG4gICAgICAgICAgICAgICAgICAgIChwcmV2KSA9PiBwcmV2Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAobSkgPT4gbS5pZCA9PT0gYXNzaXN0YW50TWVzc2FnZUlkID8geyAuLi5tLCBjb250ZW50OiBjdXJyZW50VGV4dCwgcGFydHM6IFsuLi5jdXJyZW50UGFydHMuZmlsdGVyKChwKSA9PiBwLnR5cGUgIT09IFwidGV4dFwiKSwgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY3VycmVudFRleHQgfV0gfSA6IG1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdG9vbCBjYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVG9vbCA9IGN1cnJlbnRQYXJ0cy5maW5kKFxuICAgICAgICAgICAgICAgICAgICAocCkgPT4gcC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiICYmIHAudG9vbENhbGxJZCA9PT0ganNvbi50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1Rvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbFBhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWludm9jYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBqc29uLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGpzb24udG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBqc29uLmFyZ3MgfHwge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcnRzID0gWy4uLmN1cnJlbnRQYXJ0cy5maWx0ZXIoKHApID0+IHAudHlwZSAhPT0gXCJ0ZXh0XCIpLCB0b29sUGFydF07XG4gICAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKFxuICAgICAgICAgICAgICAgICAgICAgIChwcmV2KSA9PiBwcmV2Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChtKSA9PiBtLmlkID09PSBhc3Npc3RhbnRNZXNzYWdlSWQgPyB7IC4uLm0sIHBhcnRzOiBbLi4uY3VycmVudFBhcnRzLCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjdXJyZW50VGV4dCB9XSB9IDogbVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdG9vbCByZXN1bHQgZXZlbnRzXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0cyA9IGN1cnJlbnRQYXJ0cy5tYXAoXG4gICAgICAgICAgICAgICAgICAgIChwKSA9PiBwLnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIgJiYgcC50b29sQ2FsbElkID09PSBqc29uLnRvb2xDYWxsSWQgPyB7IC4uLnAsIHN0YXRlOiBcInJlc3VsdFwiLCBvdXRwdXQ6IGpzb24ucmVzdWx0IH0gOiBwXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZXMoXG4gICAgICAgICAgICAgICAgICAgIChwcmV2KSA9PiBwcmV2Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAobSkgPT4gbS5pZCA9PT0gYXNzaXN0YW50TWVzc2FnZUlkID8geyAuLi5tLCBwYXJ0czogWy4uLmN1cnJlbnRQYXJ0cy5maWx0ZXIoKHApID0+IHAudHlwZSAhPT0gXCJ0ZXh0XCIpLCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjdXJyZW50VGV4dCB9XSB9IDogbVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBmaW5pc2ggZXZlbnRcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImRvbmVcIjoge1xuICAgICAgICAgICAgICAgICAgZmluaXNoRGF0YSA9IGpzb247XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG90aGVyIGV2ZW50IHR5cGVzIChzdGFydCwgdGV4dC1zdGFydCwgdGV4dC1lbmQsIGV0Yy4pXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdGV4dDogY3VycmVudFRleHQsIGZpbmlzaERhdGEgfTtcbiAgICB9LFxuICAgIFtdXG4gICk7XG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGNvbnRlbnQpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50ID0gY29udGVudCA/PyBpbnB1dDtcbiAgICAgIGlmICghbWVzc2FnZUNvbnRlbnQudHJpbSgpICYmIG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBuZXdNZXNzYWdlcyA9IFsuLi5tZXNzYWdlc107XG4gICAgICAgIGlmIChtZXNzYWdlQ29udGVudC50cmltKCkpIHtcbiAgICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VDb250ZW50LnRyaW0oKVxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3TWVzc2FnZXMgPSBbLi4ubmV3TWVzc2FnZXMsIHVzZXJNZXNzYWdlXTtcbiAgICAgICAgICBzZXRNZXNzYWdlcyhuZXdNZXNzYWdlcyk7XG4gICAgICAgICAgc2V0SW5wdXQoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICBjb25zdCBhc3Npc3RhbnRNZXNzYWdlID0ge1xuICAgICAgICAgIGlkOiBhc3Npc3RhbnRNZXNzYWdlSWQsXG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgIHBhcnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBzZXRNZXNzYWdlcyhbLi4ubmV3TWVzc2FnZXMsIGFzc2lzdGFudE1lc3NhZ2VdKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZ2VudC5zdHJlYW0oe1xuICAgICAgICAgIG1lc3NhZ2VzOiBuZXdNZXNzYWdlcyxcbiAgICAgICAgICBzYW5kYm94LFxuICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHRleHQsIGZpbmlzaERhdGEgfSA9IGF3YWl0IHBhcnNlU3RyZWFtKHJlc3BvbnNlLCBhc3Npc3RhbnRNZXNzYWdlSWQpO1xuICAgICAgICBzZXRNZXNzYWdlcyhcbiAgICAgICAgICAocHJldikgPT4gcHJldi5tYXAoXG4gICAgICAgICAgICAobSkgPT4gbS5pZCA9PT0gYXNzaXN0YW50TWVzc2FnZUlkID8geyAuLi5tLCBjb250ZW50OiB0ZXh0IH0gOiBtXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBpZiAob25GaW5pc2ggJiYgZmluaXNoRGF0YSkge1xuICAgICAgICAgIG9uRmluaXNoKHtcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGZpbmlzaERhdGEuZmluaXNoUmVhc29uIHx8IFwic3RvcFwiLFxuICAgICAgICAgICAgc3RlcHM6IFtdLFxuICAgICAgICAgICAgdXNhZ2U6IGZpbmlzaERhdGEudXNhZ2UgfHwgeyBpbnB1dFRva2VuczogMCwgb3V0cHV0VG9rZW5zOiAwIH0sXG4gICAgICAgICAgICBfYmlsbGluZzogZmluaXNoRGF0YS5fYmlsbGluZyB8fCB7IG1vZGVsOiBhZ2VudE1vZGVsLCBjcmVkaXRzQ2hhcmdlZDogMCwgY29zdFVTRDogMCB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICAgIGlmIChlcnJvcjIubmFtZSAhPT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBzZXRFcnJvcihlcnJvcjIpO1xuICAgICAgICAgIG9uRXJyb3I/LihlcnJvcjIpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBbYWdlbnQsIGFnZW50TW9kZWwsIG1lc3NhZ2VzLCBpbnB1dCwgc2FuZGJveCwgZ2VuZXJhdGVJZCwgcGFyc2VTdHJlYW0sIG9uRmluaXNoLCBvbkVycm9yXVxuICApO1xuICBjb25zdCBhcHBlbmQgPSB1c2VDYWxsYmFjaygobWVzc2FnZSkgPT4ge1xuICAgIHNldE1lc3NhZ2VzKChwcmV2KSA9PiBbLi4ucHJldiwgeyAuLi5tZXNzYWdlLCBpZDogbWVzc2FnZS5pZCB8fCBnZW5lcmF0ZUlkKCkgfV0pO1xuICB9LCBbZ2VuZXJhdGVJZF0pO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChlKSA9PiB7XG4gICAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gICAgfSxcbiAgICBbXVxuICApO1xuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoZSkgPT4ge1xuICAgICAgZT8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbmRNZXNzYWdlKCk7XG4gICAgfSxcbiAgICBbc2VuZE1lc3NhZ2VdXG4gICk7XG4gIGNvbnN0IGFkZFRvb2xPdXRwdXQgPSB1c2VDYWxsYmFjayhcbiAgICAoeyB0b29sQ2FsbElkLCB0b29sLCBvdXRwdXQgfSkgPT4ge1xuICAgICAgc2V0TWVzc2FnZXMoXG4gICAgICAgIChwcmV2KSA9PiBwcmV2Lm1hcCgobSkgPT4ge1xuICAgICAgICAgIGlmIChtLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIW0ucGFydHMpIHJldHVybiBtO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQYXJ0cyA9IG0ucGFydHMubWFwKFxuICAgICAgICAgICAgKHApID0+IHAudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIiAmJiBwLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgJiYgcC50b29sTmFtZSA9PT0gdG9vbCA/IHsgLi4ucCwgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLCBvdXRwdXQgfSA6IHBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7IC4uLm0sIHBhcnRzOiB1cGRhdGVkUGFydHMgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgICBbXVxuICApO1xuICBjb25zdCBjbGVhck1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldE1lc3NhZ2VzKGluaXRpYWxNZXNzYWdlcyk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gIH0sIFtpbml0aWFsTWVzc2FnZXNdKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudD8uYWJvcnQoKTtcbiAgfSwgW10pO1xuICBjb25zdCByZWxvYWQgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgbGV0IGxhc3RVc2VySW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCBpID0gbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChtZXNzYWdlc1tpXS5yb2xlID09PSBcInVzZXJcIikge1xuICAgICAgICBsYXN0VXNlckluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0VXNlckluZGV4ID09PSAtMSkgcmV0dXJuO1xuICAgIGNvbnN0IG1lc3NhZ2VzVXBUb0xhc3RVc2VyID0gbWVzc2FnZXMuc2xpY2UoMCwgbGFzdFVzZXJJbmRleCArIDEpO1xuICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzVXBUb0xhc3RVc2VyKTtcbiAgICBhd2FpdCBzZW5kTWVzc2FnZSgpO1xuICB9LCBbbWVzc2FnZXMsIHNlbmRNZXNzYWdlXSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIGFwcGVuZCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgYWRkVG9vbE91dHB1dCxcbiAgICBjbGVhck1lc3NhZ2VzLFxuICAgIHN0b3AsXG4gICAgcmVsb2FkXG4gIH07XG59XG5leHBvcnQge1xuICBCbGlua0F1dGhQcm92aWRlcixcbiAgQmxpbmtQcm92aWRlcixcbiAgdXNlQWdlbnQsXG4gIHVzZUJsaW5rLFxuICB1c2VCbGlua0F1dGgsXG4gIHVzZUJsaW5rQ2xpZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@blinkdotnew/react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@blinkdotnew/sdk/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@blinkdotnew/sdk/dist/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: function() { return /* binding */ Agent; },\n/* harmony export */   AsyncStorageAdapter: function() { return /* binding */ AsyncStorageAdapter; },\n/* harmony export */   BlinkAIImpl: function() { return /* binding */ BlinkAIImpl; },\n/* harmony export */   BlinkAnalyticsImpl: function() { return /* binding */ BlinkAnalyticsImpl; },\n/* harmony export */   BlinkConnectorsImpl: function() { return /* binding */ BlinkConnectorsImpl; },\n/* harmony export */   BlinkDataImpl: function() { return /* binding */ BlinkDataImpl; },\n/* harmony export */   BlinkDatabase: function() { return /* binding */ BlinkDatabase; },\n/* harmony export */   BlinkRAGImpl: function() { return /* binding */ BlinkRAGImpl; },\n/* harmony export */   BlinkRealtimeChannel: function() { return /* binding */ BlinkRealtimeChannel; },\n/* harmony export */   BlinkRealtimeImpl: function() { return /* binding */ BlinkRealtimeImpl; },\n/* harmony export */   BlinkSandboxImpl: function() { return /* binding */ BlinkSandboxImpl; },\n/* harmony export */   BlinkStorageImpl: function() { return /* binding */ BlinkStorageImpl; },\n/* harmony export */   BlinkTable: function() { return /* binding */ BlinkTable; },\n/* harmony export */   NoOpStorageAdapter: function() { return /* binding */ NoOpStorageAdapter; },\n/* harmony export */   SANDBOX_TEMPLATES: function() { return /* binding */ SANDBOX_TEMPLATES; },\n/* harmony export */   SandboxConnectionError: function() { return /* binding */ SandboxConnectionError; },\n/* harmony export */   WebStorageAdapter: function() { return /* binding */ WebStorageAdapter; },\n/* harmony export */   coreTools: function() { return /* binding */ coreTools; },\n/* harmony export */   createClient: function() { return /* binding */ createClient; },\n/* harmony export */   dbDelete: function() { return /* binding */ dbDelete; },\n/* harmony export */   dbGet: function() { return /* binding */ dbGet; },\n/* harmony export */   dbInsert: function() { return /* binding */ dbInsert; },\n/* harmony export */   dbList: function() { return /* binding */ dbList; },\n/* harmony export */   dbTools: function() { return /* binding */ dbTools; },\n/* harmony export */   dbUpdate: function() { return /* binding */ dbUpdate; },\n/* harmony export */   editImage: function() { return /* binding */ editImage; },\n/* harmony export */   fetchUrl: function() { return /* binding */ fetchUrl; },\n/* harmony export */   generateImage: function() { return /* binding */ generateImage; },\n/* harmony export */   generateVideo: function() { return /* binding */ generateVideo; },\n/* harmony export */   getDefaultClient: function() { return /* binding */ getDefaultClient; },\n/* harmony export */   getDefaultStorageAdapter: function() { return /* binding */ getDefaultStorageAdapter; },\n/* harmony export */   getHost: function() { return /* binding */ getHost; },\n/* harmony export */   globFileSearch: function() { return /* binding */ globFileSearch; },\n/* harmony export */   grep: function() { return /* binding */ grep; },\n/* harmony export */   imageToVideo: function() { return /* binding */ imageToVideo; },\n/* harmony export */   isBrowser: function() { return /* binding */ isBrowser; },\n/* harmony export */   isDeno: function() { return /* binding */ isDeno; },\n/* harmony export */   isNode: function() { return /* binding */ isNode; },\n/* harmony export */   isReactNative: function() { return /* binding */ isReactNative; },\n/* harmony export */   isServer: function() { return /* binding */ isServer; },\n/* harmony export */   isWeb: function() { return /* binding */ isWeb; },\n/* harmony export */   listDir: function() { return /* binding */ listDir; },\n/* harmony export */   mediaTools: function() { return /* binding */ mediaTools; },\n/* harmony export */   platform: function() { return /* binding */ platform; },\n/* harmony export */   ragSearch: function() { return /* binding */ ragSearch; },\n/* harmony export */   ragTools: function() { return /* binding */ ragTools; },\n/* harmony export */   readFile: function() { return /* binding */ readFile; },\n/* harmony export */   runCode: function() { return /* binding */ runCode; },\n/* harmony export */   runTerminalCmd: function() { return /* binding */ runTerminalCmd; },\n/* harmony export */   sandboxTools: function() { return /* binding */ sandboxTools; },\n/* harmony export */   searchReplace: function() { return /* binding */ searchReplace; },\n/* harmony export */   serializeTools: function() { return /* binding */ serializeTools; },\n/* harmony export */   stepCountIs: function() { return /* binding */ stepCountIs; },\n/* harmony export */   storageCopy: function() { return /* binding */ storageCopy; },\n/* harmony export */   storageDelete: function() { return /* binding */ storageDelete; },\n/* harmony export */   storageDownload: function() { return /* binding */ storageDownload; },\n/* harmony export */   storageList: function() { return /* binding */ storageList; },\n/* harmony export */   storageMove: function() { return /* binding */ storageMove; },\n/* harmony export */   storagePublicUrl: function() { return /* binding */ storagePublicUrl; },\n/* harmony export */   storageTools: function() { return /* binding */ storageTools; },\n/* harmony export */   storageUpload: function() { return /* binding */ storageUpload; },\n/* harmony export */   webSearch: function() { return /* binding */ webSearch; },\n/* harmony export */   writeFile: function() { return /* binding */ writeFile; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// ../core/src/platform.ts\nfunction detectPlatform() {\n  if (typeof Deno !== \"undefined\") {\n    return \"deno\";\n  }\n  if (typeof process !== \"undefined\" && process.versions?.node) {\n    if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n      return \"react-native\";\n    }\n    return \"node\";\n  }\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return \"react-native\";\n  }\n  if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    return \"web\";\n  }\n  return \"node\";\n}\nvar platform = detectPlatform();\nvar isWeb = platform === \"web\";\nvar isReactNative = platform === \"react-native\";\nvar isNode = platform === \"node\";\nvar isDeno = platform === \"deno\";\nvar isBrowser = isWeb || isReactNative;\nvar isServer = isNode || isDeno;\n\n// ../core/src/storage-adapter.ts\nvar WebStorageAdapter = class {\n  getItem(key) {\n    try {\n      if (typeof localStorage === \"undefined\") return null;\n      return localStorage.getItem(key);\n    } catch (error) {\n      console.warn(\"Failed to get item from localStorage:\", error);\n      return null;\n    }\n  }\n  setItem(key, value) {\n    try {\n      if (typeof localStorage === \"undefined\") return;\n      localStorage.setItem(key, value);\n    } catch (error) {\n      console.warn(\"Failed to set item in localStorage:\", error);\n    }\n  }\n  removeItem(key) {\n    try {\n      if (typeof localStorage === \"undefined\") return;\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.warn(\"Failed to remove item from localStorage:\", error);\n    }\n  }\n  clear() {\n    try {\n      if (typeof localStorage === \"undefined\") return;\n      localStorage.clear();\n    } catch (error) {\n      console.warn(\"Failed to clear localStorage:\", error);\n    }\n  }\n};\nvar AsyncStorageAdapter = class {\n  constructor(asyncStorage) {\n    this.asyncStorage = asyncStorage;\n    if (!asyncStorage) {\n      throw new Error(\"AsyncStorage instance is required\");\n    }\n  }\n  async getItem(key) {\n    try {\n      return await this.asyncStorage.getItem(key);\n    } catch (error) {\n      console.warn(\"Failed to get item from AsyncStorage:\", error);\n      return null;\n    }\n  }\n  async setItem(key, value) {\n    try {\n      await this.asyncStorage.setItem(key, value);\n    } catch (error) {\n      console.warn(\"Failed to set item in AsyncStorage:\", error);\n    }\n  }\n  async removeItem(key) {\n    try {\n      await this.asyncStorage.removeItem(key);\n    } catch (error) {\n      console.warn(\"Failed to remove item from AsyncStorage:\", error);\n    }\n  }\n  async clear() {\n    try {\n      await this.asyncStorage.clear();\n    } catch (error) {\n      console.warn(\"Failed to clear AsyncStorage:\", error);\n    }\n  }\n};\nvar NoOpStorageAdapter = class {\n  getItem(_key) {\n    return null;\n  }\n  setItem(_key, _value) {\n  }\n  removeItem(_key) {\n  }\n  clear() {\n  }\n};\nfunction getDefaultStorageAdapter() {\n  if (isDeno) {\n    return new NoOpStorageAdapter();\n  }\n  if (typeof window !== \"undefined\" && typeof localStorage !== \"undefined\") {\n    try {\n      localStorage.setItem(\"__test__\", \"test\");\n      localStorage.removeItem(\"__test__\");\n      return new WebStorageAdapter();\n    } catch {\n    }\n  }\n  return new NoOpStorageAdapter();\n}\n\n// ../core/src/types.ts\nvar BlinkError = class extends Error {\n  constructor(message, code, status, details) {\n    super(message);\n    this.code = code;\n    this.status = status;\n    this.details = details;\n    this.name = \"BlinkError\";\n  }\n};\nvar BlinkAuthError = class extends BlinkError {\n  code;\n  retryable;\n  userMessage;\n  constructor(code, message, userMessage, details) {\n    super(message, code, 401, details);\n    this.name = \"BlinkAuthError\";\n    this.code = code;\n    this.retryable = [\"NETWORK_ERROR\", \"RATE_LIMITED\"].includes(code);\n    this.userMessage = userMessage || this.getDefaultUserMessage(code);\n  }\n  getDefaultUserMessage(code) {\n    switch (code) {\n      case \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */:\n        return \"Invalid email or password. Please try again.\";\n      case \"EMAIL_NOT_VERIFIED\" /* EMAIL_NOT_VERIFIED */:\n        return \"Please verify your email address before signing in.\";\n      case \"POPUP_CANCELED\" /* POPUP_CANCELED */:\n        return \"Sign-in was canceled. Please try again.\";\n      case \"NETWORK_ERROR\" /* NETWORK_ERROR */:\n        return \"Network error. Please check your connection and try again.\";\n      case \"RATE_LIMITED\" /* RATE_LIMITED */:\n        return \"Too many attempts. Please wait a moment and try again.\";\n      case \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */:\n        return \"Authentication timed out. Please try again.\";\n      case \"REDIRECT_FAILED\" /* REDIRECT_FAILED */:\n        return \"Redirect failed. Please try again.\";\n      case \"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */:\n        return \"Session expired. Please sign in again.\";\n      case \"USER_NOT_FOUND\" /* USER_NOT_FOUND */:\n        return \"User not found. Please check your email and try again.\";\n      case \"EMAIL_ALREADY_EXISTS\" /* EMAIL_ALREADY_EXISTS */:\n        return \"An account with this email already exists.\";\n      case \"WEAK_PASSWORD\" /* WEAK_PASSWORD */:\n        return \"Password is too weak. Please choose a stronger password.\";\n      case \"INVALID_EMAIL\" /* INVALID_EMAIL */:\n        return \"Please enter a valid email address.\";\n      case \"MAGIC_LINK_EXPIRED\" /* MAGIC_LINK_EXPIRED */:\n        return \"Magic link has expired. Please request a new one.\";\n      case \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */:\n        return \"Verification failed. Please try again.\";\n      default:\n        return \"Authentication error. Please try again.\";\n    }\n  }\n};\nvar BlinkNetworkError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"NETWORK_ERROR\", status, details);\n    this.name = \"BlinkNetworkError\";\n  }\n};\nvar BlinkValidationError = class extends BlinkError {\n  constructor(message, details) {\n    super(message, \"VALIDATION_ERROR\", 400, details);\n    this.name = \"BlinkValidationError\";\n  }\n};\nvar BlinkStorageError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"STORAGE_ERROR\", status, details);\n    this.name = \"BlinkStorageError\";\n  }\n};\nvar BlinkAIError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"AI_ERROR\", status, details);\n    this.name = \"BlinkAIError\";\n  }\n};\nvar BlinkDataError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"DATA_ERROR\", status, details);\n    this.name = \"BlinkDataError\";\n  }\n};\nvar BlinkRealtimeError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"REALTIME_ERROR\", status, details);\n    this.name = \"BlinkRealtimeError\";\n  }\n};\nvar BlinkNotificationsError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"NOTIFICATIONS_ERROR\", status, details);\n    this.name = \"BlinkNotificationsError\";\n  }\n};\n\n// ../core/src/query-builder.ts\nfunction camelToSnake(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction convertFilterKeysToSnakeCase(condition) {\n  if (!condition) return condition;\n  if (\"AND\" in condition) {\n    return {\n      AND: condition.AND?.map(convertFilterKeysToSnakeCase)\n    };\n  }\n  if (\"OR\" in condition) {\n    return {\n      OR: condition.OR?.map(convertFilterKeysToSnakeCase)\n    };\n  }\n  const converted = {};\n  for (const [field, value] of Object.entries(condition)) {\n    const snakeField = camelToSnake(field);\n    converted[snakeField] = value;\n  }\n  return converted;\n}\nfunction buildFilterQuery(condition) {\n  if (!condition) return \"\";\n  if (\"AND\" in condition) {\n    const andConditions = condition.AND?.map(buildFilterQuery).filter(Boolean) || [];\n    return andConditions.length > 0 ? `and=(${andConditions.join(\",\")})` : \"\";\n  }\n  if (\"OR\" in condition) {\n    const orConditions = condition.OR?.map(buildFilterQuery).filter(Boolean) || [];\n    return orConditions.length > 0 ? `or=(${orConditions.join(\",\")})` : \"\";\n  }\n  const params = [];\n  for (const [field, value] of Object.entries(condition)) {\n    if (value === void 0 || value === null) continue;\n    if (typeof value === \"object\" && !Array.isArray(value)) {\n      for (const [operator, operatorValue] of Object.entries(value)) {\n        const param = buildOperatorQuery(field, operator, operatorValue);\n        if (param) params.push(param);\n      }\n    } else {\n      params.push(`${field}=eq.${encodeQueryValue(value)}`);\n    }\n  }\n  return params.join(\"&\");\n}\nfunction buildOperatorQuery(field, operator, value) {\n  switch (operator) {\n    case \"eq\":\n      return `${field}=eq.${encodeQueryValue(value)}`;\n    case \"neq\":\n      return `${field}=neq.${encodeQueryValue(value)}`;\n    case \"gt\":\n      return `${field}=gt.${encodeQueryValue(value)}`;\n    case \"gte\":\n      return `${field}=gte.${encodeQueryValue(value)}`;\n    case \"lt\":\n      return `${field}=lt.${encodeQueryValue(value)}`;\n    case \"lte\":\n      return `${field}=lte.${encodeQueryValue(value)}`;\n    case \"like\":\n      return `${field}=like.${encodeQueryValue(value)}`;\n    case \"ilike\":\n      return `${field}=ilike.${encodeQueryValue(value)}`;\n    case \"is\":\n      return `${field}=is.${value === null ? \"null\" : encodeQueryValue(value)}`;\n    case \"not\":\n      return `${field}=not.${encodeQueryValue(value)}`;\n    case \"in\":\n      if (Array.isArray(value)) {\n        const values = value.map(encodeQueryValue).join(\",\");\n        return `${field}=in.(${values})`;\n      }\n      return \"\";\n    case \"not_in\":\n      if (Array.isArray(value)) {\n        const values = value.map(encodeQueryValue).join(\",\");\n        return `${field}=not.in.(${values})`;\n      }\n      return \"\";\n    default:\n      return \"\";\n  }\n}\nfunction encodeQueryValue(value) {\n  if (value === null) return \"null\";\n  if (typeof value === \"boolean\") {\n    return value ? \"1\" : \"0\";\n  }\n  if (typeof value === \"number\") return value.toString();\n  return encodeURIComponent(String(value));\n}\nfunction buildQuery(options = {}) {\n  const params = {};\n  if (options.select && options.select.length > 0) {\n    const snakeFields = options.select.map(camelToSnake);\n    params.select = snakeFields.join(\",\");\n  } else {\n    params.select = \"*\";\n  }\n  if (options.where) {\n    const convertedWhere = convertFilterKeysToSnakeCase(options.where);\n    const filterQuery = buildFilterQuery(convertedWhere);\n    if (filterQuery) {\n      const filterParams = filterQuery.split(\"&\");\n      for (const param of filterParams) {\n        const [key, value] = param.split(\"=\", 2);\n        if (key && value) {\n          params[key] = value;\n        }\n      }\n    }\n  }\n  if (options.orderBy) {\n    if (typeof options.orderBy === \"string\") {\n      params.order = options.orderBy;\n    } else {\n      const orderClauses = Object.entries(options.orderBy).map(([field, direction]) => `${camelToSnake(field)}.${direction}`);\n      params.order = orderClauses.join(\",\");\n    }\n  }\n  if (options.limit !== void 0) {\n    params.limit = options.limit.toString();\n  }\n  if (options.offset !== void 0) {\n    params.offset = options.offset.toString();\n  }\n  if (options.cursor) {\n    params.cursor = options.cursor;\n  }\n  return params;\n}\n\n// ../core/src/http-client.ts\nfunction camelToSnake2(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction snakeToCamel(str) {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\nfunction convertKeysToSnakeCase(obj) {\n  if (obj === null || obj === void 0) return obj;\n  if (typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.map(convertKeysToSnakeCase);\n  const converted = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const snakeKey = camelToSnake2(key);\n    converted[snakeKey] = convertKeysToSnakeCase(value);\n  }\n  return converted;\n}\nfunction convertKeysToCamelCase(obj) {\n  if (obj === null || obj === void 0) return obj;\n  if (typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.map(convertKeysToCamelCase);\n  const converted = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const camelKey = snakeToCamel(key);\n    converted[camelKey] = convertKeysToCamelCase(value);\n  }\n  return converted;\n}\nvar HttpClient = class {\n  authUrl = \"https://blink.new\";\n  coreUrl = \"https://core.blink.new\";\n  projectId;\n  publishableKey;\n  secretKey;\n  // Permanent, non-expiring key (like Stripe's sk_live_...)\n  getToken;\n  getValidToken;\n  constructor(config, getToken, getValidToken) {\n    this.projectId = config.projectId;\n    this.publishableKey = config.publishableKey;\n    this.secretKey = config.secretKey || config.serviceToken;\n    this.getToken = getToken;\n    this.getValidToken = getValidToken;\n  }\n  shouldAttachPublishableKey(path, method) {\n    if (method !== \"GET\" && method !== \"POST\") return false;\n    if (path.includes(\"/api/analytics/\")) return true;\n    if (path.includes(\"/api/storage/\")) return true;\n    if (path.includes(\"/api/db/\") && path.includes(\"/rest/v1/\")) return method === \"GET\";\n    return false;\n  }\n  shouldSkipSecretKey(url) {\n    try {\n      const parsed = new URL(url);\n      return parsed.hostname.endsWith(\".functions.blink.new\");\n    } catch {\n      return false;\n    }\n  }\n  getAuthorizationHeader(url, token) {\n    if (this.secretKey && !this.shouldSkipSecretKey(url)) {\n      return `Bearer ${this.secretKey}`;\n    }\n    if (token) {\n      return `Bearer ${token}`;\n    }\n    return null;\n  }\n  /**\n   * Make an authenticated request to the Blink API\n   */\n  async request(path, options = {}) {\n    const url = this.buildUrl(path, options.searchParams);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const method = options.method || \"GET\";\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      ...options.headers\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) {\n      headers.Authorization = auth;\n    } else if (this.publishableKey && !headers[\"x-blink-publishable-key\"] && this.shouldAttachPublishableKey(path, method)) {\n      headers[\"x-blink-publishable-key\"] = this.publishableKey;\n    }\n    const requestInit = {\n      method,\n      headers,\n      signal: options.signal\n    };\n    if (options.body && method !== \"GET\") {\n      requestInit.body = typeof options.body === \"string\" ? options.body : JSON.stringify(options.body);\n    }\n    try {\n      const response = await fetch(url, requestInit);\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      const data = await this.parseResponse(response);\n      return {\n        data,\n        status: response.status,\n        headers: response.headers\n      };\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Network request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * GET request\n   */\n  async get(path, searchParams) {\n    return this.request(path, { method: \"GET\", searchParams });\n  }\n  /**\n   * POST request\n   */\n  async post(path, body, headers) {\n    return this.request(path, { method: \"POST\", body, headers });\n  }\n  /**\n   * PATCH request\n   */\n  async patch(path, body, headers) {\n    return this.request(path, { method: \"PATCH\", body, headers });\n  }\n  /**\n   * DELETE request\n   */\n  async delete(path, searchParams) {\n    return this.request(path, { method: \"DELETE\", searchParams });\n  }\n  /**\n   * Database-specific requests\n   */\n  // Table operations (PostgREST-compatible)\n  async dbGet(table, searchParams) {\n    const response = await this.get(`/api/db/${this.projectId}/rest/v1/${table}`, searchParams);\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbPost(table, body, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const convertedBody = convertKeysToSnakeCase(body);\n    const response = await this.post(`/api/db/${this.projectId}/rest/v1/${table}`, convertedBody, headers);\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbPatch(table, body, searchParams, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const convertedBody = convertKeysToSnakeCase(body);\n    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {\n      method: \"PATCH\",\n      body: convertedBody,\n      headers,\n      searchParams\n    });\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbDelete(table, searchParams, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {\n      method: \"DELETE\",\n      headers,\n      searchParams\n    });\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  // Raw SQL operations\n  async dbSql(query, params) {\n    const response = await this.post(`/api/db/${this.projectId}/sql`, { query, params });\n    const convertedData = {\n      ...response.data,\n      rows: convertKeysToCamelCase(response.data.rows)\n    };\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  // Batch SQL operations\n  async dbBatch(statements, mode = \"write\") {\n    const response = await this.post(`/api/db/${this.projectId}/batch`, { statements, mode });\n    const convertedData = {\n      ...response.data,\n      results: response.data.results.map((result) => ({\n        ...result,\n        rows: convertKeysToCamelCase(result.rows)\n      }))\n    };\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  /**\n   * Upload file with progress tracking\n   */\n  async uploadFile(path, file, filePath, options = {}) {\n    const url = this.buildUrl(path);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const formData = new FormData();\n    if (file instanceof File) {\n      formData.append(\"file\", file);\n    } else if (file instanceof Blob) {\n      const blobWithType = options.contentType ? new Blob([file], { type: options.contentType }) : file;\n      formData.append(\"file\", blobWithType);\n    } else if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n      const blob = new Blob([file], { type: options.contentType || \"application/octet-stream\" });\n      formData.append(\"file\", blob);\n    } else {\n      throw new BlinkValidationError(\"Unsupported file type\");\n    }\n    formData.append(\"path\", filePath);\n    const headers = {};\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) {\n      headers.Authorization = auth;\n    } else if (this.publishableKey && path.includes(\"/api/storage/\") && !headers[\"x-blink-publishable-key\"]) {\n      headers[\"x-blink-publishable-key\"] = this.publishableKey;\n    }\n    try {\n      if (typeof XMLHttpRequest !== \"undefined\" && options.onProgress) {\n        return this.uploadWithProgress(url, formData, headers, options.onProgress);\n      }\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: formData\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      const data = await this.parseResponse(response);\n      return {\n        data,\n        status: response.status,\n        headers: response.headers\n      };\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `File upload failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Upload with progress tracking using XMLHttpRequest\n   */\n  uploadWithProgress(url, formData, headers, onProgress) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          const percent = Math.round(event.loaded / event.total * 100);\n          onProgress(percent);\n        }\n      });\n      xhr.addEventListener(\"load\", async () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            const data = JSON.parse(xhr.responseText);\n            resolve({\n              data,\n              status: xhr.status,\n              headers: new Headers()\n              // XMLHttpRequest doesn't provide easy access to response headers\n            });\n          } catch (error) {\n            reject(new BlinkNetworkError(\"Failed to parse response\", xhr.status));\n          }\n        } else {\n          try {\n            const errorData = JSON.parse(xhr.responseText);\n            const message = errorData.error?.message || errorData.message || `HTTP ${xhr.status}`;\n            switch (xhr.status) {\n              case 401:\n                reject(new BlinkAuthError(message, errorData));\n                break;\n              case 400:\n                reject(new BlinkValidationError(message, errorData));\n                break;\n              default:\n                reject(new BlinkNetworkError(message, xhr.status, errorData));\n            }\n          } catch {\n            reject(new BlinkNetworkError(`HTTP ${xhr.status}`, xhr.status));\n          }\n        }\n      });\n      xhr.addEventListener(\"error\", () => {\n        reject(new BlinkNetworkError(\"Network error during file upload\"));\n      });\n      xhr.open(\"POST\", url);\n      Object.entries(headers).forEach(([key, value]) => {\n        xhr.setRequestHeader(key, value);\n      });\n      xhr.send(formData);\n    });\n  }\n  /**\n   * AI-specific requests\n   */\n  async aiText(prompt, options = {}) {\n    const { signal, ...body } = options;\n    const requestBody = { ...body };\n    if (prompt) {\n      requestBody.prompt = prompt;\n    }\n    return this.request(`/api/ai/${this.projectId}/text`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * Stream AI text generation - uses Vercel AI SDK's pipeUIMessageStreamToResponse (Data Stream Protocol)\n   */\n  async streamAiText(prompt, options = {}, onChunk) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/text`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const body = {\n      prompt,\n      stream: true,\n      ...options\n    };\n    const { signal: _signal, ...jsonBody } = body;\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(jsonBody),\n        signal: options.signal\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      if (!response.body) {\n        throw new BlinkNetworkError(\"No response body for streaming\");\n      }\n      return this.parseDataStreamProtocol(response.body, onChunk);\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Streaming request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  async aiObject(prompt, options = {}) {\n    const { signal, ...body } = options;\n    const requestBody = { ...body };\n    if (prompt) {\n      requestBody.prompt = prompt;\n    }\n    return this.request(`/api/ai/${this.projectId}/object`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * Stream AI object generation - uses Vercel AI SDK's pipeTextStreamToResponse\n   */\n  async streamAiObject(prompt, options = {}, onPartial) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/object`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const body = {\n      prompt,\n      stream: true,\n      ...options\n    };\n    const { signal: _signal2, ...jsonBody2 } = body;\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(jsonBody2),\n        signal: options.signal\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      if (!response.body) {\n        throw new BlinkNetworkError(\"No response body for streaming\");\n      }\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = \"\";\n      let latestObject = {};\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          const chunk = decoder.decode(value, { stream: true });\n          buffer += chunk;\n          try {\n            const parsed = JSON.parse(buffer);\n            latestObject = parsed;\n            if (onPartial) {\n              onPartial(parsed);\n            }\n          } catch {\n          }\n        }\n        if (buffer) {\n          try {\n            latestObject = JSON.parse(buffer);\n          } catch {\n          }\n        }\n        return { object: latestObject };\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Streaming request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  async aiImage(prompt, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/image`, {\n      method: \"POST\",\n      body: {\n        prompt,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiSpeech(text, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/speech`, {\n      method: \"POST\",\n      body: {\n        text,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiTranscribe(audio, options = {}) {\n    const { signal, ...body } = options;\n    let payloadAudio;\n    if (typeof audio === \"string\" || Array.isArray(audio)) {\n      payloadAudio = audio;\n    } else if (audio instanceof Uint8Array) {\n      payloadAudio = Array.from(audio);\n    } else if (audio instanceof ArrayBuffer) {\n      payloadAudio = Array.from(new Uint8Array(audio));\n    } else if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(audio)) {\n      payloadAudio = Array.from(new Uint8Array(audio));\n    } else {\n      throw new BlinkValidationError(\"Unsupported audio input type\");\n    }\n    return this.request(`/api/ai/${this.projectId}/transcribe`, {\n      method: \"POST\",\n      body: {\n        audio: payloadAudio,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiVideo(prompt, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/video`, {\n      method: \"POST\",\n      body: {\n        prompt,\n        ...body\n      },\n      signal\n    });\n  }\n  /**\n   * AI Agent request (non-streaming)\n   * Returns JSON response with text, steps, usage, and billing\n   */\n  async aiAgent(requestBody, signal) {\n    return this.request(`/api/ai/${this.projectId}/agent`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * AI Agent streaming request\n   * Returns raw Response for SSE streaming (compatible with AI SDK useChat)\n   */\n  async aiAgentStream(requestBody, signal) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/agent`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(requestBody),\n      signal\n    });\n    if (!response.ok) {\n      await this.handleErrorResponse(response);\n    }\n    return response;\n  }\n  /**\n   * RAG AI Search streaming request\n   * Returns raw Response for SSE streaming\n   */\n  async ragAiSearchStream(body, signal) {\n    const url = this.buildUrl(`/api/rag/${this.projectId}/ai-search`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body),\n      signal\n    });\n    if (!response.ok) {\n      await this.handleErrorResponse(response);\n    }\n    return response;\n  }\n  /**\n   * Data-specific requests\n   */\n  async dataExtractFromUrl(projectId, request) {\n    return this.request(`/api/data/${projectId}/extract-from-url`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataExtractFromBlob(projectId, file, chunking, chunkSize) {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    if (chunking !== void 0) {\n      formData.append(\"chunking\", String(chunking));\n    }\n    if (chunkSize !== void 0) {\n      formData.append(\"chunkSize\", String(chunkSize));\n    }\n    return this.request(`/api/data/${projectId}/extract-from-blob`, {\n      method: \"POST\",\n      body: formData\n    });\n  }\n  async dataScrape(projectId, request) {\n    return this.request(`/api/data/${projectId}/scrape`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataScreenshot(projectId, request) {\n    return this.request(`/api/data/${projectId}/screenshot`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataFetch(projectId, request) {\n    return this.post(`/api/data/${projectId}/fetch`, request);\n  }\n  async dataSearch(projectId, request) {\n    return this.post(`/api/data/${projectId}/search`, request);\n  }\n  /**\n   * Connector requests\n   */\n  formatProviderForPath(provider) {\n    return provider.replace(\"_\", \"-\");\n  }\n  async connectorStatus(provider) {\n    return this.request(`/api/connectors/${this.formatProviderForPath(provider)}/${this.projectId}/status`, {\n      method: \"GET\"\n    });\n  }\n  async connectorExecute(provider, request) {\n    const path = request.method.startsWith(\"/\") ? request.method : `/${request.method}`;\n    const url = `/api/connectors/${this.formatProviderForPath(provider)}/${this.projectId}${path}`;\n    const method = (request.http_method || \"GET\").toUpperCase();\n    if (method === \"GET\") {\n      return this.request(url, {\n        method: \"GET\",\n        searchParams: request.params\n      });\n    }\n    return this.request(url, {\n      method,\n      body: request.params || {}\n    });\n  }\n  async connectorSaveApiKey(provider, request) {\n    return this.request(`/api/connectors/${this.formatProviderForPath(provider)}/${this.projectId}/api-key`, {\n      method: \"POST\",\n      body: request\n    });\n  }\n  /**\n   * Realtime-specific requests\n   */\n  async realtimePublish(projectId, request) {\n    return this.post(`/api/realtime/${projectId}/publish`, request);\n  }\n  async realtimeGetPresence(projectId, channel) {\n    return this.get(`/api/realtime/${projectId}/presence`, { channel });\n  }\n  async realtimeGetMessages(projectId, options) {\n    const { channel, ...searchParams } = options;\n    return this.get(`/api/realtime/${projectId}/messages`, {\n      channel,\n      ...Object.fromEntries(\n        Object.entries(searchParams).filter(([k, v]) => v !== void 0).map(([k, v]) => [k, String(v)])\n      )\n    });\n  }\n  /**\n   * Private helper methods\n   */\n  buildUrl(path, searchParams) {\n    const baseUrl = path.includes(\"/api/auth/\") ? this.authUrl : this.coreUrl;\n    const url = new URL(path, baseUrl);\n    if (searchParams) {\n      Object.entries(searchParams).forEach(([key, value]) => {\n        url.searchParams.set(key, value);\n      });\n    }\n    return url.toString();\n  }\n  async parseResponse(response) {\n    const contentType = response.headers.get(\"content-type\");\n    if (contentType?.includes(\"application/json\")) {\n      return response.json();\n    }\n    if (contentType?.includes(\"text/\")) {\n      return response.text();\n    }\n    return response.blob();\n  }\n  async handleErrorResponse(response) {\n    let errorData;\n    try {\n      const contentType = response.headers.get(\"content-type\");\n      if (contentType?.includes(\"application/json\")) {\n        errorData = await response.json();\n      } else {\n        errorData = { message: await response.text() };\n      }\n    } catch {\n      errorData = { message: \"Unknown error occurred\" };\n    }\n    const message = errorData.error?.message || errorData.message || `HTTP ${response.status}`;\n    errorData.error?.code || errorData.code;\n    switch (response.status) {\n      case 401:\n        throw new BlinkAuthError(message, errorData);\n      case 400:\n        throw new BlinkValidationError(message, errorData);\n      default:\n        throw new BlinkNetworkError(message, response.status, errorData);\n    }\n  }\n  /**\n   * Parse Vercel AI SDK v5 Data Stream Protocol (Server-Sent Events)\n   * Supports all event types from the UI Message Stream protocol\n   */\n  async parseDataStreamProtocol(body, onChunk) {\n    const reader = body.getReader();\n    const decoder = new TextDecoder();\n    const finalResult = {\n      text: \"\",\n      toolCalls: [],\n      toolResults: [],\n      sources: [],\n      files: [],\n      reasoning: []\n    };\n    let buffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split(\"\\n\");\n        buffer = lines.pop() || \"\";\n        for (const line of lines) {\n          if (!line.trim()) continue;\n          if (line === \"[DONE]\") {\n            continue;\n          }\n          if (!line.startsWith(\"data: \")) continue;\n          try {\n            const jsonStr = line.slice(6);\n            const part = JSON.parse(jsonStr);\n            switch (part.type) {\n              case \"text-start\":\n                break;\n              case \"text-delta\":\n                if (part.delta) {\n                  finalResult.text += part.delta;\n                  if (onChunk) onChunk(part.delta);\n                }\n                if (part.textDelta) {\n                  finalResult.text += part.textDelta;\n                  if (onChunk) onChunk(part.textDelta);\n                }\n                break;\n              case \"text-end\":\n                break;\n              case \"tool-call\":\n                finalResult.toolCalls.push({\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  args: part.args\n                });\n                break;\n              case \"tool-result\":\n                finalResult.toolResults.push({\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  result: part.result\n                });\n                break;\n              case \"source-url\":\n                finalResult.sources.push({\n                  id: part.id,\n                  url: part.url,\n                  title: part.title\n                });\n                break;\n              case \"file\":\n                finalResult.files.push(part.file);\n                break;\n              case \"reasoning\":\n                finalResult.reasoning.push(part.content);\n                break;\n              case \"finish\":\n                finalResult.finishReason = part.finishReason;\n                finalResult.usage = part.usage;\n                if (part.response) finalResult.response = part.response;\n                break;\n              case \"error\":\n                finalResult.error = part.error;\n                throw new Error(part.error);\n              case \"data\":\n                if (!finalResult.customData) finalResult.customData = [];\n                finalResult.customData.push(part.value);\n                break;\n            }\n          } catch (e) {\n          }\n        }\n      }\n      return finalResult;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n};\n\n// src/utils/browser-env.ts\nfunction hasWindow() {\n  return typeof window !== \"undefined\";\n}\nfunction hasWindowLocation() {\n  return typeof window !== \"undefined\" && typeof window.location !== \"undefined\";\n}\nfunction hasDocument() {\n  return typeof document !== \"undefined\";\n}\nfunction isReactNative2() {\n  return typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\n}\nfunction getWindowLocation() {\n  if (!hasWindow()) return null;\n  try {\n    return window.location;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHref() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.href;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationOrigin() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.origin;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHostname() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.hostname;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationPathname() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.pathname;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationSearch() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.search;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHash() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.hash;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationProtocol() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.protocol;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHost() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.host;\n  } catch {\n    return null;\n  }\n}\nfunction constructFullUrl() {\n  if (!hasWindow()) return null;\n  const protocol = getLocationProtocol();\n  const host = getLocationHost();\n  const pathname = getLocationPathname();\n  const search = getLocationSearch();\n  const hash = getLocationHash();\n  if (!protocol || !host) return null;\n  return `${protocol}//${host}${pathname || \"\"}${search || \"\"}${hash || \"\"}`;\n}\nfunction getDocumentReferrer() {\n  if (!hasDocument()) return null;\n  try {\n    return document.referrer || null;\n  } catch {\n    return null;\n  }\n}\nfunction getWindowInnerWidth() {\n  if (!hasWindow()) return null;\n  try {\n    return window.innerWidth;\n  } catch {\n    return null;\n  }\n}\nfunction isIframe() {\n  if (!hasWindow()) return false;\n  try {\n    return window.self !== window.top;\n  } catch {\n    return true;\n  }\n}\nfunction getSessionStorage() {\n  if (!hasWindow()) return null;\n  try {\n    return window.sessionStorage;\n  } catch {\n    return null;\n  }\n}\n\n// src/auth.ts\nvar BlinkAuth = class {\n  config;\n  authConfig;\n  authState;\n  listeners = /* @__PURE__ */ new Set();\n  authUrl;\n  coreUrl;\n  parentWindowTokens = null;\n  isIframe = false;\n  initializationPromise = null;\n  isInitialized = false;\n  storage;\n  constructor(config) {\n    this.config = config;\n    if (!config.projectId) {\n      throw new Error(\"projectId is required for authentication\");\n    }\n    this.authConfig = {\n      mode: \"managed\",\n      // Default mode\n      authUrl: \"https://blink.new\",\n      coreUrl: \"https://core.blink.new\",\n      detectSessionInUrl: true,\n      // Default to true for web compatibility\n      ...config.auth\n    };\n    this.authUrl = this.authConfig.authUrl || \"https://blink.new\";\n    this.coreUrl = this.authConfig.coreUrl || \"https://core.blink.new\";\n    const hostname = getLocationHostname();\n    if (hostname && this.authUrl === \"https://blink.new\" && (hostname === \"localhost\" || hostname === \"127.0.0.1\")) {\n      console.warn(\"\\u26A0\\uFE0F Using default authUrl in development. Set auth.authUrl to your app origin for headless auth endpoints to work.\");\n    }\n    if (config.authRequired !== void 0 && !config.auth?.mode) {\n      this.authConfig.mode = config.authRequired ? \"managed\" : \"headless\";\n    }\n    this.authState = {\n      user: null,\n      tokens: null,\n      isAuthenticated: false,\n      isLoading: false\n    };\n    this.storage = config.auth?.storage || config.storage || getDefaultStorageAdapter();\n    if (isWeb) {\n      this.isIframe = isIframe();\n      this.setupParentWindowListener();\n      this.setupCrossTabSync();\n      this.initializationPromise = this.initialize();\n    } else {\n      this.isInitialized = true;\n    }\n  }\n  /**\n   * Generate project-scoped storage key\n   */\n  getStorageKey(suffix) {\n    return `blink_${suffix}_${this.config.projectId}`;\n  }\n  /**\n   * Migrate existing global tokens to project-scoped storage\n   * DISABLED: We don't migrate global blink_tokens anymore because:\n   * 1. Platform uses blink_tokens for platform auth (different user)\n   * 2. Migrating platform tokens would cause project to show wrong user\n   * 3. Projects should always authenticate fresh via their own flow\n   */\n  migrateExistingTokens() {\n  }\n  /**\n   * Wait for authentication initialization to complete\n   */\n  async waitForInitialization() {\n    if (this.isInitialized) return;\n    if (this.initializationPromise) {\n      await this.initializationPromise;\n    }\n  }\n  /**\n   * Setup listener for tokens from parent window\n   */\n  setupParentWindowListener() {\n    if (!isWeb || !this.isIframe || !hasWindow()) return;\n    window.addEventListener(\"message\", (event) => {\n      if (event.origin !== \"https://blink.new\" && event.origin !== \"http://localhost:3000\" && event.origin !== \"http://localhost:3001\") {\n        return;\n      }\n      if (event.data?.type === \"BLINK_AUTH_TOKENS\") {\n        console.log(\"\\u{1F4E5} Received auth tokens from parent window\");\n        const { tokens } = event.data;\n        if (tokens) {\n          this.parentWindowTokens = tokens;\n          this.setTokens(tokens, false).then(() => {\n            console.log(\"\\u2705 Tokens from parent window applied\");\n          }).catch((error) => {\n            console.error(\"Failed to apply parent window tokens:\", error);\n          });\n        }\n      }\n      if (event.data?.type === \"BLINK_AUTH_LOGOUT\") {\n        console.log(\"\\u{1F4E4} Received logout command from parent window\");\n        this.clearTokens();\n      }\n    });\n    if (hasWindow() && window.parent !== window) {\n      console.log(\"\\u{1F504} Requesting auth tokens from parent window\");\n      window.parent.postMessage({\n        type: \"BLINK_REQUEST_AUTH_TOKENS\",\n        projectId: this.config.projectId\n      }, \"*\");\n    }\n  }\n  /**\n   * Initialize authentication from stored tokens or URL fragments\n   */\n  async initialize() {\n    console.log(\"\\u{1F680} Initializing Blink Auth...\");\n    this.setLoading(true);\n    try {\n      this.migrateExistingTokens();\n      if (this.isIframe) {\n        console.log(\"\\u{1F50D} Detected iframe environment, waiting for parent tokens...\");\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        if (this.parentWindowTokens) {\n          console.log(\"\\u2705 Using tokens from parent window\");\n          await this.setTokens(this.parentWindowTokens, false);\n          return;\n        }\n      }\n      if (this.authConfig.detectSessionInUrl !== false) {\n        const tokensFromUrl = this.extractTokensFromUrl();\n        if (tokensFromUrl) {\n          console.log(\"\\u{1F4E5} Found tokens in URL, setting them...\");\n          await this.setTokens(tokensFromUrl, true);\n          this.clearUrlTokens();\n          console.log(\"\\u2705 Auth initialization complete (from URL)\");\n          return;\n        }\n      }\n      const storedTokens = await this.getStoredTokens();\n      if (storedTokens) {\n        console.log(\"\\u{1F4BE} Found stored tokens, validating...\", {\n          hasAccessToken: !!storedTokens.access_token,\n          hasRefreshToken: !!storedTokens.refresh_token,\n          issuedAt: storedTokens.issued_at,\n          expiresIn: storedTokens.expires_in,\n          refreshExpiresIn: storedTokens.refresh_expires_in,\n          currentTime: Math.floor(Date.now() / 1e3)\n        });\n        this.authState.tokens = storedTokens;\n        console.log(\"\\u{1F527} Tokens set in auth state, refresh token available:\", !!this.authState.tokens?.refresh_token);\n        const isValid = await this.validateStoredTokens(storedTokens);\n        if (isValid) {\n          console.log(\"\\u2705 Auth initialization complete (from storage)\");\n          return;\n        } else {\n          console.log(\"\\u{1F504} Stored tokens invalid, clearing...\");\n          this.clearTokens();\n        }\n      }\n      console.log(\"\\u274C No tokens found\");\n      if (this.config.authRequired && hasWindowLocation()) {\n        console.log(\"\\u{1F504} Auth required, redirecting to auth page...\");\n        this.redirectToAuth();\n      } else {\n        console.log(\"\\u26A0\\uFE0F Auth not required or no window.location, continuing without authentication\");\n      }\n    } finally {\n      this.setLoading(false);\n      this.isInitialized = true;\n    }\n  }\n  /**\n   * Redirect to Blink auth page\n   */\n  login(nextUrl) {\n    if (!hasWindowLocation()) {\n      console.warn(\"login() called in non-browser environment (no window.location available)\");\n      return;\n    }\n    let redirectUrl = nextUrl || this.authConfig.redirectUrl;\n    if (!redirectUrl) {\n      const href = getLocationHref();\n      if (href && href.startsWith(\"http\")) {\n        redirectUrl = href;\n      } else {\n        redirectUrl = constructFullUrl() || void 0;\n      }\n    }\n    if (redirectUrl) {\n      try {\n        const url = new URL(redirectUrl);\n        url.searchParams.delete(\"redirect_url\");\n        url.searchParams.delete(\"redirect\");\n        redirectUrl = url.toString();\n      } catch (e) {\n        console.warn(\"Failed to parse redirect URL:\", e);\n      }\n    }\n    const authUrl = new URL(\"/auth\", this.authUrl);\n    authUrl.searchParams.set(\"redirect_url\", redirectUrl || \"\");\n    if (this.config.projectId) {\n      authUrl.searchParams.set(\"project_id\", this.config.projectId);\n    }\n    window.location.href = authUrl.toString();\n  }\n  /**\n   * Logout and clear stored tokens\n   */\n  logout(redirectUrl) {\n    this.clearTokens();\n    if (redirectUrl && hasWindowLocation()) {\n      window.location.href = redirectUrl;\n    }\n  }\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated() {\n    return this.authState.isAuthenticated;\n  }\n  /**\n   * Get current user (sync)\n   */\n  currentUser() {\n    return this.authState.user;\n  }\n  /**\n   * Get current access token\n   */\n  getToken() {\n    return this.authState.tokens?.access_token || null;\n  }\n  /**\n   * Check if access token is expired based on timestamp\n   */\n  isAccessTokenExpired() {\n    const tokens = this.authState.tokens;\n    if (!tokens || !tokens.issued_at) {\n      return true;\n    }\n    const now = Math.floor(Date.now() / 1e3);\n    const expiresAt = tokens.issued_at + tokens.expires_in;\n    const bufferTime = 30;\n    return now >= expiresAt - bufferTime;\n  }\n  /**\n   * Check if refresh token is expired based on timestamp\n   */\n  isRefreshTokenExpired() {\n    const tokens = this.authState.tokens;\n    if (!tokens || !tokens.refresh_token || !tokens.issued_at || !tokens.refresh_expires_in) {\n      return true;\n    }\n    const now = Math.floor(Date.now() / 1e3);\n    const expiresAt = tokens.issued_at + tokens.refresh_expires_in;\n    return now >= expiresAt;\n  }\n  /**\n   * Get a valid access token, refreshing if necessary\n   */\n  async getValidToken() {\n    const tokens = this.authState.tokens;\n    if (!tokens) {\n      return null;\n    }\n    if (!this.isAccessTokenExpired()) {\n      console.log(\"\\u2705 Access token is still valid\");\n      return tokens.access_token;\n    }\n    console.log(\"\\u23F0 Access token expired, attempting refresh...\");\n    if (this.isRefreshTokenExpired()) {\n      console.log(\"\\u274C Refresh token also expired, clearing tokens\");\n      this.clearTokens();\n      if (this.config.authRequired) {\n        this.redirectToAuth();\n      }\n      return null;\n    }\n    const refreshed = await this.refreshToken();\n    if (refreshed) {\n      console.log(\"\\u2705 Token refreshed successfully\");\n      return this.authState.tokens?.access_token || null;\n    } else {\n      console.log(\"\\u274C Token refresh failed\");\n      this.clearTokens();\n      if (this.config.authRequired) {\n        this.redirectToAuth();\n      }\n      return null;\n    }\n  }\n  /**\n   * Fetch current user profile from API\n   * Gracefully waits for auth initialization to complete before throwing errors\n   */\n  async me() {\n    await this.waitForInitialization();\n    if (this.authState.isAuthenticated && this.authState.user) {\n      return this.authState.user;\n    }\n    if (!this.authState.isAuthenticated) {\n      return new Promise((resolve, reject) => {\n        if (this.authState.user) {\n          resolve(this.authState.user);\n          return;\n        }\n        const timeout = setTimeout(() => {\n          unsubscribe();\n          reject(new BlinkAuthError(\"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */, \"Authentication timeout - no user available\"));\n        }, 5e3);\n        const unsubscribe = this.onAuthStateChanged((state) => {\n          if (state.user) {\n            clearTimeout(timeout);\n            unsubscribe();\n            resolve(state.user);\n          } else if (!state.isLoading && !state.isAuthenticated) {\n            clearTimeout(timeout);\n            unsubscribe();\n            reject(new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"Not authenticated\"));\n          }\n        });\n      });\n    }\n    let token = this.getToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${token}`\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          const refreshed = await this.refreshToken();\n          if (refreshed) {\n            token = this.getToken();\n            if (token) {\n              const retryResponse = await fetch(`${this.authUrl}/api/auth/me`, {\n                headers: {\n                  \"Authorization\": `Bearer ${token}`\n                }\n              });\n              if (retryResponse.ok) {\n                const retryData = await retryResponse.json();\n                const user2 = retryData.user;\n                this.updateAuthState({\n                  ...this.authState,\n                  user: user2\n                });\n                return user2;\n              }\n            }\n          }\n          this.clearTokens();\n          if (this.config.authRequired) {\n            this.redirectToAuth();\n          }\n        }\n        const errorData = await response.json().catch(() => ({}));\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || `Failed to fetch user: ${response.statusText}`);\n      }\n      const data = await response.json();\n      const user = data.user;\n      this.updateAuthState({\n        ...this.authState,\n        user\n      });\n      return user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign up with email and password (headless mode)\n   */\n  async signUp(data) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signUp is only available in headless mode\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signup`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          ...data,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Sign up failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign in with email and password (headless mode)\n   */\n  async signInWithEmail(email, password) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithEmail is only available in headless mode\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/email`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          password,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Sign in failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign in with Google (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * \n   * On React Native, requires `webBrowser` to be configured in client:\n   * ```typescript\n   * const blink = createClient({\n   *   auth: { mode: 'headless', webBrowser: WebBrowser }\n   * })\n   * await blink.auth.signInWithGoogle() // Works on both platforms!\n   * ```\n   */\n  async signInWithGoogle(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithGoogle is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"google\", options);\n  }\n  /**\n   * Sign in with GitHub (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * See signInWithGoogle() for setup instructions.\n   */\n  async signInWithGitHub(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithGitHub is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"github\", options);\n  }\n  /**\n   * Sign in with Apple (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * See signInWithGoogle() for setup instructions.\n   */\n  async signInWithApple(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithApple is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"apple\", options);\n  }\n  /**\n   * Sign in with Microsoft (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * See signInWithGoogle() for setup instructions.\n   */\n  async signInWithMicrosoft(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithMicrosoft is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"microsoft\", options);\n  }\n  /**\n   * Initiate OAuth for mobile without deep linking (expo-web-browser pattern)\n   * \n   * This method:\n   * 1. Generates a unique session ID\n   * 2. Returns OAuth URL with session parameter\n   * 3. App opens URL in expo-web-browser\n   * 4. App polls checkMobileOAuthSession() until complete\n   * \n   * @param provider - OAuth provider (google, github, apple, etc.)\n   * @param options - Optional metadata\n   * @returns Session ID and OAuth URL\n   * \n   * @example\n   * // React Native with expo-web-browser\n   * import * as WebBrowser from 'expo-web-browser';\n   * \n   * const { sessionId, authUrl } = await blink.auth.initiateMobileOAuth('google');\n   * \n   * // Open browser\n   * await WebBrowser.openAuthSessionAsync(authUrl);\n   * \n   * // Poll for completion\n   * const user = await blink.auth.pollMobileOAuthSession(sessionId);\n   * console.log('Authenticated:', user.email);\n   */\n  async initiateMobileOAuth(provider, options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\n        \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */,\n        \"initiateMobileOAuth is only available in headless mode\"\n      );\n    }\n    const sessionId = this.generateSessionId();\n    const authUrl = new URL(\"/auth\", this.authUrl);\n    authUrl.searchParams.set(\"provider\", provider);\n    authUrl.searchParams.set(\"project_id\", this.config.projectId);\n    authUrl.searchParams.set(\"mode\", \"mobile-session\");\n    authUrl.searchParams.set(\"session_id\", sessionId);\n    if (options?.metadata) {\n      authUrl.searchParams.set(\"metadata\", JSON.stringify(options.metadata));\n    }\n    return {\n      sessionId,\n      authUrl: authUrl.toString()\n    };\n  }\n  /**\n   * Check mobile OAuth session status (single check)\n   * \n   * @param sessionId - Session ID from initiateMobileOAuth\n   * @returns Tokens if session is complete, null if still pending\n   */\n  async checkMobileOAuthSession(sessionId) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/mobile-session/${sessionId}`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (response.status === 404 || response.status === 202) {\n        return null;\n      }\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to check OAuth session\"\n        );\n      }\n      const data = await response.json();\n      return {\n        access_token: data.access_token,\n        refresh_token: data.refresh_token,\n        token_type: data.token_type || \"Bearer\",\n        expires_in: data.expires_in || 3600,\n        refresh_expires_in: data.refresh_expires_in\n      };\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  /**\n   * Poll mobile OAuth session until complete (convenience method)\n   * \n   * @param sessionId - Session ID from initiateMobileOAuth\n   * @param options - Polling options\n   * @returns Authenticated user\n   * \n   * @example\n   * const { sessionId, authUrl } = await blink.auth.initiateMobileOAuth('google');\n   * await WebBrowser.openAuthSessionAsync(authUrl);\n   * const user = await blink.auth.pollMobileOAuthSession(sessionId, {\n   *   maxAttempts: 60,\n   *   intervalMs: 1000\n   * });\n   */\n  async pollMobileOAuthSession(sessionId, options) {\n    const maxAttempts = options?.maxAttempts || 60;\n    const intervalMs = options?.intervalMs || 1e3;\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      const tokens = await this.checkMobileOAuthSession(sessionId);\n      if (tokens) {\n        await this.setTokens(tokens, true);\n        return this.authState.user;\n      }\n      await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    }\n    throw new BlinkAuthError(\n      \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */,\n      \"Mobile OAuth session timed out\"\n    );\n  }\n  /**\n   * Sign in with OAuth provider using expo-web-browser (React Native)\n   * \n   * This is a convenience method that handles the entire flow:\n   * 1. Initiates mobile OAuth session\n   * 2. Returns auth URL to open in WebBrowser\n   * 3. Provides polling function to call after browser opens\n   * \n   * @param provider - OAuth provider\n   * @returns Object with authUrl and authenticate function\n   * \n   * @example\n   * import * as WebBrowser from 'expo-web-browser';\n   * \n   * const { authUrl, authenticate } = await blink.auth.signInWithProviderMobile('google');\n   * \n   * // Open browser\n   * await WebBrowser.openAuthSessionAsync(authUrl);\n   * \n   * // Wait for authentication\n   * const user = await authenticate();\n   */\n  async signInWithProviderMobile(provider, options) {\n    const { sessionId, authUrl } = await this.initiateMobileOAuth(provider, options);\n    return {\n      authUrl,\n      authenticate: () => this.pollMobileOAuthSession(sessionId, {\n        maxAttempts: 60,\n        intervalMs: 1e3\n      })\n    };\n  }\n  /**\n   * Universal OAuth flow using session-based authentication (internal)\n   * Works on ALL platforms: Web, iOS, Android\n   * Uses expo-web-browser to open auth URL and polls for completion\n   */\n  async signInWithProviderUniversal(provider, options) {\n    const webBrowser = this.authConfig.webBrowser;\n    if (!webBrowser) {\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"webBrowser module is required for universal OAuth flow\"\n      );\n    }\n    const { sessionId, authUrl } = await this.initiateMobileOAuth(provider, options);\n    console.log(\"\\u{1F510} Opening OAuth browser for\", provider);\n    const browserPromise = webBrowser.openAuthSessionAsync(authUrl);\n    const raceResult = await Promise.race([\n      browserPromise.then((result) => ({ closed: true, result })).catch((err) => ({ closed: true, error: err })),\n      new Promise(\n        (resolve) => setTimeout(() => resolve({ closed: false }), 5e3)\n      )\n    ]);\n    if (raceResult.closed) {\n      if (\"result\" in raceResult) {\n        console.log(\"\\u{1F510} Browser closed with result:\", raceResult.result.type);\n      } else {\n        console.log(\"\\u{1F510} Browser closed with error\");\n      }\n    } else {\n      console.log(\"\\u{1F510} Browser still open (new tab/stuck popup), starting to poll...\");\n    }\n    const user = await this.pollMobileOAuthSession(sessionId, {\n      maxAttempts: 120,\n      // 60 seconds (give user time to complete auth)\n      intervalMs: 500\n    });\n    console.log(\"\\u2705 OAuth completed successfully\");\n    return user;\n  }\n  /**\n   * Generic provider sign-in method (headless mode)\n   * \n   * **Universal OAuth** - Works seamlessly on both Web and React Native!\n   * \n   * When `webBrowser` is configured in the client, this method automatically\n   * uses the session-based OAuth flow that works on ALL platforms.\n   * \n   * **Universal Setup (configure once, works everywhere):**\n   * ```typescript\n   * import * as WebBrowser from 'expo-web-browser'\n   * import AsyncStorage from '@react-native-async-storage/async-storage'\n   * \n   * const blink = createClient({\n   *   projectId: 'your-project',\n   *   auth: {\n   *     mode: 'headless',\n   *     webBrowser: WebBrowser  // Pass the module here\n   *   },\n   *   storage: new AsyncStorageAdapter(AsyncStorage)\n   * })\n   * \n   * // Now this works on ALL platforms - no platform checks needed!\n   * const user = await blink.auth.signInWithGoogle()\n   * ```\n   * \n   * @param provider - OAuth provider (google, github, apple, etc.)\n   * @param options - Optional redirect URL and metadata\n   * @returns Promise that resolves with authenticated user\n   */\n  async signInWithProvider(provider, options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithProvider is only available in headless mode\");\n    }\n    if (this.authConfig.webBrowser) {\n      return this.signInWithProviderUniversal(provider, options);\n    }\n    if (isReactNative2()) {\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        'React Native OAuth requires webBrowser in config!\\n\\nimport * as WebBrowser from \"expo-web-browser\";\\n\\nconst blink = createClient({\\n  projectId: \"your-project\",\\n  auth: {\\n    mode: \"headless\",\\n    webBrowser: WebBrowser\\n  }\\n})\\n\\nawait blink.auth.signInWithGoogle() // Works on all platforms!'\n      );\n    }\n    if (!hasWindow()) {\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, \"signInWithProvider requires a browser environment\");\n    }\n    const shouldPreferRedirect = isWeb && this.isIframe || typeof window !== \"undefined\" && window.crossOriginIsolated === true;\n    const state = this.generateState();\n    try {\n      const sessionStorage = getSessionStorage();\n      if (sessionStorage) {\n        sessionStorage.setItem(\"blink_oauth_state\", state);\n      }\n    } catch {\n    }\n    const redirectUrl = options?.redirectUrl || getLocationOrigin() || \"\";\n    const buildAuthUrl = (mode) => {\n      const url = new URL(\"/auth\", this.authUrl);\n      url.searchParams.set(\"provider\", provider);\n      url.searchParams.set(\"project_id\", this.config.projectId);\n      url.searchParams.set(\"state\", state);\n      url.searchParams.set(\"mode\", mode);\n      url.searchParams.set(\"redirect_url\", redirectUrl);\n      url.searchParams.set(\"opener_origin\", getLocationOrigin() || \"\");\n      return url;\n    };\n    if (shouldPreferRedirect) {\n      window.location.href = buildAuthUrl(\"redirect\").toString();\n      return new Promise(() => {\n      });\n    }\n    return new Promise((resolve, reject) => {\n      const popupUrl = buildAuthUrl(\"popup\");\n      const popup = window.open(\n        popupUrl.toString(),\n        \"blink-auth\",\n        \"width=500,height=600,scrollbars=yes,resizable=yes\"\n      );\n      if (!popup) {\n        reject(new BlinkAuthError(\"POPUP_CANCELED\" /* POPUP_CANCELED */, \"Popup was blocked\"));\n        return;\n      }\n      let timeoutId;\n      let closedIntervalId;\n      let cleanedUp = false;\n      const cleanup = () => {\n        if (cleanedUp) return;\n        cleanedUp = true;\n        clearTimeout(timeoutId);\n        if (closedIntervalId) clearInterval(closedIntervalId);\n        window.removeEventListener(\"message\", messageListener);\n      };\n      const messageListener = (event) => {\n        let allowed = false;\n        try {\n          const authOrigin = new URL(this.authUrl).origin;\n          if (event.origin === authOrigin) allowed = true;\n        } catch {\n        }\n        if (event.origin === \"http://localhost:3000\" || event.origin === \"http://localhost:3001\") allowed = true;\n        if (!allowed) return;\n        if (event.data?.type === \"BLINK_AUTH_TOKENS\") {\n          const { access_token, refresh_token, token_type, expires_in, refresh_expires_in, projectId, state: returnedState } = event.data;\n          try {\n            const sessionStorage = getSessionStorage();\n            const expected = sessionStorage?.getItem(\"blink_oauth_state\");\n            if (returnedState && expected && returnedState !== expected) {\n              reject(new BlinkAuthError(\"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */, \"State mismatch\"));\n              clearTimeout(timeoutId);\n              window.removeEventListener(\"message\", messageListener);\n              popup.close();\n              return;\n            }\n          } catch {\n          }\n          if (projectId !== this.config.projectId) {\n            reject(new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"Project ID mismatch\"));\n            return;\n          }\n          this.setTokens({\n            access_token,\n            refresh_token,\n            token_type,\n            expires_in,\n            refresh_expires_in\n          }, true).then(() => {\n            resolve(this.authState.user);\n          }).catch(reject);\n          cleanup();\n          popup.close();\n        } else if (event.data?.type === \"BLINK_AUTH_ERROR\") {\n          const errorCode = this.mapErrorCodeFromResponse(event.data.code);\n          reject(new BlinkAuthError(errorCode, event.data.message || \"Authentication failed\"));\n          cleanup();\n          popup.close();\n        }\n      };\n      if (popup.opener === null) {\n        try {\n          popup.close();\n        } catch {\n        }\n        cleanup();\n        window.location.href = buildAuthUrl(\"redirect\").toString();\n        return;\n      }\n      timeoutId = setTimeout(() => {\n        cleanup();\n        if (!popup.closed) {\n          popup.close();\n        }\n        reject(new BlinkAuthError(\"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */, \"Authentication timed out\"));\n      }, 3e5);\n      closedIntervalId = setInterval(() => {\n        if (popup.closed) {\n          cleanup();\n          reject(new BlinkAuthError(\"POPUP_CANCELED\" /* POPUP_CANCELED */, \"Authentication was canceled\"));\n        }\n      }, 1e3);\n      window.addEventListener(\"message\", messageListener);\n    });\n  }\n  /**\n   * Generate password reset token (for custom email delivery)\n   */\n  async generatePasswordResetToken(email) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate password reset token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate password reset token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send password reset email (using Blink default email service)\n   */\n  async sendPasswordResetEmail(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          projectId: this.config.projectId,\n          redirectUrl: options?.redirectUrl\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send password reset email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Confirm password reset with token\n   */\n  async confirmPasswordReset(token, newPassword) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset/confirm`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token,\n          password: newPassword,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to reset password\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Change password (requires current authentication)\n   */\n  async changePassword(oldPassword, newPassword) {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/change`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          oldPassword,\n          newPassword\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to change password\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Generate email verification token (for custom email delivery)\n   */\n  async generateEmailVerificationToken() {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate email verification token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate email verification token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send email verification (using Blink default email service)\n   */\n  async sendEmailVerification() {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify/send`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send verification email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Verify email with token\n   */\n  async verifyEmail(token) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to verify email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Generate magic link token (for custom email delivery)\n   */\n  async generateMagicLinkToken(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          redirectUrl: options?.redirectUrl,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate magic link token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate magic link token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send magic link (using Blink default email service)\n   */\n  async sendMagicLink(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          redirectUrl: options?.redirectUrl,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send magic link\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Verify magic link (automatic on redirect)\n   */\n  async verifyMagicLink(token) {\n    const magicToken = token || this.extractMagicTokenFromUrl();\n    if (!magicToken) {\n      throw new BlinkAuthError(\"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */, \"No magic link token found\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic/verify`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token: magicToken,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Magic link verification failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Get available providers for the current project\n   */\n  async getAvailableProviders() {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/providers?projectId=${encodeURIComponent(this.config.projectId)}`);\n      if (!response.ok) {\n        return [\"email\", \"google\"];\n      }\n      const data = await response.json();\n      return data.providers || [\"email\", \"google\"];\n    } catch (error) {\n      return [\"email\", \"google\"];\n    }\n  }\n  /**\n   * Check if user has a specific role\n   */\n  hasRole(role) {\n    const user = this.authState.user;\n    if (!user || !user.role) {\n      return false;\n    }\n    if (Array.isArray(role)) {\n      return role.includes(user.role);\n    }\n    return user.role === role;\n  }\n  /**\n   * Check if user can perform a specific action\n   */\n  can(permission, resource) {\n    const user = this.authState.user;\n    if (!user || !user.role) {\n      return false;\n    }\n    const roles = this.authConfig.roles;\n    if (!roles) {\n      return false;\n    }\n    const roleConfig = roles[user.role];\n    if (!roleConfig) {\n      return false;\n    }\n    if (roleConfig.permissions.includes(\"*\")) {\n      return true;\n    }\n    const fullPermission = resource ? `${permission}.${resource}` : permission;\n    if (roleConfig.permissions.includes(fullPermission)) {\n      return true;\n    }\n    if (roleConfig.permissions.includes(permission)) {\n      return true;\n    }\n    const visited = /* @__PURE__ */ new Set();\n    const hasPermissionInRole = (roleName) => {\n      if (visited.has(roleName)) return false;\n      visited.add(roleName);\n      const rc = roles[roleName];\n      if (!rc) return false;\n      if (rc.permissions.includes(\"*\")) return true;\n      const fullPermission2 = resource ? `${permission}.${resource}` : permission;\n      if (rc.permissions.includes(fullPermission2) || rc.permissions.includes(permission)) return true;\n      if (rc.inherit) {\n        for (const parent of rc.inherit) {\n          if (hasPermissionInRole(parent)) return true;\n        }\n      }\n      return false;\n    };\n    if (hasPermissionInRole(user.role)) return true;\n    return false;\n  }\n  /**\n   * Sign out (clear local tokens)\n   * Note: With stateless tokens, this only clears local storage\n   */\n  async signOut() {\n    this.clearTokens();\n  }\n  /**\n   * @deprecated Use signOut() instead. Kept for backward compatibility.\n   */\n  async revokeAllSessions() {\n    return this.signOut();\n  }\n  /**\n   * Recover auth state (clear corrupted tokens and re-initialize)\n   */\n  async recoverAuthState() {\n    console.log(\"\\u{1F504} Recovering auth state...\");\n    this.clearTokens();\n    this.isInitialized = false;\n    this.initializationPromise = null;\n    if (typeof window !== \"undefined\") {\n      this.initializationPromise = this.initialize();\n      await this.initializationPromise;\n    }\n    console.log(\"\\u2705 Auth state recovery complete\");\n  }\n  /**\n   * Update user profile\n   */\n  async updateMe(updates) {\n    const token = this.getToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        method: \"PATCH\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(updates)\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || `Failed to update user: ${response.statusText}`);\n      }\n      const data = await response.json();\n      const user = data.user;\n      this.updateAuthState({\n        ...this.authState,\n        user\n      });\n      return user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Manually set tokens (for server-side usage)\n   */\n  async setToken(jwt, persist = false) {\n    const tokens = {\n      access_token: jwt,\n      token_type: \"Bearer\",\n      expires_in: 15 * 60\n      // Default 15 minutes\n    };\n    await this.setTokens(tokens, persist);\n  }\n  /**\n   * Manually set auth session from tokens (React Native deep link OAuth)\n   * \n   * Use this method to set the user session after receiving tokens from a deep link callback.\n   * This is the React Native equivalent of automatic URL token detection on web.\n   * \n   * @param tokens - Auth tokens received from deep link or OAuth callback\n   * @param persist - Whether to persist tokens to storage (default: true)\n   * \n   * @example\n   * // React Native: Handle deep link OAuth callback\n   * import * as Linking from 'expo-linking'\n   * \n   * Linking.addEventListener('url', async ({ url }) => {\n   *   const { queryParams } = Linking.parse(url)\n   *   \n   *   if (queryParams.access_token) {\n   *     await blink.auth.setSession({\n   *       access_token: queryParams.access_token,\n   *       refresh_token: queryParams.refresh_token,\n   *       expires_in: parseInt(queryParams.expires_in) || 3600,\n   *       refresh_expires_in: parseInt(queryParams.refresh_expires_in)\n   *     })\n   *     \n   *     console.log('User authenticated:', blink.auth.currentUser())\n   *   }\n   * })\n   */\n  async setSession(tokens, persist = true) {\n    const authTokens = {\n      access_token: tokens.access_token,\n      refresh_token: tokens.refresh_token,\n      token_type: \"Bearer\",\n      expires_in: tokens.expires_in || 3600,\n      // Default 1 hour\n      refresh_expires_in: tokens.refresh_expires_in,\n      issued_at: Math.floor(Date.now() / 1e3)\n    };\n    await this.setTokens(authTokens, persist);\n    const user = await this.me();\n    return user;\n  }\n  /**\n   * Verify a Blink Auth token using the introspection endpoint.\n   * \n   * **Server-side / Edge Function use only.**\n   * \n   * This is the recommended way to verify user tokens in Deno Edge Functions\n   * and other server-side contexts. It calls the Blink API introspection \n   * endpoint which validates the token without exposing the JWT secret.\n   * \n   * @param token - The raw JWT token (without \"Bearer \" prefix) or full Authorization header\n   * @returns Token introspection result with validity and claims\n   * \n   * @example\n   * // Deno Edge Function usage\n   * import { createClient } from \"npm:@blinkdotnew/sdk\";\n   * \n   * const blink = createClient({\n   *   projectId: Deno.env.get(\"BLINK_PROJECT_ID\")!,\n   *   secretKey: Deno.env.get(\"BLINK_SECRET_KEY\"),\n   * });\n   * \n   * async function handler(req: Request): Promise<Response> {\n   *   const authHeader = req.headers.get(\"Authorization\");\n   *   const result = await blink.auth.verifyToken(authHeader);\n   *   \n   *   if (!result.valid) {\n   *     return new Response(JSON.stringify({ error: result.error }), { status: 401 });\n   *   }\n   *   \n   *   // User is authenticated\n   *   console.log(\"User ID:\", result.userId);\n   *   console.log(\"Email:\", result.email);\n   *   console.log(\"Project:\", result.projectId);\n   *   \n   *   // Continue with your logic...\n   * }\n   */\n  async verifyToken(token) {\n    if (!token) {\n      return { valid: false, error: \"Token required\" };\n    }\n    let cleanToken = token.toLowerCase().startsWith(\"bearer \") ? token.slice(7) : token;\n    cleanToken = cleanToken.trim();\n    if (!cleanToken) {\n      return { valid: false, error: \"Token required\" };\n    }\n    try {\n      const response = await fetch(`${this.coreUrl}/api/auth/introspect`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${cleanToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      const contentType = response.headers.get(\"content-type\")?.toLowerCase();\n      if (!contentType || !contentType.includes(\"application/json\")) {\n        return {\n          valid: false,\n          error: `Server error: ${response.status} ${response.statusText}`\n        };\n      }\n      const result = await response.json();\n      if (!result || typeof result !== \"object\" || typeof result.valid !== \"boolean\") {\n        return {\n          valid: false,\n          error: result && (result.error || result.message) || `Request failed: ${response.status}`\n        };\n      }\n      return result;\n    } catch (error) {\n      console.error(\"[BlinkAuth] Token verification failed:\", error);\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : \"Token verification failed\"\n      };\n    }\n  }\n  /**\n   * Refresh access token using refresh token\n   */\n  async refreshToken() {\n    const refreshToken = this.authState.tokens?.refresh_token;\n    if (!refreshToken) {\n      return false;\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          refresh_token: refreshToken\n        })\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          this.clearTokens();\n          if (this.config.authRequired) {\n            this.redirectToAuth();\n          }\n        }\n        return false;\n      }\n      const data = await response.json();\n      await this.setTokens({\n        access_token: data.access_token,\n        refresh_token: data.refresh_token,\n        token_type: data.token_type,\n        expires_in: data.expires_in,\n        refresh_expires_in: data.refresh_expires_in\n      }, true);\n      return true;\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      return false;\n    }\n  }\n  /**\n   * Add auth state change listener\n   */\n  onAuthStateChanged(callback) {\n    this.listeners.add(callback);\n    queueMicrotask(() => {\n      try {\n        callback(this.authState);\n      } catch (error) {\n        console.error(\"Error in auth state change callback:\", error);\n      }\n    });\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n  /**\n   * Private helper methods\n   */\n  async validateStoredTokens(tokens) {\n    try {\n      console.log(\"\\u{1F50D} Validating stored tokens...\");\n      if (this.isAccessTokenExpired()) {\n        console.log(\"\\u23F0 Access token expired based on timestamp, attempting refresh...\");\n        if (!tokens.refresh_token) {\n          console.log(\"\\u274C No refresh token available\");\n          return false;\n        }\n        if (this.isRefreshTokenExpired()) {\n          console.log(\"\\u274C Refresh token also expired\");\n          return false;\n        }\n        const refreshed = await this.refreshToken();\n        if (refreshed) {\n          console.log(\"\\u2705 Token refreshed successfully during validation\");\n          return true;\n        } else {\n          console.log(\"\\u274C Token refresh failed during validation\");\n          return false;\n        }\n      }\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${tokens.access_token}`\n        }\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const user = data.user;\n        this.updateAuthState({\n          user,\n          tokens,\n          isAuthenticated: true,\n          isLoading: false\n        });\n        console.log(\"\\u2705 Stored tokens are valid, user authenticated\");\n        return true;\n      } else if (response.status === 401 && tokens.refresh_token) {\n        console.log(\"\\u{1F504} Access token expired (server validation), attempting refresh...\");\n        if (this.isRefreshTokenExpired()) {\n          console.log(\"\\u274C Refresh token expired\");\n          return false;\n        }\n        const refreshed = await this.refreshToken();\n        if (refreshed) {\n          console.log(\"\\u2705 Token refreshed successfully after server validation\");\n          return true;\n        } else {\n          console.log(\"\\u274C Token refresh failed after server validation\");\n          return false;\n        }\n      } else {\n        console.log(\"\\u274C Token validation failed:\", response.status, response.statusText);\n        return false;\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error validating tokens:\", error);\n      return false;\n    }\n  }\n  async setTokens(tokens, persist) {\n    const tokensWithTimestamp = {\n      ...tokens,\n      issued_at: tokens.issued_at || Math.floor(Date.now() / 1e3)\n    };\n    console.log(\"\\u{1F510} Setting tokens:\", {\n      persist,\n      hasAccessToken: !!tokensWithTimestamp.access_token,\n      hasRefreshToken: !!tokensWithTimestamp.refresh_token,\n      expiresIn: tokensWithTimestamp.expires_in,\n      issuedAt: tokensWithTimestamp.issued_at\n    });\n    if (persist) {\n      try {\n        const result = this.storage.setItem(\n          this.getStorageKey(\"tokens\"),\n          JSON.stringify(tokensWithTimestamp)\n        );\n        if (result instanceof Promise) {\n          await result;\n        }\n        console.log(\"\\u{1F4BE} Tokens persisted to storage\");\n      } catch (error) {\n        console.log(\"\\u{1F4A5} Error persisting tokens:\", error);\n      }\n    }\n    let user = null;\n    try {\n      console.log(\"\\u{1F464} Fetching user data...\");\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${tokensWithTimestamp.access_token}`\n        }\n      });\n      console.log(\"\\u{1F4E1} User fetch response:\", {\n        status: response.status,\n        statusText: response.statusText,\n        ok: response.ok\n      });\n      if (response.ok) {\n        const data = await response.json();\n        user = data.user;\n        console.log(\"\\u2705 User data fetched successfully:\", {\n          id: user?.id,\n          email: user?.email,\n          displayName: user?.displayName\n        });\n      } else {\n        console.log(\"\\u274C Failed to fetch user data:\", await response.text());\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error fetching user data:\", error);\n    }\n    this.updateAuthState({\n      user,\n      tokens: tokensWithTimestamp,\n      isAuthenticated: !!user,\n      isLoading: false\n    });\n    console.log(\"\\u{1F3AF} Auth state updated:\", {\n      hasUser: !!user,\n      isAuthenticated: !!user,\n      isLoading: false\n    });\n  }\n  clearTokens() {\n    try {\n      const result = this.storage.removeItem(this.getStorageKey(\"tokens\"));\n      if (result instanceof Promise) {\n        result.catch((error) => {\n          console.log(\"\\u{1F4A5} Error clearing tokens from storage:\", error);\n        });\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error clearing tokens:\", error);\n    }\n    this.updateAuthState({\n      user: null,\n      tokens: null,\n      isAuthenticated: false,\n      isLoading: false\n    });\n  }\n  async getStoredTokens() {\n    if (isWeb && this.isIframe && this.parentWindowTokens) {\n      return this.parentWindowTokens;\n    }\n    try {\n      const result = this.storage.getItem(this.getStorageKey(\"tokens\"));\n      const stored = result instanceof Promise ? await result : result;\n      console.log(\"\\u{1F50D} Checking storage for tokens:\", {\n        hasStoredData: !!stored,\n        storedLength: stored?.length || 0,\n        isIframe: isWeb && this.isIframe\n      });\n      if (stored) {\n        const tokens = JSON.parse(stored);\n        console.log(\"\\u{1F4E6} Parsed stored tokens:\", {\n          hasAccessToken: !!tokens.access_token,\n          hasRefreshToken: !!tokens.refresh_token,\n          tokenType: tokens.token_type,\n          expiresIn: tokens.expires_in\n        });\n        return tokens;\n      }\n      return null;\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error reading tokens from storage:\", error);\n      return null;\n    }\n  }\n  extractTokensFromUrl() {\n    const search = getLocationSearch();\n    if (!search) return null;\n    const params = new URLSearchParams(search);\n    const accessToken = params.get(\"access_token\");\n    const refreshToken = params.get(\"refresh_token\");\n    console.log(\"\\u{1F50D} Extracting tokens from URL:\", {\n      url: getLocationHref(),\n      accessToken: accessToken ? `${accessToken.substring(0, 20)}...` : null,\n      refreshToken: refreshToken ? `${refreshToken.substring(0, 20)}...` : null,\n      allParams: Object.fromEntries(params.entries())\n    });\n    if (accessToken) {\n      const tokens = {\n        access_token: accessToken,\n        refresh_token: refreshToken || void 0,\n        token_type: \"Bearer\",\n        expires_in: 15 * 60,\n        // 15 minutes default\n        refresh_expires_in: refreshToken ? 30 * 24 * 60 * 60 : void 0,\n        // 30 days default\n        issued_at: Math.floor(Date.now() / 1e3)\n        // Current timestamp\n      };\n      console.log(\"\\u2705 Tokens extracted successfully:\", {\n        hasAccessToken: !!tokens.access_token,\n        hasRefreshToken: !!tokens.refresh_token\n      });\n      return tokens;\n    }\n    console.log(\"\\u274C No access token found in URL\");\n    return null;\n  }\n  clearUrlTokens() {\n    const href = getLocationHref();\n    if (!href || !hasWindowLocation()) return;\n    const url = new URL(href);\n    url.searchParams.delete(\"access_token\");\n    url.searchParams.delete(\"refresh_token\");\n    url.searchParams.delete(\"token_type\");\n    url.searchParams.delete(\"project_id\");\n    url.searchParams.delete(\"expires_in\");\n    url.searchParams.delete(\"refresh_expires_in\");\n    url.searchParams.delete(\"state\");\n    url.searchParams.delete(\"code\");\n    url.searchParams.delete(\"error\");\n    url.searchParams.delete(\"error_description\");\n    window.history.replaceState({}, \"\", url.toString());\n    console.log(\"\\u{1F9F9} URL cleaned up, removed auth parameters\");\n  }\n  redirectToAuth() {\n    if (hasWindowLocation()) {\n      this.login();\n    }\n  }\n  setLoading(loading) {\n    this.updateAuthState({\n      ...this.authState,\n      isLoading: loading\n    });\n  }\n  updateAuthState(newState) {\n    this.authState = newState;\n    this.listeners.forEach((callback) => {\n      try {\n        callback(newState);\n      } catch (error) {\n        console.error(\"Error in auth state change callback:\", error);\n      }\n    });\n  }\n  /**\n   * Generate secure random state for OAuth flows\n   */\n  generateState() {\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n      const array = new Uint8Array(16);\n      crypto.getRandomValues(array);\n      return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n    } else {\n      return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n    }\n  }\n  /**\n   * Generate unique session ID for mobile OAuth\n   */\n  generateSessionId() {\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n      const array = new Uint8Array(32);\n      crypto.getRandomValues(array);\n      return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n    } else {\n      return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n    }\n  }\n  /**\n   * Extract magic link token from URL\n   */\n  extractMagicTokenFromUrl() {\n    const search = getLocationSearch();\n    if (!search) return null;\n    const params = new URLSearchParams(search);\n    return params.get(\"magic_token\") || params.get(\"token\");\n  }\n  /**\n   * Map server error codes to BlinkAuthErrorCode\n   */\n  mapErrorCodeFromResponse(serverCode) {\n    switch (serverCode) {\n      case \"INVALID_CREDENTIALS\":\n      case \"auth/invalid-credential\":\n      case \"auth/wrong-password\":\n      case \"auth/user-not-found\":\n        return \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */;\n      case \"EMAIL_NOT_VERIFIED\":\n      case \"auth/email-not-verified\":\n        return \"EMAIL_NOT_VERIFIED\" /* EMAIL_NOT_VERIFIED */;\n      case \"EMAIL_ALREADY_VERIFIED\":\n        return \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */;\n      case \"POPUP_CANCELED\":\n      case \"auth/popup-closed-by-user\":\n        return \"POPUP_CANCELED\" /* POPUP_CANCELED */;\n      case \"NETWORK_ERROR\":\n        return \"NETWORK_ERROR\" /* NETWORK_ERROR */;\n      case \"RATE_LIMITED\":\n      case \"auth/too-many-requests\":\n        return \"RATE_LIMITED\" /* RATE_LIMITED */;\n      case \"AUTH_TIMEOUT\":\n        return \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */;\n      case \"REDIRECT_FAILED\":\n        return \"REDIRECT_FAILED\" /* REDIRECT_FAILED */;\n      case \"TOKEN_EXPIRED\":\n      case \"auth/id-token-expired\":\n        return \"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */;\n      case \"USER_NOT_FOUND\":\n        return \"USER_NOT_FOUND\" /* USER_NOT_FOUND */;\n      case \"EMAIL_ALREADY_EXISTS\":\n      case \"auth/email-already-in-use\":\n        return \"EMAIL_ALREADY_EXISTS\" /* EMAIL_ALREADY_EXISTS */;\n      case \"WEAK_PASSWORD\":\n      case \"auth/weak-password\":\n        return \"WEAK_PASSWORD\" /* WEAK_PASSWORD */;\n      case \"INVALID_EMAIL\":\n      case \"auth/invalid-email\":\n        return \"INVALID_EMAIL\" /* INVALID_EMAIL */;\n      case \"MAGIC_LINK_EXPIRED\":\n        return \"MAGIC_LINK_EXPIRED\" /* MAGIC_LINK_EXPIRED */;\n      case \"VERIFICATION_FAILED\":\n        return \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */;\n      default:\n        return \"NETWORK_ERROR\" /* NETWORK_ERROR */;\n    }\n  }\n  /**\n   * Setup cross-tab authentication synchronization\n   */\n  setupCrossTabSync() {\n    if (!isWeb || !hasWindow()) return;\n    window.addEventListener(\"storage\", (e) => {\n      if (e.key === this.getStorageKey(\"tokens\")) {\n        const newTokens = e.newValue ? JSON.parse(e.newValue) : null;\n        if (newTokens && newTokens !== this.authState.tokens) {\n          this.setTokens(newTokens, false).catch((error) => {\n            console.error(\"Failed to sync tokens from other tab:\", error);\n          });\n        } else if (!newTokens && this.authState.tokens) {\n          this.clearTokens();\n        }\n      }\n    });\n  }\n};\n\n// src/database.ts\nfunction assertServerOnly(methodName) {\n  if (typeof window !== \"undefined\") {\n    throw new Error(`${methodName} is server-only. Use Blink CRUD methods (blink.db.<table>.*) instead.`);\n  }\n}\nfunction camelToSnake3(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction generateSecureId() {\n  if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n    const array = new Uint8Array(16);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n  } else {\n    const timestamp = Date.now().toString(36);\n    const randomPart = Math.random().toString(36).substring(2, 15);\n    const extraRandom = Math.random().toString(36).substring(2, 15);\n    return `${timestamp}_${randomPart}_${extraRandom}`;\n  }\n}\nfunction ensureRecordId(record) {\n  if (!record.id) {\n    return { ...record, id: generateSecureId() };\n  }\n  return record;\n}\nvar BlinkTable = class {\n  constructor(tableName, httpClient) {\n    this.tableName = tableName;\n    this.httpClient = httpClient;\n    this.actualTableName = camelToSnake3(tableName);\n  }\n  actualTableName;\n  /**\n   * Create a single record\n   */\n  async create(data, options = {}) {\n    const record = ensureRecordId(data);\n    const response = await this.httpClient.dbPost(\n      this.actualTableName,\n      record,\n      { returning: options.returning !== false }\n    );\n    const result = Array.isArray(response.data) ? response.data[0] : response.data;\n    if (!result) {\n      throw new Error(\"Failed to create record\");\n    }\n    return result;\n  }\n  /**\n   * Create multiple records\n   */\n  async createMany(data, options = {}) {\n    const records = data.map(ensureRecordId);\n    const response = await this.httpClient.dbPost(\n      this.actualTableName,\n      records,\n      { returning: options.returning !== false }\n    );\n    const results = Array.isArray(response.data) ? response.data : [response.data];\n    return results;\n  }\n  /**\n   * Upsert a single record (insert or update on conflict)\n   */\n  async upsert(data, options = {}) {\n    const headers = {};\n    if (options.returning !== false) {\n      headers.Prefer = \"return=representation\";\n    }\n    if (options.onConflict) {\n      headers[\"Prefer\"] = `${headers[\"Prefer\"] || \"\"} resolution=merge-duplicates`.trim();\n    }\n    const record = ensureRecordId(data);\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || \"id\"}`,\n      {\n        method: \"POST\",\n        body: record,\n        headers\n      }\n    );\n    const result = Array.isArray(response.data) ? response.data[0] : response.data;\n    if (!result) {\n      throw new Error(\"Failed to upsert record\");\n    }\n    return result;\n  }\n  /**\n   * Upsert multiple records\n   */\n  async upsertMany(data, options = {}) {\n    const records = data.map(ensureRecordId);\n    const headers = {};\n    if (options.returning !== false) {\n      headers.Prefer = \"return=representation\";\n    }\n    if (options.onConflict) {\n      headers[\"Prefer\"] = `${headers[\"Prefer\"] || \"\"} resolution=merge-duplicates`.trim();\n    }\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || \"id\"}`,\n      {\n        method: \"POST\",\n        body: records,\n        headers\n      }\n    );\n    const results = Array.isArray(response.data) ? response.data : [response.data];\n    return results;\n  }\n  /**\n   * Get a single record by ID\n   */\n  async get(id) {\n    const searchParams = {\n      id: `eq.${id}`,\n      limit: \"1\"\n    };\n    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);\n    const records = response.data;\n    if (records.length === 0) {\n      return null;\n    }\n    return records[0] || null;\n  }\n  /**\n   * List records with filtering, sorting, and pagination\n   */\n  async list(options = {}) {\n    const queryParams = buildQuery(options);\n    const searchParams = queryParams;\n    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);\n    const records = response.data;\n    return records;\n  }\n  /**\n   * Update a single record by ID\n   */\n  async update(id, data, options = {}) {\n    const searchParams = {\n      id: `eq.${id}`\n    };\n    const response = await this.httpClient.dbPatch(\n      this.actualTableName,\n      data,\n      searchParams,\n      { returning: options.returning !== false }\n    );\n    const records = response.data;\n    if (!records || records.length === 0) {\n      throw new Error(`Record with id ${id} not found`);\n    }\n    return records[0];\n  }\n  /**\n   * Update multiple records\n   */\n  async updateMany(updates, options = {}) {\n    const results = [];\n    for (const update of updates) {\n      const { id, ...data } = update;\n      const result = await this.update(id, data, options);\n      results.push(result);\n    }\n    return results;\n  }\n  /**\n   * Delete a single record by ID\n   */\n  async delete(id) {\n    const searchParams = {\n      id: `eq.${id}`\n    };\n    await this.httpClient.dbDelete(this.actualTableName, searchParams);\n  }\n  /**\n   * Delete multiple records based on filter\n   */\n  async deleteMany(options) {\n    const queryParams = buildQuery({ where: options.where });\n    const searchParams = queryParams;\n    await this.httpClient.dbDelete(this.actualTableName, searchParams);\n  }\n  /**\n   * Count records matching filter\n   */\n  async count(options = {}) {\n    const queryParams = buildQuery({\n      where: options.where,\n      select: [\"id\"]\n    });\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}`,\n      {\n        method: \"GET\",\n        searchParams: queryParams,\n        headers: {\n          \"Prefer\": \"count=exact\"\n        }\n      }\n    );\n    const contentRange = response.headers.get(\"content-range\");\n    if (contentRange) {\n      const match = contentRange.match(/\\/(\\d+)$/);\n      if (match && match[1]) {\n        return parseInt(match[1], 10);\n      }\n    }\n    const records = response.data;\n    return records.length;\n  }\n  /**\n   * Check if any records exist matching filter\n   */\n  async exists(options) {\n    const count = await this.count(options);\n    return count > 0;\n  }\n  /**\n   * Raw SQL query on this table (for advanced use cases)\n   */\n  async sql(query, params) {\n    assertServerOnly(\"blink.db.<table>.sql\");\n    const response = await this.httpClient.dbSql(query, params);\n    return response.data;\n  }\n  /**\n   * Private helper methods\n   */\n  extractCursor(record) {\n    return record.id || record._id || String(Math.random());\n  }\n};\nvar BlinkDatabase = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    const proxy = new Proxy(this, {\n      get(target, prop) {\n        if (prop === \"table\") {\n          return target.table.bind(target);\n        }\n        if (prop in target) {\n          const value = target[prop];\n          return typeof value === \"function\" ? value.bind(target) : value;\n        }\n        if (typeof prop === \"string\") {\n          return target.table(prop);\n        }\n        return void 0;\n      }\n    });\n    return proxy;\n  }\n  tables = /* @__PURE__ */ new Map();\n  /**\n   * Get a table instance for any table name\n   */\n  table(tableName) {\n    if (!this.tables.has(tableName)) {\n      this.tables.set(tableName, new BlinkTable(tableName, this.httpClient));\n    }\n    const table = this.tables.get(tableName);\n    if (!table) {\n      throw new Error(`Table ${tableName} not found`);\n    }\n    return table;\n  }\n  /**\n   * Execute raw SQL query\n   */\n  async sql(query, params) {\n    assertServerOnly(\"blink.db.sql\");\n    const response = await this.httpClient.dbSql(query, params);\n    return response.data;\n  }\n  /**\n   * Execute batch SQL operations\n   */\n  async batch(statements, mode = \"write\") {\n    assertServerOnly(\"blink.db.batch\");\n    const response = await this.httpClient.dbBatch(statements, mode);\n    return response.data;\n  }\n};\n\n// src/storage.ts\nvar BlinkStorageImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  /**\n   * Upload a file to project storage\n   * \n   * @param file - File, Blob, or Buffer to upload\n   * @param path - Destination path within project storage (extension will be auto-corrected to match file type)\n   * @param options - Upload options including upsert and progress callback\n   * @returns Promise resolving to upload response with public URL\n   * \n   * @example\n   * ```ts\n   * // Extension automatically corrected to match actual file type\n   * const { publicUrl } = await blink.storage.upload(\n   *   pngFile,\n   *   `avatars/${user.id}`, // No extension needed!\n   *   { upsert: true }\n   * );\n   * // If file is PNG, final path will be: avatars/user123.png\n   * \n   * // Or with extension (will be corrected if wrong)\n   * const { publicUrl } = await blink.storage.upload(\n   *   pngFile,\n   *   `avatars/${user.id}.jpg`, // Wrong extension\n   *   { upsert: true }\n   * );\n   * // Final path will be: avatars/user123.png (auto-corrected!)\n   * ```\n   */\n  async upload(file, path, options = {}) {\n    try {\n      if (!file) {\n        throw new BlinkStorageError(\"File is required\");\n      }\n      if (!path || typeof path !== \"string\" || !path.trim()) {\n        throw new BlinkStorageError(\"Path must be a non-empty string\");\n      }\n      const maxSize = 50 * 1024 * 1024;\n      let fileSize = 0;\n      if (file instanceof File || file instanceof Blob) {\n        fileSize = file.size;\n      } else if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n        fileSize = file.length;\n      }\n      if (fileSize > maxSize) {\n        throw new BlinkStorageError(`File size (${Math.round(fileSize / 1024 / 1024)}MB) exceeds maximum allowed size (50MB)`);\n      }\n      const { correctedPath, detectedContentType } = await this.detectFileTypeAndCorrectPath(file, path);\n      const response = await this.httpClient.uploadFile(\n        `/api/storage/${this.httpClient.projectId}/upload`,\n        file,\n        correctedPath,\n        // Use corrected path with proper extension\n        {\n          onProgress: options.onProgress,\n          contentType: detectedContentType\n          // Pass detected content type\n        }\n      );\n      if (response.data?.data?.publicUrl) {\n        return { publicUrl: response.data.data.publicUrl };\n      } else if (response.data?.publicUrl) {\n        return { publicUrl: response.data.publicUrl };\n      } else {\n        throw new BlinkStorageError(\"Invalid response format: missing publicUrl\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 409) {\n          throw new BlinkStorageError(\"File already exists.\", 409);\n        }\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Upload failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Detect file type from actual file content and correct path extension\n   * This ensures the path extension always matches the actual file type\n   */\n  async detectFileTypeAndCorrectPath(file, originalPath) {\n    try {\n      const fileSignature = await this.getFileSignature(file);\n      const detectedType = this.detectFileTypeFromSignature(fileSignature);\n      let detectedContentType = detectedType.mimeType;\n      let detectedExtension = detectedType.extension;\n      if (!detectedContentType && file instanceof File && file.type) {\n        detectedContentType = file.type;\n        detectedExtension = this.getExtensionFromMimeType(file.type);\n      }\n      if (!detectedContentType) {\n        detectedContentType = \"application/octet-stream\";\n        detectedExtension = \"bin\";\n      }\n      const pathParts = originalPath.split(\"/\");\n      const fileName = pathParts[pathParts.length - 1];\n      const directory = pathParts.slice(0, -1).join(\"/\");\n      if (!fileName) {\n        throw new Error(\"Invalid path: filename cannot be empty\");\n      }\n      const nameWithoutExt = fileName.includes(\".\") ? fileName.substring(0, fileName.lastIndexOf(\".\")) : fileName;\n      const correctedFileName = `${nameWithoutExt}.${detectedExtension}`;\n      const correctedPath = directory ? `${directory}/${correctedFileName}` : correctedFileName;\n      return {\n        correctedPath,\n        detectedContentType\n      };\n    } catch (error) {\n      return {\n        correctedPath: originalPath,\n        detectedContentType: \"application/octet-stream\"\n      };\n    }\n  }\n  /**\n   * Get the first few bytes of a file to analyze its signature\n   */\n  async getFileSignature(file) {\n    const bytesToRead = 12;\n    if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n      return new Uint8Array(file.slice(0, bytesToRead));\n    }\n    if (file instanceof File || file instanceof Blob) {\n      const slice = file.slice(0, bytesToRead);\n      const arrayBuffer = await slice.arrayBuffer();\n      return new Uint8Array(arrayBuffer);\n    }\n    throw new Error(\"Unsupported file type for signature detection\");\n  }\n  /**\n   * Detect file type from file signature (magic numbers)\n   * This is the most reliable way to detect actual file type\n   */\n  detectFileTypeFromSignature(signature) {\n    const hex = Array.from(signature).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    const signatures = {\n      // Images\n      \"ffd8ff\": { mimeType: \"image/jpeg\", extension: \"jpg\" },\n      \"89504e47\": { mimeType: \"image/png\", extension: \"png\" },\n      \"47494638\": { mimeType: \"image/gif\", extension: \"gif\" },\n      \"52494646\": { mimeType: \"image/webp\", extension: \"webp\" },\n      // RIFF (WebP container)\n      \"424d\": { mimeType: \"image/bmp\", extension: \"bmp\" },\n      \"49492a00\": { mimeType: \"image/tiff\", extension: \"tiff\" },\n      \"4d4d002a\": { mimeType: \"image/tiff\", extension: \"tiff\" },\n      // Documents\n      \"25504446\": { mimeType: \"application/pdf\", extension: \"pdf\" },\n      \"504b0304\": { mimeType: \"application/zip\", extension: \"zip\" },\n      // Also used by docx, xlsx\n      \"d0cf11e0\": { mimeType: \"application/msword\", extension: \"doc\" },\n      // Audio\n      \"494433\": { mimeType: \"audio/mpeg\", extension: \"mp3\" },\n      \"664c6143\": { mimeType: \"audio/flac\", extension: \"flac\" },\n      \"4f676753\": { mimeType: \"audio/ogg\", extension: \"ogg\" },\n      // Video\n      \"000000\": { mimeType: \"video/mp4\", extension: \"mp4\" },\n      // ftyp box\n      \"1a45dfa3\": { mimeType: \"video/webm\", extension: \"webm\" },\n      // Text\n      \"efbbbf\": { mimeType: \"text/plain\", extension: \"txt\" }\n      // UTF-8 BOM\n    };\n    for (const [sig, type] of Object.entries(signatures)) {\n      if (hex.startsWith(sig)) {\n        return type;\n      }\n    }\n    if (hex.startsWith(\"52494646\") && hex.substring(16, 24) === \"57454250\") {\n      return { mimeType: \"image/webp\", extension: \"webp\" };\n    }\n    if (hex.substring(8, 16) === \"66747970\") {\n      return { mimeType: \"video/mp4\", extension: \"mp4\" };\n    }\n    return { mimeType: \"\", extension: \"\" };\n  }\n  /**\n   * Get file extension from MIME type as fallback\n   */\n  getExtensionFromMimeType(mimeType) {\n    const mimeToExt = {\n      \"image/jpeg\": \"jpg\",\n      \"image/png\": \"png\",\n      \"image/gif\": \"gif\",\n      \"image/webp\": \"webp\",\n      \"image/bmp\": \"bmp\",\n      \"image/svg+xml\": \"svg\",\n      \"application/pdf\": \"pdf\",\n      \"text/plain\": \"txt\",\n      \"text/html\": \"html\",\n      \"text/css\": \"css\",\n      \"application/javascript\": \"js\",\n      \"application/json\": \"json\",\n      \"audio/mpeg\": \"mp3\",\n      \"audio/wav\": \"wav\",\n      \"audio/ogg\": \"ogg\",\n      \"video/mp4\": \"mp4\",\n      \"video/webm\": \"webm\",\n      \"application/zip\": \"zip\"\n    };\n    return mimeToExt[mimeType] || \"bin\";\n  }\n  /**\n   * Get a download URL for a file that triggers browser download\n   * \n   * @param path - Path to the file in project storage\n   * @param options - Download options including custom filename\n   * @returns Promise resolving to download response with download URL\n   * \n   * @example\n   * ```ts\n   * // Download with original filename\n   * const { downloadUrl, filename } = await blink.storage.download('images/photo.jpg');\n   * window.open(downloadUrl, '_blank');\n   * \n   * // Download with custom filename\n   * const { downloadUrl } = await blink.storage.download(\n   *   'images/photo.jpg',\n   *   { filename: 'my-photo.jpg' }\n   * );\n   * \n   * // Create download link in React\n   * <a href={downloadUrl} download={filename}>Download Image</a>\n   * ```\n   */\n  async download(path, options = {}) {\n    try {\n      if (!path || typeof path !== \"string\" || !path.trim()) {\n        throw new BlinkStorageError(\"Path must be a non-empty string\");\n      }\n      const response = await this.httpClient.request(\n        `/api/storage/${this.httpClient.projectId}/download`,\n        {\n          method: \"GET\",\n          searchParams: {\n            path: path.trim(),\n            ...options.filename && { filename: options.filename }\n          }\n        }\n      );\n      if (response.data?.downloadUrl) {\n        return {\n          downloadUrl: response.data.downloadUrl,\n          filename: response.data.filename || options.filename || path.split(\"/\").pop() || \"download\",\n          contentType: response.data.contentType,\n          size: response.data.size\n        };\n      } else {\n        throw new BlinkStorageError(\"Invalid response format: missing downloadUrl\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 404) {\n          throw new BlinkStorageError(\"File not found\", 404);\n        }\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Download failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Remove one or more files from project storage\n   * \n   * @param paths - File paths to remove\n   * @returns Promise that resolves when files are removed\n   * \n   * @example\n   * ```ts\n   * await blink.storage.remove('avatars/user1.png');\n   * await blink.storage.remove('file1.pdf', 'file2.pdf', 'file3.pdf');\n   * ```\n   */\n  async remove(...paths) {\n    try {\n      if (paths.length === 0) {\n        throw new BlinkStorageError(\"At least one path must be provided\");\n      }\n      for (const path of paths) {\n        if (!path || typeof path !== \"string\") {\n          throw new BlinkStorageError(\"All paths must be non-empty strings\");\n        }\n      }\n      await this.httpClient.request(\n        `/api/storage/${this.httpClient.projectId}/remove`,\n        {\n          method: \"DELETE\",\n          body: { paths },\n          headers: { \"Content-Type\": \"application/json\" }\n        }\n      );\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Failed to remove files: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n};\n\n// src/tools/core.ts\nvar webSearch = \"web_search\";\nvar fetchUrl = \"fetch_url\";\nvar runCode = \"run_code\";\nvar coreTools = [webSearch, fetchUrl, runCode];\n\n// src/tools/sandbox.ts\nvar readFile = \"read_file\";\nvar listDir = \"list_dir\";\nvar writeFile = \"write_file\";\nvar searchReplace = \"search_replace\";\nvar grep = \"grep\";\nvar globFileSearch = \"glob_file_search\";\nvar runTerminalCmd = \"run_terminal_cmd\";\nvar getHost = \"get_host\";\nvar sandboxTools = [\n  readFile,\n  listDir,\n  writeFile,\n  searchReplace,\n  grep,\n  globFileSearch,\n  runTerminalCmd,\n  getHost\n];\n\n// src/tools/db.ts\nvar dbInsert = \"db_insert\";\nvar dbList = \"db_list\";\nvar dbGet = \"db_get\";\nvar dbUpdate = \"db_update\";\nvar dbDelete = \"db_delete\";\nvar dbTools = [dbInsert, dbList, dbGet, dbUpdate, dbDelete];\n\n// src/tools/storage.ts\nvar storageUpload = \"storage_upload\";\nvar storageDownload = \"storage_download\";\nvar storageList = \"storage_list\";\nvar storageDelete = \"storage_delete\";\nvar storagePublicUrl = \"storage_public_url\";\nvar storageMove = \"storage_move\";\nvar storageCopy = \"storage_copy\";\nvar storageTools = [\n  storageUpload,\n  storageDownload,\n  storageList,\n  storageDelete,\n  storagePublicUrl,\n  storageMove,\n  storageCopy\n];\n\n// src/tools/rag.ts\nvar ragSearch = \"rag_search\";\nvar ragTools = [ragSearch];\n\n// src/tools/media.ts\nvar generateImage = \"generate_image\";\nvar editImage = \"edit_image\";\nvar generateVideo = \"generate_video\";\nvar imageToVideo = \"image_to_video\";\nvar mediaTools = [generateImage, editImage, generateVideo, imageToVideo];\n\n// src/tools/index.ts\nfunction serializeTools(tools) {\n  return tools;\n}\n\n// src/agent.ts\nfunction createStopConditions(maxSteps, stopWhen) {\n  if (stopWhen && stopWhen.length > 0) {\n    return stopWhen;\n  }\n  if (maxSteps && maxSteps > 0) {\n    return [{ type: \"step_count_is\", count: maxSteps }];\n  }\n  return void 0;\n}\nvar Agent = class {\n  httpClient = null;\n  config;\n  /**\n   * Create a new Agent instance.\n   * Auto-binds to default client if createClient() was called.\n   * \n   * @param options - Agent configuration options\n   */\n  constructor(options) {\n    if (!options.model) {\n      throw new BlinkAIError(\"Agent model is required\");\n    }\n    this.config = options;\n    try {\n      this.httpClient = _getDefaultHttpClient();\n    } catch {\n    }\n  }\n  /**\n   * Internal: Set the HTTP client (called by BlinkClient)\n   */\n  _setHttpClient(client) {\n    this.httpClient = client;\n  }\n  /**\n   * Internal: Get the agent config for API requests\n   */\n  getAgentConfig() {\n    const { model, system, instructions, tools, webhookTools, clientTools, toolChoice, stopWhen, maxSteps } = this.config;\n    const serializedTools = tools ? serializeTools(tools) : void 0;\n    const stopConditions = createStopConditions(maxSteps, stopWhen);\n    return {\n      model,\n      system: system || instructions,\n      tools: serializedTools,\n      webhook_tools: webhookTools,\n      client_tools: clientTools,\n      tool_choice: toolChoice,\n      stop_when: stopConditions\n    };\n  }\n  /**\n   * Generate a response (non-streaming)\n   * \n   * @param options - Generation options (prompt or messages)\n   * @returns Promise<AgentResponse> with text, steps, usage, and billing\n   * \n   * @example\n   * ```ts\n   * const result = await agent.generate({\n   *   prompt: 'What is the weather in San Francisco?',\n   * })\n   * console.log(result.text)\n   * console.log(result.steps)\n   * ```\n   */\n  async generate(options) {\n    if (!this.httpClient) {\n      throw new BlinkAIError(\n        \"Agent not initialized. Call createClient() first, or use useAgent() in React.\"\n      );\n    }\n    if (!options.prompt && !options.messages) {\n      throw new BlinkAIError(\"Either prompt or messages is required\");\n    }\n    if (options.prompt && options.messages) {\n      throw new BlinkAIError(\"prompt and messages are mutually exclusive\");\n    }\n    try {\n      const requestBody = {\n        stream: false,\n        agent: this.getAgentConfig()\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      } else if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      if (options.sandbox) {\n        requestBody.sandbox_id = typeof options.sandbox === \"string\" ? options.sandbox : options.sandbox.id;\n      }\n      const response = await this.httpClient.aiAgent(requestBody, options.signal);\n      return response.data;\n    } catch (error) {\n      console.error(\"[Agent] generate failed:\", error);\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Agent generate failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Stream a response (real-time)\n   * \n   * @param options - Stream options (prompt or messages)\n   * @returns Promise<Response> - AI SDK UI Message Stream for useChat compatibility\n   * \n   * @example\n   * ```ts\n   * const stream = await agent.stream({\n   *   prompt: 'Tell me a story',\n   * })\n   * \n   * // Process stream\n   * for await (const chunk of stream.body) {\n   *   // Handle chunk\n   * }\n   * ```\n   */\n  async stream(options) {\n    if (!this.httpClient) {\n      throw new BlinkAIError(\n        \"Agent not initialized. Call createClient() first, or use useAgent() in React.\"\n      );\n    }\n    if (!options.prompt && !options.messages) {\n      throw new BlinkAIError(\"Either prompt or messages is required\");\n    }\n    if (options.prompt && options.messages) {\n      throw new BlinkAIError(\"prompt and messages are mutually exclusive\");\n    }\n    try {\n      const requestBody = {\n        stream: true,\n        agent: this.getAgentConfig()\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      } else if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      if (options.sandbox) {\n        requestBody.sandbox_id = typeof options.sandbox === \"string\" ? options.sandbox : options.sandbox.id;\n      }\n      return await this.httpClient.aiAgentStream(requestBody, options.signal);\n    } catch (error) {\n      console.error(\"[Agent] stream failed:\", error);\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Agent stream failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Get the agent's model\n   */\n  get model() {\n    return this.config.model;\n  }\n  /**\n   * Get the agent's system prompt\n   */\n  get system() {\n    return this.config.system || this.config.instructions;\n  }\n  /**\n   * Get the agent's tools\n   */\n  get tools() {\n    return this.config.tools;\n  }\n};\nfunction stepCountIs(count) {\n  return { type: \"step_count_is\", count };\n}\n\n// src/ai.ts\nvar BlinkAIImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  // Supported image formats for validation\n  SUPPORTED_IMAGE_FORMATS = [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\"];\n  /**\n   * Validates if a URL is a valid HTTPS image URL\n   */\n  validateImageUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      if (parsedUrl.protocol !== \"https:\") {\n        return { isValid: false, error: \"Image URLs must use HTTPS protocol\" };\n      }\n      const pathname = parsedUrl.pathname.toLowerCase();\n      const hasValidExtension = this.SUPPORTED_IMAGE_FORMATS.some(\n        (format) => pathname.endsWith(`.${format}`)\n      );\n      if (!hasValidExtension) {\n        return {\n          isValid: false,\n          error: `Image URL must end with a supported format: ${this.SUPPORTED_IMAGE_FORMATS.join(\", \")}`\n        };\n      }\n      return { isValid: true };\n    } catch (error) {\n      return { isValid: false, error: \"Invalid URL format\" };\n    }\n  }\n  /**\n   * Validates messages for image content\n   */\n  validateMessages(messages) {\n    const errors = [];\n    messages.forEach((message, messageIndex) => {\n      if (Array.isArray(message.content)) {\n        message.content.forEach((item, contentIndex) => {\n          if (item.type === \"image\") {\n            if (!item.image || typeof item.image !== \"string\") {\n              errors.push(`Message ${messageIndex}, content ${contentIndex}: Image content must have a valid image URL`);\n            } else {\n              const validation = this.validateImageUrl(item.image);\n              if (!validation.isValid) {\n                errors.push(`Message ${messageIndex}, content ${contentIndex}: ${validation.error}`);\n              }\n            }\n          }\n        });\n      }\n    });\n    return { isValid: errors.length === 0, errors };\n  }\n  /**\n   * Get MIME type for audio format\n   */\n  getMimeTypeForFormat(format) {\n    const mimeTypes = {\n      mp3: \"audio/mpeg\",\n      opus: \"audio/opus\",\n      aac: \"audio/aac\",\n      flac: \"audio/flac\",\n      wav: \"audio/wav\",\n      pcm: \"audio/pcm\"\n    };\n    return mimeTypes[format] || \"audio/mpeg\";\n  }\n  /**\n   * Generates a text response using the Blink AI engine.\n   * \n   * @param options - An object containing either:\n   *   - `prompt`: a simple string prompt\n   *   - OR `messages`: an array of chat messages for conversation\n   *   - Plus optional model, search, maxSteps, experimental_continueSteps, maxTokens, temperature, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Simple prompt\n   * const { text } = await blink.ai.generateText({ \n   *   prompt: \"Write a poem about coding\" \n   * });\n   * \n   * // Chat messages (text only)\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { role: \"system\", content: \"You are a helpful assistant\" },\n   *     { role: \"user\", content: \"Explain quantum computing\" }\n   *   ]\n   * });\n   * \n   * // With image content\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { \n   *       role: \"user\", \n   *       content: [\n   *         { type: \"text\", text: \"What do you see in this image?\" },\n   *         { type: \"image\", image: \"https://example.com/photo.jpg\" }\n   *       ]\n   *     }\n   *   ]\n   * });\n   * \n   * // Mixed content with multiple images\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { \n   *       role: \"user\", \n   *       content: [\n   *         { type: \"text\", text: \"Compare these two images:\" },\n   *         { type: \"image\", image: \"https://example.com/image1.jpg\" },\n   *         { type: \"image\", image: \"https://example.com/image2.jpg\" }\n   *       ]\n   *     }\n   *   ]\n   * });\n   * \n   * // With options\n   * const { text, usage } = await blink.ai.generateText({\n   *   prompt: \"Summarize this article\",\n   *   model: \"gpt-4.1-mini\",\n   *   maxTokens: 150,\n   *   temperature: 0.7\n   * });\n   * \n   * // With web search (OpenAI models only)\n   * const { text, sources } = await blink.ai.generateText({\n   *   prompt: \"What are the latest developments in AI?\",\n   *   model: \"gpt-4.1-mini\",\n   *   search: true // Enables web search\n   * });\n   * \n   * // With advanced multi-step configuration\n   * const { text } = await blink.ai.generateText({\n   *   prompt: \"Research and analyze recent tech trends\",\n   *   model: \"gpt-4o\",\n   *   search: true,\n   *   maxSteps: 10, // Allow up to 10 reasoning steps\n   *   experimental_continueSteps: true // Enable continued reasoning\n   * });\n   * ```\n   * \n   * @returns Promise<TextGenerationResponse> - Object containing:\n   *   - `text`: Generated text string\n   *   - `usage`: Token usage information\n   *   - `finishReason`: Why generation stopped (\"stop\", \"length\", etc.)\n   */\n  async generateText(options) {\n    try {\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.messages) {\n        const validation = this.validateMessages(options.messages);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Message validation failed: ${validation.errors.join(\"; \")}`);\n        }\n      }\n      const requestBody = {\n        model: options.model,\n        stream: false,\n        search: options.search,\n        maxSteps: options.maxSteps,\n        experimental_continueSteps: options.experimental_continueSteps,\n        maxTokens: options.maxTokens,\n        temperature: options.temperature,\n        signal: options.signal\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      }\n      if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      const response = await this.httpClient.aiText(\n        options.prompt || \"\",\n        requestBody\n      );\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Text generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Streams text generation with real-time updates as the AI generates content.\n   * \n   * @param options - Same as generateText: either `prompt` or `messages` with optional parameters including search, maxSteps, experimental_continueSteps\n   * @param onChunk - Callback function that receives each text chunk as it's generated\n   * \n   * @example\n   * ```ts\n   * // Stream with prompt\n   * await blink.ai.streamText(\n   *   { prompt: \"Write a short story about space exploration\" },\n   *   (chunk) => {\n   *     process.stdout.write(chunk); // Real-time output\n   *   }\n   * );\n   * \n   * // Stream with messages\n   * await blink.ai.streamText(\n   *   { \n   *     messages: [\n   *       { role: \"system\", content: \"You are a creative writer\" },\n   *       { role: \"user\", content: \"Write a haiku about programming\" }\n   *     ]\n   *   },\n   *   (chunk) => updateUI(chunk)\n   * );\n   * ```\n   * \n   * @returns Promise<TextGenerationResponse> - Final complete response with full text and metadata\n   */\n  async streamText(options, onChunk) {\n    try {\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.messages) {\n        const validation = this.validateMessages(options.messages);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Message validation failed: ${validation.errors.join(\"; \")}`);\n        }\n      }\n      const result = await this.httpClient.streamAiText(\n        options.prompt || \"\",\n        {\n          model: options.model,\n          messages: options.messages,\n          search: options.search,\n          maxSteps: options.maxSteps,\n          experimental_continueSteps: options.experimental_continueSteps,\n          maxTokens: options.maxTokens,\n          temperature: options.temperature,\n          signal: options.signal\n        },\n        onChunk\n      );\n      return {\n        text: result.text || \"\",\n        finishReason: result.finishReason || \"stop\",\n        usage: result.usage,\n        toolCalls: result.toolCalls,\n        toolResults: result.toolResults,\n        sources: result.sources,\n        files: result.files,\n        reasoningDetails: result.reasoning,\n        response: result.response\n      };\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Text streaming failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates structured JSON objects using AI with schema validation.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Description of what object to generate (required)\n   *   - `schema`: JSON Schema to validate the generated object\n   *   - `output`: Type of output (\"object\", \"array\", \"enum\")\n   *   - `enum`: Array of allowed values for enum output\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Generate user profile\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"Generate a user profile for a software developer\",\n   *   schema: {\n   *     type: \"object\",\n   *     properties: {\n   *       name: { type: \"string\" },\n   *       age: { type: \"number\" },\n   *       skills: { type: \"array\", items: { type: \"string\" } },\n   *       experience: { type: \"number\" }\n   *     },\n   *     required: [\"name\", \"skills\"]\n   *   }\n   * });\n   * \n   * // Generate array of items\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"List 5 programming languages\",\n   *   output: \"array\",\n   *   schema: {\n   *     type: \"array\",\n   *     items: { type: \"string\" }\n   *   }\n   * });\n   * \n   * // Generate enum value\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"Choose the best programming language for web development\",\n   *   output: \"enum\",\n   *   enum: [\"JavaScript\", \"Python\", \"TypeScript\", \"Go\"]\n   * });\n   * ```\n   * \n   * @returns Promise<ObjectGenerationResponse> - Object containing:\n   *   - `object`: The generated and validated JSON object/array/enum\n   *   - `usage`: Token usage information\n   *   - `finishReason`: Why generation stopped\n   */\n  async generateObject(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const response = await this.httpClient.aiObject(\n        options.prompt,\n        {\n          model: options.model,\n          output: options.output,\n          schema: options.schema,\n          enum: options.enum,\n          stream: false,\n          signal: options.signal\n        }\n      );\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Object generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Streams structured object generation with real-time partial updates as the AI builds the object.\n   * \n   * @param options - Same as generateObject: prompt, schema, output type, etc.\n   * @param onPartial - Callback function that receives partial object updates as they're generated\n   * \n   * @example\n   * ```ts\n   * // Stream object generation with schema\n   * await blink.ai.streamObject(\n   *   {\n   *     prompt: \"Generate a detailed product catalog entry\",\n   *     schema: {\n   *       type: \"object\",\n   *       properties: {\n   *         name: { type: \"string\" },\n   *         price: { type: \"number\" },\n   *         description: { type: \"string\" },\n   *         features: { type: \"array\", items: { type: \"string\" } }\n   *       }\n   *     }\n   *   },\n   *   (partial) => {\n   *     console.log(\"Partial update:\", partial);\n   *     updateProductForm(partial); // Update UI in real-time\n   *   }\n   * );\n   * ```\n   * \n   * @returns Promise<ObjectGenerationResponse> - Final complete object with metadata\n   */\n  async streamObject(options, onPartial) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const result = await this.httpClient.streamAiObject(\n        options.prompt,\n        {\n          model: options.model,\n          output: options.output,\n          schema: options.schema,\n          enum: options.enum,\n          signal: options.signal\n        },\n        onPartial\n      );\n      return {\n        object: result.object || {},\n        finishReason: \"stop\",\n        usage: result.usage\n      };\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Object streaming failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates images from text descriptions using AI image models.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Text description of the desired image (required, up to 100k characters)\n   *   - `model`: AI model to use (optional). Available models:\n   *       **Fal.ai Models (Recommended):**\n   *       - `\"fal-ai/nano-banana\"` (default) - Gemini 2.5 Flash Image (Fast)\n   *       - `\"fal-ai/nano-banana-pro\"` - Gemini 3 Pro Image (High quality)\n   *       - `\"fal-ai/gemini-25-flash-image\"` - Alias for nano-banana\n   *       - `\"fal-ai/gemini-3-pro-image-preview\"` - Alias for nano-banana-pro\n   *       **Legacy Gemini Models:**\n   *       - `\"gemini-2.5-flash-image-preview\"` - Direct Gemini API\n   *       - `\"gemini-3-pro-image-preview\"` - Direct Gemini API\n   *   - `n`: Number of images to generate (default: 1)\n   *   - `size`: Image dimensions (e.g., \"1024x1024\", \"512x512\")\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Basic image generation (uses default fast model)\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A serene landscape with mountains and a lake at sunset\"\n   * });\n   * console.log(\"Image URL:\", data[0].url);\n   * \n   * // High quality generation with Pro model\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A detailed infographic about AI with charts and diagrams\",\n   *   model: \"fal-ai/nano-banana-pro\",\n   *   n: 2\n   * });\n   * \n   * // Fast generation with specific size\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A futuristic city skyline with flying cars\",\n   *   model: \"fal-ai/nano-banana\",\n   *   size: \"1024x1024\",\n   *   n: 3\n   * });\n   * data.forEach((img, i) => console.log(`Image ${i+1}:`, img.url));\n   * \n   * // Using legacy Gemini model\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A cute robot mascot for a tech company\",\n   *   model: \"gemini-2.5-flash-image-preview\"\n   * });\n   * ```\n   * \n   * @returns Promise<ImageGenerationResponse> - Object containing:\n   *   - `data`: Array of generated images with URLs\n   *   - `created`: Timestamp of generation\n   *   - `model`: The model used for generation\n   */\n  async generateImage(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const response = await this.httpClient.aiImage(\n        options.prompt,\n        {\n          model: options.model,\n          n: options.n,\n          size: options.size,\n          signal: options.signal\n        }\n      );\n      let imageResponse;\n      if (response.data?.result?.data) {\n        imageResponse = response.data.result;\n      } else if (response.data?.data) {\n        imageResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing image data\");\n      }\n      if (!Array.isArray(imageResponse.data)) {\n        throw new BlinkAIError(\"Invalid response format: data should be an array\");\n      }\n      imageResponse.data = imageResponse.data.map((item) => {\n        if (typeof item === \"string\") {\n          return { url: item };\n        } else if (item.url) {\n          return item;\n        } else {\n          throw new BlinkAIError(\"Invalid image response format\");\n        }\n      });\n      return imageResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Image generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Modifies existing images using AI image editing models with text prompts for image-to-image editing.\n   * \n   * @param options - Object containing:\n   *   - `images`: Array of public image URLs to modify (required, up to 50 images)\n   *   - `prompt`: Text description of desired modifications (required, up to 100k characters)\n   *   - `model`: AI model to use (optional). Available editing models:\n   *       **Fal.ai Editing Models (Recommended):**\n   *       - `\"fal-ai/nano-banana/edit\"` (default) - Flash editing (Fast)\n   *       - `\"fal-ai/nano-banana-pro/edit\"` - Pro editing (High quality)\n   *       - `\"fal-ai/gemini-25-flash-image/edit\"` - Alias for nano-banana/edit\n   *       - `\"fal-ai/gemini-3-pro-image-preview/edit\"` - Alias for nano-banana-pro/edit\n   *       **Legacy Gemini Models:**\n   *       - `\"gemini-2.5-flash-image-preview\"` - Direct Gemini API\n   *       - `\"gemini-3-pro-image-preview\"` - Direct Gemini API\n   *   - `n`: Number of output images to generate (default: 1)\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Fast editing with default model\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/photo.jpg\"],\n   *   prompt: \"make it green\"\n   * });\n   * \n   * // High quality editing with Pro model\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/landscape.jpg\"],\n   *   prompt: \"add a tree in the background\",\n   *   model: \"fal-ai/nano-banana-pro/edit\"\n   * });\n   * \n   * // Professional headshots from casual photos\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\n   *     \"https://storage.example.com/user-photo-1.jpg\",\n   *     \"https://storage.example.com/user-photo-2.jpg\"\n   *   ],\n   *   prompt: \"Transform into professional business headshots with studio lighting\",\n   *   model: \"fal-ai/nano-banana/edit\",\n   *   n: 4\n   * });\n   * data.forEach((img, i) => console.log(`Headshot ${i+1}:`, img.url));\n   * \n   * // Artistic style transformation\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/portrait.jpg\"],\n   *   prompt: \"Transform into oil painting style with dramatic lighting\",\n   *   model: \"fal-ai/nano-banana-pro/edit\"\n   * });\n   * \n   * // Background replacement\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/product.jpg\"],\n   *   prompt: \"Remove background and place on clean white studio background\",\n   *   n: 2\n   * });\n   * \n   * // Batch processing multiple photos\n   * const userPhotos = [\n   *   \"https://storage.example.com/photo1.jpg\",\n   *   \"https://storage.example.com/photo2.jpg\",\n   *   \"https://storage.example.com/photo3.jpg\"\n   * ];\n   * const { data } = await blink.ai.modifyImage({\n   *   images: userPhotos,\n   *   prompt: \"Convert to black and white vintage style photographs\"\n   * });\n   * \n   * //  Style Transfer - IMPORTANT: Provide all images in array\n   * //  WRONG - Don't reference other images in prompt\n   * const wrong = await blink.ai.modifyImage({\n   *   images: [userPhotoUrl],\n   *   prompt: `Apply hairstyle from ${referenceUrl}`\n   * });\n   * \n   * //  CORRECT - Provide all images in array\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [userPhotoUrl, hairstyleReferenceUrl],\n   *   prompt: \"Apply the hairstyle from the second image to the person in the first image\"\n   * });\n   * ```\n   * \n   * @returns Promise<ImageGenerationResponse> - Object containing:\n   *   - `data`: Array of modified images with URLs\n   *   - `created`: Timestamp of generation\n   *   - `model`: The model used for editing\n   */\n  async modifyImage(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      if (!options.images || !Array.isArray(options.images) || options.images.length === 0) {\n        throw new BlinkAIError(\"Images array is required and must contain at least one image URL\");\n      }\n      if (options.images.length > 50) {\n        throw new BlinkAIError(\"Maximum 50 images allowed\");\n      }\n      for (let i = 0; i < options.images.length; i++) {\n        const validation = this.validateImageUrl(options.images[i]);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Image ${i + 1}: ${validation.error}`);\n        }\n      }\n      const response = await this.httpClient.aiImage(\n        options.prompt,\n        // Non-null assertion since we validated above\n        {\n          model: options.model,\n          images: options.images,\n          n: options.n,\n          signal: options.signal\n        }\n      );\n      let imageResponse;\n      if (response.data?.result?.data) {\n        imageResponse = response.data.result;\n      } else if (response.data?.data) {\n        imageResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing image data\");\n      }\n      if (!Array.isArray(imageResponse.data)) {\n        throw new BlinkAIError(\"Invalid response format: data should be an array\");\n      }\n      imageResponse.data = imageResponse.data.map((item) => {\n        if (typeof item === \"string\") {\n          return { url: item };\n        } else if (item.url) {\n          return item;\n        } else {\n          throw new BlinkAIError(\"Invalid image response format\");\n        }\n      });\n      return imageResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Image modification failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates videos from text prompts or images using AI video generation models.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Text description of the video to generate (required)\n   *   - `model`: Video model to use (optional). Available models:\n   *       **Text-to-Video Models:**\n   *       - `\"fal-ai/veo3.1\"` - Google Veo 3.1 (best quality)\n   *       - `\"fal-ai/veo3.1/fast\"` (default) - Veo 3.1 fast mode (faster, cheaper)\n   *       - `\"fal-ai/sora-2/text-to-video/pro\"` - OpenAI Sora 2\n   *       - `\"fal-ai/kling-video/v2.6/pro/text-to-video\"` - Kling 2.6\n   *       **Image-to-Video Models:**\n   *       - `\"fal-ai/veo3.1/image-to-video\"` - Veo 3.1 I2V\n   *       - `\"fal-ai/veo3.1/fast/image-to-video\"` - Veo 3.1 fast I2V\n   *       - `\"fal-ai/sora-2/image-to-video/pro\"` - Sora 2 I2V\n   *       - `\"fal-ai/kling-video/v2.6/pro/image-to-video\"` - Kling 2.6 I2V\n   *   - `image_url`: Source image URL for image-to-video (required for I2V models)\n   *   - `duration`: Video duration (\"4s\", \"5s\", \"6s\", \"8s\", \"10s\", \"12s\")\n   *   - `aspect_ratio`: Aspect ratio (\"16:9\", \"9:16\", \"1:1\")\n   *   - `resolution`: Resolution (\"720p\", \"1080p\") - Veo/Sora only\n   *   - `negative_prompt`: What to avoid in generation - Veo/Kling only\n   *   - `generate_audio`: Generate audio with video (default: true)\n   *   - `seed`: For reproducibility - Veo only\n   *   - `cfg_scale`: Guidance scale (0-1) - Kling only\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Basic text-to-video generation (uses default fast model)\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"A serene sunset over the ocean with gentle waves\"\n   * });\n   * console.log(\"Video URL:\", result.video.url);\n   * \n   * // High quality with Veo 3.1\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"A cinematic shot of a futuristic city at night\",\n   *   model: \"fal-ai/veo3.1\",\n   *   resolution: \"1080p\",\n   *   aspect_ratio: \"16:9\"\n   * });\n   * \n   * // Image-to-video animation\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"Animate this image with gentle camera movement\",\n   *   model: \"fal-ai/veo3.1/fast/image-to-video\",\n   *   image_url: \"https://example.com/my-image.jpg\",\n   *   duration: \"5s\"\n   * });\n   * \n   * // Using Sora 2 for creative videos\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"A magical forest with glowing fireflies\",\n   *   model: \"fal-ai/sora-2/text-to-video/pro\",\n   *   duration: \"8s\"\n   * });\n   * \n   * // Using Kling for detailed videos\n   * const { result, usage } = await blink.ai.generateVideo({\n   *   prompt: \"A professional cooking tutorial scene\",\n   *   model: \"fal-ai/kling-video/v2.6/pro/text-to-video\",\n   *   negative_prompt: \"blur, distort, low quality\",\n   *   cfg_scale: 0.7\n   * });\n   * console.log(\"Credits charged:\", usage?.creditsCharged);\n   * ```\n   * \n   * @returns Promise<VideoGenerationResponse> - Object containing:\n   *   - `result.video.url`: URL to the generated video\n   *   - `result.video.content_type`: MIME type (video/mp4)\n   *   - `result.video.file_name`: Generated filename\n   *   - `result.video.file_size`: File size in bytes\n   *   - `metadata`: Generation metadata (projectId, timestamp, model)\n   *   - `usage`: Credits charged and cost information\n   */\n  async generateVideo(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const i2vModels = [\n        \"fal-ai/veo3.1/image-to-video\",\n        \"fal-ai/veo3.1/fast/image-to-video\",\n        \"fal-ai/sora-2/image-to-video/pro\",\n        \"fal-ai/kling-video/v2.6/pro/image-to-video\"\n      ];\n      if (options.model && i2vModels.includes(options.model) && !options.image_url) {\n        throw new BlinkAIError(\"image_url is required for image-to-video models\");\n      }\n      if (options.image_url) {\n        const validation = this.validateImageUrl(options.image_url);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Invalid image_url: ${validation.error}`);\n        }\n      }\n      const response = await this.httpClient.aiVideo(\n        options.prompt,\n        {\n          model: options.model,\n          image_url: options.image_url,\n          duration: options.duration,\n          aspect_ratio: options.aspect_ratio,\n          resolution: options.resolution,\n          negative_prompt: options.negative_prompt,\n          generate_audio: options.generate_audio,\n          seed: options.seed,\n          cfg_scale: options.cfg_scale,\n          signal: options.signal\n        }\n      );\n      if (!response.data?.result?.video?.url) {\n        throw new BlinkAIError(\"Invalid response format: missing video URL\");\n      }\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Video generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Converts text to speech using AI voice synthesis models.\n   * \n   * @param options - Object containing:\n   *   - `text`: Text content to convert to speech (required)\n   *   - `voice`: Voice to use (\"alloy\", \"echo\", \"fable\", \"onyx\", \"nova\", \"shimmer\")\n   *   - `response_format`: Audio format (\"mp3\", \"opus\", \"aac\", \"flac\", \"wav\", \"pcm\")\n   *   - `speed`: Speech speed (0.25 to 4.0, default: 1.0)\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Basic text-to-speech\n   * const { url } = await blink.ai.generateSpeech({\n   *   text: \"Hello, welcome to our AI-powered application!\"\n   * });\n   * console.log(\"Audio URL:\", url);\n   * \n   * // Custom voice and format\n   * const { url, voice, format } = await blink.ai.generateSpeech({\n   *   text: \"This is a demonstration of our speech synthesis capabilities.\",\n   *   voice: \"nova\",\n   *   response_format: \"wav\",\n   *   speed: 1.2\n   * });\n   * console.log(`Generated ${format} audio with ${voice} voice:`, url);\n   * \n   * // Slow, clear speech for accessibility\n   * const { url } = await blink.ai.generateSpeech({\n   *   text: \"Please listen carefully to these important instructions.\",\n   *   voice: \"echo\",\n   *   speed: 0.8\n   * });\n   * ```\n   * \n   * @returns Promise<SpeechGenerationResponse> - Object containing:\n   *   - `url`: URL to the generated audio file\n   *   - `voice`: Voice used for generation\n   *   - `format`: Audio format\n   *   - `mimeType`: MIME type of the audio\n   */\n  async generateSpeech(options) {\n    try {\n      if (!options.text) {\n        throw new BlinkAIError(\"Text is required\");\n      }\n      const response = await this.httpClient.aiSpeech(\n        options.text,\n        {\n          model: options.model,\n          voice: options.voice,\n          response_format: options.response_format,\n          speed: options.speed,\n          signal: options.signal\n        }\n      );\n      let speechResponse;\n      if (response.data?.result) {\n        speechResponse = response.data.result;\n      } else if (response.data?.url) {\n        speechResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing speech data\");\n      }\n      if (!speechResponse.url) {\n        if (typeof response.data === \"string\") {\n          speechResponse = {\n            url: response.data,\n            voice: options.voice || \"alloy\",\n            format: options.response_format || \"mp3\",\n            mimeType: this.getMimeTypeForFormat(options.response_format || \"mp3\")\n          };\n        } else if (response.data?.data) {\n          speechResponse = {\n            url: response.data.data,\n            voice: options.voice || \"alloy\",\n            format: options.response_format || \"mp3\",\n            mimeType: this.getMimeTypeForFormat(options.response_format || \"mp3\")\n          };\n        } else {\n          throw new BlinkAIError(\"Invalid response format: no audio URL found\");\n        }\n      }\n      if (!speechResponse.voice) {\n        speechResponse.voice = options.voice || \"alloy\";\n      }\n      if (!speechResponse.format) {\n        speechResponse.format = options.response_format || \"mp3\";\n      }\n      if (!speechResponse.mimeType) {\n        speechResponse.mimeType = this.getMimeTypeForFormat(speechResponse.format);\n      }\n      return speechResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Speech generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Transcribes audio content to text using AI speech recognition models.\n   * \n   * @param options - Object containing:\n   *   - `audio`: Audio input as URL string, base64 string, or number array buffer (required)\n   *   - `language`: Language code for transcription (e.g., \"en\", \"es\", \"fr\")\n   *   - `response_format`: Output format (\"json\", \"text\", \"srt\", \"verbose_json\", \"vtt\")\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Transcribe from URL\n   * const { text } = await blink.ai.transcribeAudio({\n   *   audio: \"https://example.com/meeting-recording.mp3\"\n   * });\n   * console.log(\"Transcription:\", text);\n   * \n   * // Transcribe with language hint\n   * const { text, language } = await blink.ai.transcribeAudio({\n   *   audio: \"https://example.com/spanish-audio.wav\",\n   *   language: \"es\"\n   * });\n   * console.log(`Transcribed ${language}:`, text);\n   * \n   * // Transcribe with timestamps (verbose format)\n   * const result = await blink.ai.transcribeAudio({\n   *   audio: audioFileUrl,\n   *   response_format: \"verbose_json\"\n   * });\n   * result.segments?.forEach(segment => {\n   *   console.log(`${segment.start}s - ${segment.end}s: ${segment.text}`);\n   * });\n   * \n   * // Transcribe from audio buffer\n   * const audioBuffer = new Array(1024).fill(0); // Your audio data\n   * const { text } = await blink.ai.transcribeAudio({\n   *   audio: audioBuffer,\n   *   language: \"en\"\n   * });\n   * ```\n   * \n   * @returns Promise<TranscriptionResponse> - Object containing:\n   *   - `text`: Transcribed text content\n   *   - `transcript`: Alias for text\n   *   - `segments`: Array of timestamped segments (if verbose format)\n   *   - `language`: Detected language\n   *   - `duration`: Audio duration in seconds\n   */\n  async transcribeAudio(options) {\n    try {\n      if (!options.audio) {\n        throw new BlinkAIError(\"Audio is required\");\n      }\n      const response = await this.httpClient.aiTranscribe(\n        options.audio,\n        {\n          model: options.model,\n          language: options.language,\n          response_format: options.response_format,\n          signal: options.signal\n        }\n      );\n      if (response.data?.result) {\n        return response.data.result;\n      } else if (response.data?.text || response.data?.transcript) {\n        return {\n          text: response.data.text || response.data.transcript,\n          transcript: response.data.transcript || response.data.text,\n          ...response.data\n        };\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing transcription text\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Audio transcription failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  async agent(options) {\n    try {\n      if (!options.agent?.model) {\n        throw new BlinkAIError(\"agent.model is required\");\n      }\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.prompt && options.messages) {\n        throw new BlinkAIError(\"prompt and messages are mutually exclusive\");\n      }\n      const serializedTools = options.agent.tools ? serializeTools(options.agent.tools) : void 0;\n      const requestBody = {\n        stream: options.stream,\n        agent: {\n          model: options.agent.model,\n          system: options.agent.system,\n          tools: serializedTools,\n          webhook_tools: options.agent.webhook_tools,\n          client_tools: options.agent.client_tools,\n          tool_choice: options.agent.tool_choice,\n          stop_when: options.agent.stop_when,\n          prepare_step: options.agent.prepare_step\n        }\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      } else if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      if (options.stream) {\n        return await this.httpClient.aiAgentStream(requestBody, options.signal);\n      } else {\n        const response = await this.httpClient.aiAgent(requestBody, options.signal);\n        return response.data;\n      }\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Agent request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  // ============================================================================\n  // Agent Factory\n  // ============================================================================\n  /**\n   * Creates a reusable Agent instance with the Vercel AI SDK pattern.\n   * \n   * The Agent can be used multiple times with different prompts:\n   * - `agent.generate({ prompt })` for non-streaming\n   * - `agent.stream({ prompt })` for streaming\n   * \n   * @param options - Agent configuration (model, tools, system, etc.)\n   * @returns Agent instance\n   * \n   * @example\n   * ```ts\n   * const weatherAgent = blink.ai.createAgent({\n   *   model: 'anthropic/claude-sonnet-4-20250514',\n   *   system: 'You are a helpful weather assistant.',\n   *   tools: [webSearch, fetchUrl],\n   *   maxSteps: 10,\n   * })\n   * \n   * // Non-streaming\n   * const result = await weatherAgent.generate({\n   *   prompt: 'What is the weather in San Francisco?',\n   * })\n   * \n   * // Streaming\n   * const stream = await weatherAgent.stream({\n   *   prompt: 'Tell me about weather patterns',\n   * })\n   * ```\n   */\n  createAgent(options) {\n    const agent = new Agent(options);\n    agent._setHttpClient(this.httpClient);\n    return agent;\n  }\n  /**\n   * Binds an existing Agent instance to this client's HTTP client.\n   * \n   * Used internally by useAgent() when an Agent instance is passed.\n   * This allows agents created with `new Agent()` to be used with the hook.\n   * \n   * @param agent - Existing Agent instance\n   * @returns The same Agent instance (with httpClient set)\n   */\n  bindAgent(agent) {\n    agent._setHttpClient(this.httpClient);\n    return agent;\n  }\n};\n\n// src/data.ts\nvar BlinkDataImpl = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  async extractFromUrl(url, options = {}) {\n    const { chunking = false, chunkSize } = options;\n    const request = { url, chunking, chunkSize };\n    const response = await this.httpClient.dataExtractFromUrl(this.projectId, request);\n    return chunking ? response.data.chunks : response.data.text;\n  }\n  async extractFromBlob(file, options = {}) {\n    const { chunking = false, chunkSize } = options;\n    const response = await this.httpClient.dataExtractFromBlob(this.projectId, file, chunking, chunkSize);\n    return chunking ? response.data.chunks : response.data.text;\n  }\n  async scrape(url) {\n    const request = {\n      url,\n      formats: [\"markdown\", \"html\", \"links\", \"extract\", \"metadata\"]\n    };\n    const response = await this.httpClient.dataScrape(this.projectId, request);\n    const data = response.data;\n    return {\n      markdown: data.markdown || \"\",\n      html: data.html || \"\",\n      metadata: {\n        title: data.metadata?.title || \"\",\n        description: data.metadata?.description || \"\",\n        url: data.metadata?.url || url,\n        domain: data.metadata?.domain || new URL(url).hostname,\n        favicon: data.metadata?.favicon,\n        image: data.metadata?.image,\n        author: data.metadata?.author,\n        publishedTime: data.metadata?.publishedTime,\n        modifiedTime: data.metadata?.modifiedTime,\n        type: data.metadata?.type,\n        siteName: data.metadata?.siteName,\n        locale: data.metadata?.locale,\n        keywords: data.metadata?.keywords || []\n      },\n      links: data.links || [],\n      extract: {\n        title: data.extract?.title || data.metadata?.title || \"\",\n        description: data.extract?.description || data.metadata?.description || \"\",\n        headings: data.extract?.headings || [],\n        text: data.extract?.text || data.markdown || \"\"\n      }\n    };\n  }\n  async screenshot(url, options = {}) {\n    const request = { url, ...options };\n    const response = await this.httpClient.dataScreenshot(this.projectId, request);\n    return response.data.url;\n  }\n  async fetch(request) {\n    const response = await this.httpClient.dataFetch(this.projectId, request);\n    if (\"status\" in response.data && \"headers\" in response.data) {\n      return response.data;\n    }\n    throw new BlinkDataError(\"Unexpected response format from fetch endpoint\");\n  }\n  async fetchAsync(request) {\n    const asyncRequest = { ...request, async: true };\n    const response = await this.httpClient.dataFetch(this.projectId, asyncRequest);\n    if (\"status\" in response.data && response.data.status === \"triggered\") {\n      return response.data;\n    }\n    throw new BlinkDataError(\"Unexpected response format from async fetch endpoint\");\n  }\n  async search(query, options) {\n    const normalizeType = (type) => {\n      switch (type) {\n        case \"news\":\n          return \"nws\";\n        case \"images\":\n        case \"image\":\n          return \"isch\";\n        case \"videos\":\n        case \"video\":\n          return \"vid\";\n        case \"shopping\":\n        case \"shop\":\n          return \"shop\";\n        default:\n          return void 0;\n      }\n    };\n    const request = {\n      q: query,\n      location: options?.location,\n      hl: options?.language || \"en\",\n      tbm: normalizeType(options?.type),\n      num: options?.limit\n    };\n    const response = await this.httpClient.dataSearch(this.projectId, request);\n    return response.data;\n  }\n};\n\n// src/realtime-connection.ts\nvar getWebSocketClass = () => {\n  if (typeof WebSocket !== \"undefined\") {\n    return WebSocket;\n  }\n  try {\n    const WS = __require(\"ws\");\n    return WS;\n  } catch (error) {\n    throw new BlinkRealtimeError('WebSocket is not available. Install \"ws\" package for Node.js environments.');\n  }\n};\nvar RealtimeConnection = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  websocket = null;\n  isConnected = false;\n  isConnecting = false;\n  reconnectTimer = null;\n  heartbeatTimer = null;\n  reconnectAttempts = 0;\n  connectionPromise = null;\n  // Channel management\n  channels = /* @__PURE__ */ new Map();\n  pendingSubscriptions = /* @__PURE__ */ new Map();\n  // Message queue for when socket not ready\n  messageQueue = [];\n  /**\n   * Check if connection is ready\n   */\n  isReady() {\n    return this.isConnected && this.websocket?.readyState === 1;\n  }\n  /**\n   * Ensure WebSocket connection is established\n   */\n  async connect() {\n    if (this.isConnected && this.websocket?.readyState === 1) {\n      return;\n    }\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n    this.connectionPromise = this.connectWebSocket();\n    try {\n      await this.connectionPromise;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n  /**\n   * Join a channel (subscribe)\n   */\n  async joinChannel(channelName, handler, options = {}) {\n    await this.connect();\n    this.channels.set(channelName, { handler, options });\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pendingSubscriptions.delete(channelName);\n        this.channels.delete(channelName);\n        reject(new BlinkRealtimeError(\"Subscription timeout - no acknowledgment from server\"));\n      }, 1e4);\n      this.pendingSubscriptions.set(channelName, { resolve, reject, timeout });\n      const subscribeMessage = {\n        type: \"subscribe\",\n        payload: {\n          channel: channelName,\n          userId: options.userId,\n          metadata: options.metadata\n        }\n      };\n      try {\n        this.sendRaw(JSON.stringify(subscribeMessage));\n      } catch (error) {\n        clearTimeout(timeout);\n        this.pendingSubscriptions.delete(channelName);\n        this.channels.delete(channelName);\n        reject(error);\n      }\n    });\n  }\n  /**\n   * Leave a channel (unsubscribe)\n   */\n  async leaveChannel(channelName) {\n    this.channels.delete(channelName);\n    const pending = this.pendingSubscriptions.get(channelName);\n    if (pending) {\n      clearTimeout(pending.timeout);\n      pending.reject(new BlinkRealtimeError(\"Subscription cancelled\"));\n      this.pendingSubscriptions.delete(channelName);\n    }\n    if (this.websocket && this.websocket.readyState === 1) {\n      const unsubscribeMessage = {\n        type: \"unsubscribe\",\n        payload: { channel: channelName }\n      };\n      this.websocket.send(JSON.stringify(unsubscribeMessage));\n    }\n    if (this.channels.size === 0) {\n      this.disconnect();\n    }\n  }\n  /**\n   * Send a message to a channel\n   */\n  async send(channelName, type, data, options = {}) {\n    await this.connect();\n    const publishMessage = {\n      type: \"publish\",\n      payload: {\n        channel: channelName,\n        type,\n        data,\n        userId: options.userId,\n        metadata: options.metadata\n      }\n    };\n    return this.sendWithResponse(JSON.stringify(publishMessage), channelName);\n  }\n  /**\n   * Disconnect and cleanup\n   */\n  disconnect() {\n    this.isConnected = false;\n    this.isConnecting = false;\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.messageQueue.forEach((q) => {\n      clearTimeout(q.timeout);\n      q.reject(new BlinkRealtimeError(\"Connection closed\"));\n    });\n    this.messageQueue = [];\n    this.pendingSubscriptions.forEach((pending, channel) => {\n      clearTimeout(pending.timeout);\n      pending.reject(new BlinkRealtimeError(\"Connection closed\"));\n    });\n    this.pendingSubscriptions.clear();\n    if (this.websocket) {\n      this.websocket.close();\n      this.websocket = null;\n    }\n  }\n  /**\n   * Get count of active channels\n   */\n  getChannelCount() {\n    return this.channels.size;\n  }\n  // Private methods\n  async connectWebSocket() {\n    if (this.websocket && this.websocket.readyState === 1) {\n      this.isConnected = true;\n      return;\n    }\n    if (this.isConnecting) {\n      return new Promise((resolve, reject) => {\n        const checkConnection = () => {\n          if (this.isConnected) {\n            resolve();\n          } else if (!this.isConnecting) {\n            reject(new BlinkRealtimeError(\"Connection failed\"));\n          } else {\n            setTimeout(checkConnection, 100);\n          }\n        };\n        checkConnection();\n      });\n    }\n    this.isConnecting = true;\n    this.isConnected = false;\n    return new Promise((resolve, reject) => {\n      try {\n        const httpClient = this.httpClient;\n        const coreUrl = httpClient.coreUrl || \"https://core.blink.new\";\n        const baseUrl = coreUrl.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\");\n        const wsUrl = `${baseUrl}?project_id=${this.projectId}`;\n        console.log(`\\u{1F517} Connecting to realtime: ${wsUrl}`);\n        const WSClass = getWebSocketClass();\n        this.websocket = new WSClass(wsUrl);\n        if (!this.websocket) {\n          this.isConnecting = false;\n          reject(new BlinkRealtimeError(\"Failed to create WebSocket instance\"));\n          return;\n        }\n        this.websocket.onopen = () => {\n          console.log(`\\u{1F517} Connected to realtime for project ${this.projectId}`);\n          this.isConnecting = false;\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n          this.startHeartbeat();\n          this.flushMessageQueue();\n          resolve();\n        };\n        this.websocket.onmessage = (event) => {\n          try {\n            const message = JSON.parse(event.data);\n            this.handleMessage(message);\n          } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n          }\n        };\n        this.websocket.onclose = () => {\n          console.log(`\\u{1F50C} Disconnected from realtime for project ${this.projectId}`);\n          this.isConnecting = false;\n          this.isConnected = false;\n          this.rejectQueuedMessages(new BlinkRealtimeError(\"WebSocket connection closed\"));\n          this.scheduleReconnect();\n        };\n        this.websocket.onerror = (error) => {\n          console.error(\"WebSocket error:\", error);\n          this.isConnecting = false;\n          this.isConnected = false;\n          reject(new BlinkRealtimeError(`WebSocket connection failed to ${wsUrl}`));\n        };\n        setTimeout(() => {\n          if (this.websocket?.readyState !== 1) {\n            this.isConnecting = false;\n            reject(new BlinkRealtimeError(\"WebSocket connection timeout\"));\n          }\n        }, 1e4);\n      } catch (error) {\n        this.isConnecting = false;\n        reject(new BlinkRealtimeError(`Failed to create WebSocket connection: ${error instanceof Error ? error.message : \"Unknown error\"}`));\n      }\n    });\n  }\n  handleMessage(message) {\n    const channelName = message.payload?.channel;\n    switch (message.type) {\n      case \"connected\":\n        console.log(`\\u2705 WebSocket connected: ${message.payload?.socketId}`);\n        break;\n      case \"subscribed\":\n        console.log(`\\u2705 Subscribed to channel: ${channelName}`);\n        const pendingSub = this.pendingSubscriptions.get(channelName);\n        if (pendingSub) {\n          clearTimeout(pendingSub.timeout);\n          pendingSub.resolve();\n          this.pendingSubscriptions.delete(channelName);\n        }\n        const subHandler = this.channels.get(channelName);\n        if (subHandler) {\n          subHandler.handler.onSubscribed();\n        }\n        break;\n      case \"message\":\n        const msgChannel = this.channels.get(message.payload?.channel);\n        if (msgChannel) {\n          msgChannel.handler.onMessage(message.payload);\n        }\n        break;\n      case \"presence\":\n        const presChannel = this.channels.get(message.payload?.channel);\n        if (presChannel) {\n          const users = message.payload?.data?.users || [];\n          presChannel.handler.onPresence(users);\n        }\n        break;\n      case \"published\":\n        break;\n      case \"pong\":\n        break;\n      case \"error\":\n        console.error(\"Realtime error:\", message.payload?.error);\n        const errChannel = this.channels.get(channelName);\n        if (errChannel) {\n          errChannel.handler.onError(message.payload?.error);\n        }\n        const pendingErr = this.pendingSubscriptions.get(channelName);\n        if (pendingErr) {\n          clearTimeout(pendingErr.timeout);\n          pendingErr.reject(new BlinkRealtimeError(`Subscription error: ${message.payload?.error}`));\n          this.pendingSubscriptions.delete(channelName);\n        }\n        break;\n      case \"unsubscribed\":\n        console.log(`\\u274C Unsubscribed from channel: ${channelName}`);\n        break;\n      default:\n        console.log(\"Unknown message type:\", message.type);\n    }\n  }\n  sendRaw(message) {\n    if (this.websocket && this.websocket.readyState === 1) {\n      this.websocket.send(message);\n    } else {\n      throw new BlinkRealtimeError(\"Cannot send message: WebSocket not connected\");\n    }\n  }\n  sendWithResponse(message, channelName) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const index = this.messageQueue.findIndex((q) => q.resolve === resolve);\n        if (index > -1) {\n          this.messageQueue.splice(index, 1);\n        }\n        reject(new BlinkRealtimeError(\"Message send timeout - no response from server\"));\n      }, 1e4);\n      if (this.websocket && this.websocket.readyState === 1) {\n        const handleResponse = (event) => {\n          try {\n            const response = JSON.parse(event.data);\n            if (response.type === \"published\" && response.payload.channel === channelName) {\n              clearTimeout(timeout);\n              this.websocket.removeEventListener(\"message\", handleResponse);\n              resolve(response.payload.messageId);\n            } else if (response.type === \"error\") {\n              clearTimeout(timeout);\n              this.websocket.removeEventListener(\"message\", handleResponse);\n              reject(new BlinkRealtimeError(`Server error: ${response.payload.error}`));\n            }\n          } catch (err) {\n          }\n        };\n        this.websocket.addEventListener(\"message\", handleResponse);\n        this.websocket.send(message);\n      } else {\n        this.messageQueue.push({ message, resolve, reject, timeout });\n      }\n    });\n  }\n  flushMessageQueue() {\n    if (!this.websocket || this.websocket.readyState !== 1) return;\n    const queue = [...this.messageQueue];\n    this.messageQueue = [];\n    queue.forEach((q) => {\n      try {\n        this.websocket.send(q.message);\n      } catch (error) {\n        clearTimeout(q.timeout);\n        q.reject(new BlinkRealtimeError(\"Failed to send queued message\"));\n      }\n    });\n  }\n  rejectQueuedMessages(error) {\n    const queue = [...this.messageQueue];\n    this.messageQueue = [];\n    queue.forEach((q) => {\n      clearTimeout(q.timeout);\n      q.reject(error);\n    });\n  }\n  startHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n    }\n    this.heartbeatTimer = globalThis.setInterval(() => {\n      if (this.websocket && this.websocket.readyState === 1) {\n        this.websocket.send(JSON.stringify({ type: \"ping\", payload: {} }));\n      }\n    }, 25e3);\n  }\n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    if (this.channels.size === 0) {\n      return;\n    }\n    this.reconnectAttempts++;\n    const baseDelay = Math.min(3e4, Math.pow(2, this.reconnectAttempts) * 1e3);\n    const jitter = Math.random() * 1e3;\n    const delay = baseDelay + jitter;\n    console.log(`\\u{1F504} Scheduling reconnect attempt ${this.reconnectAttempts} in ${Math.round(delay)}ms`);\n    this.reconnectTimer = globalThis.setTimeout(async () => {\n      if (this.channels.size === 0) return;\n      try {\n        await this.connectWebSocket();\n        await this.resubscribeAllChannels();\n      } catch (error) {\n        console.error(\"Reconnection failed:\", error);\n        this.scheduleReconnect();\n      }\n    }, delay);\n  }\n  async resubscribeAllChannels() {\n    console.log(`\\u{1F504} Resubscribing ${this.channels.size} channels...`);\n    for (const [channelName, subscription] of this.channels) {\n      try {\n        const subscribeMessage = {\n          type: \"subscribe\",\n          payload: {\n            channel: channelName,\n            userId: subscription.options.userId,\n            metadata: subscription.options.metadata\n          }\n        };\n        if (this.websocket && this.websocket.readyState === 1) {\n          this.websocket.send(JSON.stringify(subscribeMessage));\n        }\n      } catch (error) {\n        console.error(`Failed to resubscribe to ${channelName}:`, error);\n      }\n    }\n  }\n};\n\n// src/realtime.ts\nvar BlinkRealtimeChannel = class {\n  constructor(channelName, connection, httpClient, projectId) {\n    this.channelName = channelName;\n    this.connection = connection;\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  messageCallbacks = [];\n  presenceCallbacks = [];\n  isSubscribed = false;\n  subscribeOptions = {};\n  /**\n   * Check if channel is ready for publishing\n   */\n  isReady() {\n    return this.isSubscribed && this.connection.isReady();\n  }\n  async subscribe(options = {}) {\n    if (this.isSubscribed) {\n      return;\n    }\n    this.subscribeOptions = options;\n    const handler = {\n      onMessage: (message) => {\n        this.messageCallbacks.forEach((callback) => {\n          try {\n            callback(message);\n          } catch (error) {\n            console.error(\"Error in message callback:\", error);\n          }\n        });\n      },\n      onPresence: (users) => {\n        this.presenceCallbacks.forEach((callback) => {\n          try {\n            callback(users);\n          } catch (error) {\n            console.error(\"Error in presence callback:\", error);\n          }\n        });\n      },\n      onSubscribed: () => {\n        this.isSubscribed = true;\n      },\n      onError: (error) => {\n        console.error(`Channel ${this.channelName} error:`, error);\n      }\n    };\n    await this.connection.joinChannel(this.channelName, handler, options);\n    this.isSubscribed = true;\n  }\n  async unsubscribe() {\n    if (!this.isSubscribed) {\n      return;\n    }\n    await this.connection.leaveChannel(this.channelName);\n    this.cleanup();\n  }\n  async publish(type, data, options = {}) {\n    return this.connection.send(this.channelName, type, data, options);\n  }\n  onMessage(callback) {\n    this.messageCallbacks.push(callback);\n    return () => {\n      const index = this.messageCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.messageCallbacks.splice(index, 1);\n      }\n    };\n  }\n  onPresence(callback) {\n    this.presenceCallbacks.push(callback);\n    return () => {\n      const index = this.presenceCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.presenceCallbacks.splice(index, 1);\n      }\n    };\n  }\n  async getPresence() {\n    try {\n      const response = await this.httpClient.realtimeGetPresence(this.projectId, this.channelName);\n      return response.data.users || [];\n    } catch (error) {\n      throw new BlinkRealtimeError(\n        `Failed to get presence for channel ${this.channelName}: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  async getMessages(options = {}) {\n    try {\n      const response = await this.httpClient.realtimeGetMessages(this.projectId, {\n        channel: this.channelName,\n        limit: options.limit,\n        start: options.after || \"-\",\n        end: options.before || \"+\"\n      });\n      return response.data.messages || [];\n    } catch (error) {\n      throw new BlinkRealtimeError(\n        `Failed to get messages for channel ${this.channelName}: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  cleanup() {\n    this.isSubscribed = false;\n    this.subscribeOptions = {};\n    this.messageCallbacks = [];\n    this.presenceCallbacks = [];\n  }\n};\nvar BlinkRealtimeImpl = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n    this.connection = new RealtimeConnection(httpClient, projectId);\n  }\n  connection;\n  channels = /* @__PURE__ */ new Map();\n  handlers = {};\n  channel(name) {\n    if (!this.channels.has(name)) {\n      this.channels.set(name, new BlinkRealtimeChannel(name, this.connection, this.httpClient, this.projectId));\n    }\n    return this.channels.get(name);\n  }\n  async subscribe(channelName, callback, options = {}) {\n    const channel = this.channel(channelName);\n    await channel.subscribe(options);\n    const state = this.handlers[channelName] ??= {\n      msgHandlers: /* @__PURE__ */ new Set(),\n      presHandlers: /* @__PURE__ */ new Set(),\n      subscribed: true\n    };\n    state.msgHandlers.add(callback);\n    const messageUnsub = channel.onMessage(callback);\n    return () => {\n      messageUnsub();\n      state.msgHandlers.delete(callback);\n      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {\n        channel.unsubscribe();\n        delete this.handlers[channelName];\n      }\n    };\n  }\n  async publish(channelName, type, data, options = {}) {\n    const channel = this.channel(channelName);\n    return channel.publish(type, data, options);\n  }\n  async presence(channelName) {\n    const channel = this.channel(channelName);\n    return channel.getPresence();\n  }\n  onPresence(channelName, callback) {\n    const channel = this.channel(channelName);\n    const state = this.handlers[channelName] ??= {\n      msgHandlers: /* @__PURE__ */ new Set(),\n      presHandlers: /* @__PURE__ */ new Set(),\n      subscribed: false\n    };\n    state.presHandlers.add(callback);\n    const presenceUnsub = channel.onPresence(callback);\n    return () => {\n      presenceUnsub();\n      state.presHandlers.delete(callback);\n      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {\n        channel.unsubscribe();\n        delete this.handlers[channelName];\n      }\n    };\n  }\n  /**\n   * Get the number of active WebSocket connections (should always be 0 or 1)\n   */\n  getConnectionCount() {\n    return this.connection.isReady() ? 1 : 0;\n  }\n  /**\n   * Get the number of active channels\n   */\n  getChannelCount() {\n    return this.connection.getChannelCount();\n  }\n};\n\n// src/notifications.ts\nvar BlinkNotificationsImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  /**\n   * Sends an email using the Blink Notifications API.\n   *\n   * @param params - An object containing the details for the email.\n   *   - `to`: The recipient's email address or an array of addresses.\n   *   - `subject`: The subject line of the email.\n   *   - `html`: The HTML body of the email. For best results across all email\n   *             clients (like Gmail, Outlook), use inline CSS and table-based layouts.\n   *   - `text`: A plain-text version of the email body (optional).\n   *   - `from`: A custom sender name (e.g., \"Acme Inc\"). The email address will\n   *             be auto-generated by the project (e.g., \"noreply@project.blink-email.com\").\n   *   - `replyTo`: An email address for recipients to reply to (optional).\n   *   - `cc`: A CC recipient's email address or an array of addresses (optional).\n   *   - `bcc`: A BCC recipient's email address or an array of addresses (optional).\n   *   - `attachments`: An array of objects for files to attach, each with a `url`.\n   *                    The file at the URL will be fetched and attached by the server.\n   *\n   * @example\n   * ```ts\n   * // Send a simple email\n   * const { success, messageId } = await blink.notifications.email({\n   *   to: 'customer@example.com',\n   *   subject: 'Your order has shipped!',\n   *   html: '<h1>Order Confirmation</h1><p>Your order #12345 is on its way.</p>'\n   * });\n   *\n   * // Send an email with attachments and a custom from name\n   * const { success } = await blink.notifications.email({\n   *   to: ['team@example.com', 'manager@example.com'],\n   *   subject: 'New Invoice',\n   *   from: 'Blink Invoicing',\n   *   html: '<p>Please find the invoice attached.</p>',\n   *   attachments: [\n   *     { url: 'https://example.com/invoice.pdf', filename: 'invoice.pdf' }\n   *   ]\n   * });\n   * ```\n   *\n   * @returns A promise that resolves with an object containing the status of the email send.\n   *   - `success`: A boolean indicating if the email was sent successfully.\n   *   - `messageId`: The unique ID of the message from the email provider.\n   */\n  async email(params) {\n    try {\n      if (!params.to || !params.subject || !params.html && !params.text) {\n        throw new BlinkNotificationsError('The \"to\", \"subject\", and either \"html\" or \"text\" fields are required.');\n      }\n      const response = await this.httpClient.post(`/api/notifications/${this.httpClient.projectId}/email`, params);\n      if (!response.data || typeof response.data.success !== \"boolean\") {\n        throw new BlinkNotificationsError(\"Invalid response from email API\");\n      }\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkNotificationsError) {\n        throw error;\n      }\n      const errorMessage = error.response?.data?.error?.message || error.message || \"An unknown error occurred\";\n      throw new BlinkNotificationsError(`Failed to send email: ${errorMessage}`, error.response?.status, error.response?.data?.error);\n    }\n  }\n};\n\n// src/analytics.ts\nvar SESSION_DURATION = 30 * 60 * 1e3;\nvar MAX_BATCH_SIZE = 10;\nvar BATCH_TIMEOUT = 3e3;\nvar MAX_STRING_LENGTH = 256;\nvar BlinkAnalyticsImpl = class {\n  httpClient;\n  projectId;\n  queue = [];\n  timer = null;\n  enabled = true;\n  userId = null;\n  userEmail = null;\n  hasTrackedPageview = false;\n  utmParams = {};\n  persistedAttribution = {};\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n    if (!isWeb) {\n      this.enabled = false;\n      return;\n    }\n    if (navigator.doNotTrack === \"1\") {\n      this.enabled = false;\n      return;\n    }\n    this.loadPersistedAttribution();\n    this.captureUTMParams();\n    this.loadQueue();\n    this.trackPageview();\n    this.setupRouteChangeListener();\n    this.setupUnloadListener();\n  }\n  /**\n   * Generate project-scoped storage key for analytics\n   */\n  getStorageKey(suffix) {\n    return `blinkAnalytics${suffix}_${this.projectId}`;\n  }\n  /**\n   * Log a custom analytics event\n   */\n  log(eventName, data = {}) {\n    if (!this.enabled || !isWeb) {\n      return;\n    }\n    const event = this.buildEvent(eventName, data);\n    this.enqueue(event);\n  }\n  /**\n   * Disable analytics tracking\n   */\n  disable() {\n    this.enabled = false;\n    this.clearTimer();\n  }\n  /**\n   * Cleanup analytics instance (remove from global tracking)\n   */\n  destroy() {\n    this.disable();\n    if (typeof window !== \"undefined\") {\n      window.__blinkAnalyticsInstances?.delete(this);\n    }\n  }\n  /**\n   * Enable analytics tracking\n   */\n  enable() {\n    this.enabled = true;\n  }\n  /**\n   * Check if analytics is enabled\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Set the user ID for analytics events\n   */\n  setUserId(userId) {\n    this.userId = userId;\n  }\n  /**\n   * Set the user email for analytics events\n   */\n  setUserEmail(email) {\n    this.userEmail = email;\n  }\n  /**\n   * Clear persisted attribution data\n   */\n  clearAttribution() {\n    this.persistedAttribution = {};\n    try {\n      localStorage.removeItem(this.getStorageKey(\"Attribution\"));\n    } catch {\n    }\n  }\n  // Private methods\n  buildEvent(type, data = {}) {\n    const sessionId = this.getOrCreateSessionId();\n    const channel = this.detectChannel();\n    return {\n      type,\n      timestamp: (/* @__PURE__ */ new Date()).toISOString(),\n      project_id: this.projectId,\n      user_id: this.userId,\n      user_email: this.userEmail,\n      session_id: sessionId,\n      pathname: getLocationPathname(),\n      referrer: getDocumentReferrer(),\n      screen_width: getWindowInnerWidth(),\n      channel,\n      utm_source: this.utmParams.utm_source || this.persistedAttribution.utm_source || null,\n      utm_medium: this.utmParams.utm_medium || this.persistedAttribution.utm_medium || null,\n      utm_campaign: this.utmParams.utm_campaign || this.persistedAttribution.utm_campaign || null,\n      utm_content: this.utmParams.utm_content || this.persistedAttribution.utm_content || null,\n      utm_term: this.utmParams.utm_term || this.persistedAttribution.utm_term || null,\n      ...this.sanitizeData(data)\n    };\n  }\n  sanitizeData(data) {\n    if (typeof data === \"string\") {\n      return data.length > MAX_STRING_LENGTH ? data.slice(0, MAX_STRING_LENGTH - 3) + \"...\" : data;\n    }\n    if (typeof data === \"object\" && data !== null) {\n      const result = {};\n      for (const key in data) {\n        result[key] = this.sanitizeData(data[key]);\n      }\n      return result;\n    }\n    return data;\n  }\n  enqueue(event) {\n    this.queue.push(event);\n    this.persistQueue();\n    if (this.queue.length >= MAX_BATCH_SIZE) {\n      this.flush();\n    } else if (!this.timer) {\n      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n    }\n  }\n  async flush() {\n    this.clearTimer();\n    if (this.queue.length === 0) {\n      return;\n    }\n    const events = this.queue.slice(0, MAX_BATCH_SIZE);\n    this.queue = this.queue.slice(MAX_BATCH_SIZE);\n    this.persistQueue();\n    try {\n      await this.httpClient.post(`/api/analytics/${this.projectId}/log`, { events });\n    } catch (error) {\n      this.queue = [...events, ...this.queue];\n      this.persistQueue();\n    }\n    if (this.queue.length > 0) {\n      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n    }\n  }\n  clearTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n  }\n  getOrCreateSessionId() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Session\"));\n      if (stored) {\n        const session = JSON.parse(stored);\n        const now = Date.now();\n        if (now - session.lastActivityAt > SESSION_DURATION) {\n          return this.createNewSession();\n        }\n        session.lastActivityAt = now;\n        localStorage.setItem(this.getStorageKey(\"Session\"), JSON.stringify(session));\n        return session.id;\n      }\n      return this.createNewSession();\n    } catch {\n      return null;\n    }\n  }\n  createNewSession() {\n    const now = Date.now();\n    const randomId = Math.random().toString(36).substring(2, 10);\n    const session = {\n      id: `sess_${now}_${randomId}`,\n      startedAt: now,\n      lastActivityAt: now\n    };\n    try {\n      localStorage.setItem(this.getStorageKey(\"Session\"), JSON.stringify(session));\n    } catch {\n    }\n    return session.id;\n  }\n  loadQueue() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Queue\"));\n      if (stored) {\n        this.queue = JSON.parse(stored);\n        if (this.queue.length > 0) {\n          this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n        }\n      }\n    } catch {\n      this.queue = [];\n    }\n  }\n  persistQueue() {\n    try {\n      if (this.queue.length === 0) {\n        localStorage.removeItem(this.getStorageKey(\"Queue\"));\n      } else {\n        localStorage.setItem(this.getStorageKey(\"Queue\"), JSON.stringify(this.queue));\n      }\n    } catch {\n    }\n  }\n  trackPageview() {\n    if (!this.hasTrackedPageview) {\n      this.log(\"pageview\");\n      this.hasTrackedPageview = true;\n    }\n  }\n  setupRouteChangeListener() {\n    if (!isWeb) return;\n    if (!window.__blinkAnalyticsSetup) {\n      const originalPushState = history.pushState;\n      const originalReplaceState = history.replaceState;\n      const analyticsInstances = /* @__PURE__ */ new Set();\n      window.__blinkAnalyticsInstances = analyticsInstances;\n      history.pushState = (...args) => {\n        originalPushState.apply(history, args);\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      };\n      history.replaceState = (...args) => {\n        originalReplaceState.apply(history, args);\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      };\n      window.addEventListener(\"popstate\", () => {\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      });\n      window.__blinkAnalyticsSetup = true;\n    }\n    window.__blinkAnalyticsInstances?.add(this);\n  }\n  setupUnloadListener() {\n    if (!isWeb || !hasWindow()) return;\n    window.addEventListener(\"pagehide\", () => {\n      this.flush();\n    });\n    window.addEventListener(\"unload\", () => {\n      this.flush();\n    });\n  }\n  captureUTMParams() {\n    if (!isWeb) return;\n    const search = getLocationSearch();\n    if (!search) {\n      this.utmParams = {};\n      return;\n    }\n    const urlParams = new URLSearchParams(search);\n    this.utmParams = {\n      utm_source: urlParams.get(\"utm_source\"),\n      utm_medium: urlParams.get(\"utm_medium\"),\n      utm_campaign: urlParams.get(\"utm_campaign\"),\n      utm_content: urlParams.get(\"utm_content\"),\n      utm_term: urlParams.get(\"utm_term\")\n    };\n    const hasNewParams = Object.values(this.utmParams).some((v) => v !== null);\n    if (hasNewParams) {\n      this.persistAttribution();\n    }\n  }\n  loadPersistedAttribution() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Attribution\"));\n      if (stored) {\n        this.persistedAttribution = JSON.parse(stored);\n      }\n    } catch {\n      this.persistedAttribution = {};\n    }\n  }\n  persistAttribution() {\n    try {\n      const attribution = {\n        ...this.persistedAttribution,\n        ...Object.fromEntries(\n          Object.entries(this.utmParams).filter(([_, v]) => v !== null)\n        )\n      };\n      localStorage.setItem(this.getStorageKey(\"Attribution\"), JSON.stringify(attribution));\n      this.persistedAttribution = attribution;\n    } catch {\n    }\n  }\n  detectChannel() {\n    const referrer = getDocumentReferrer();\n    const utmMedium = this.utmParams.utm_medium;\n    this.utmParams.utm_source;\n    if (utmMedium) {\n      if (utmMedium === \"cpc\" || utmMedium === \"ppc\") return \"Paid Search\";\n      if (utmMedium === \"email\") return \"Email\";\n      if (utmMedium === \"social\") return \"Social\";\n      if (utmMedium === \"referral\") return \"Referral\";\n      if (utmMedium === \"display\") return \"Display\";\n      if (utmMedium === \"affiliate\") return \"Affiliate\";\n    }\n    if (!referrer) return \"Direct\";\n    try {\n      const referrerUrl = new URL(referrer);\n      const referrerDomain = referrerUrl.hostname.toLowerCase();\n      if (/google\\.|bing\\.|yahoo\\.|duckduckgo\\.|baidu\\.|yandex\\./.test(referrerDomain)) {\n        return \"Organic Search\";\n      }\n      if (/facebook\\.|twitter\\.|linkedin\\.|instagram\\.|youtube\\.|tiktok\\.|reddit\\./.test(referrerDomain)) {\n        return \"Social\";\n      }\n      if (/mail\\.|outlook\\.|gmail\\./.test(referrerDomain)) {\n        return \"Email\";\n      }\n      return \"Referral\";\n    } catch {\n      return \"Direct\";\n    }\n  }\n};\n\n// src/connectors.ts\nvar BlinkConnectorsImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  async status(provider, options) {\n    const response = await this.httpClient.connectorStatus(provider);\n    return response.data;\n  }\n  async execute(provider, request) {\n    const response = await this.httpClient.connectorExecute(provider, request);\n    return response.data;\n  }\n  async saveApiKey(provider, request) {\n    const response = await this.httpClient.connectorSaveApiKey(provider, request);\n    return response.data;\n  }\n};\n\n// src/functions.ts\nvar BlinkFunctionsImpl = class {\n  httpClient;\n  projectId;\n  constructor(httpClient, projectId, _getToken) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  /**\n   * Get the project suffix from the full project ID.\n   * Project IDs are formatted as: prj_xxxxx\n   * The suffix is the last 8 characters used in function URLs.\n   */\n  getProjectSuffix() {\n    return this.projectId.slice(-8);\n  }\n  /**\n   * Build the full function URL\n   */\n  buildFunctionUrl(functionSlug, searchParams) {\n    const suffix = this.getProjectSuffix();\n    const baseUrl = `https://${suffix}--${functionSlug}.functions.blink.new`;\n    if (!searchParams || Object.keys(searchParams).length === 0) {\n      return baseUrl;\n    }\n    const url = new URL(baseUrl);\n    Object.entries(searchParams).forEach(([key, value]) => {\n      url.searchParams.set(key, value);\n    });\n    return url.toString();\n  }\n  async invoke(functionSlug, options = {}) {\n    const { method = \"POST\", body, headers = {}, searchParams } = options;\n    const url = this.buildFunctionUrl(functionSlug, searchParams);\n    const res = await this.httpClient.request(url, { method, body, headers });\n    return { data: res.data, status: res.status, headers: res.headers };\n  }\n};\n\n// src/rag.ts\nfunction removeUndefined(obj) {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, v]) => v !== void 0)\n  );\n}\nfunction convertCollection(api) {\n  return {\n    id: api.id,\n    name: api.name,\n    description: api.description,\n    embeddingModel: api.embedding_model,\n    embeddingDimensions: api.embedding_dimensions,\n    indexMetric: api.index_metric,\n    chunkMaxTokens: api.chunk_max_tokens,\n    chunkOverlapTokens: api.chunk_overlap_tokens,\n    documentCount: api.document_count,\n    chunkCount: api.chunk_count,\n    shared: api.shared,\n    createdAt: api.created_at,\n    updatedAt: api.updated_at\n  };\n}\nfunction convertDocument(api) {\n  return {\n    id: api.id,\n    collectionId: api.collection_id,\n    filename: api.filename,\n    sourceType: api.source_type,\n    sourceUrl: api.source_url,\n    contentType: api.content_type,\n    fileSize: api.file_size,\n    status: api.status,\n    errorMessage: api.error_message,\n    processingStartedAt: api.processing_started_at,\n    processingCompletedAt: api.processing_completed_at,\n    chunkCount: api.chunk_count,\n    tokenCount: api.token_count,\n    metadata: api.metadata,\n    createdAt: api.created_at,\n    updatedAt: api.updated_at\n  };\n}\nfunction convertPartialDocument(api, options) {\n  let sourceType = \"text\";\n  if (options.url) sourceType = \"url\";\n  if (options.file) sourceType = \"file\";\n  return {\n    id: api.id || \"\",\n    collectionId: api.collection_id || options.collectionId || \"\",\n    filename: api.filename || options.filename,\n    sourceType: api.source_type || sourceType,\n    sourceUrl: api.source_url ?? options.url ?? null,\n    contentType: api.content_type ?? options.file?.contentType ?? null,\n    fileSize: api.file_size ?? null,\n    status: api.status || \"pending\",\n    errorMessage: api.error_message ?? null,\n    processingStartedAt: api.processing_started_at ?? null,\n    processingCompletedAt: api.processing_completed_at ?? null,\n    chunkCount: api.chunk_count ?? 0,\n    tokenCount: api.token_count ?? null,\n    metadata: api.metadata || options.metadata || {},\n    createdAt: api.created_at || (/* @__PURE__ */ new Date()).toISOString(),\n    updatedAt: api.updated_at || api.created_at || (/* @__PURE__ */ new Date()).toISOString()\n  };\n}\nfunction convertSearchResult(api) {\n  return {\n    chunkId: api.chunk_id,\n    documentId: api.document_id,\n    filename: api.filename,\n    content: api.content,\n    score: api.score,\n    chunkIndex: api.chunk_index,\n    metadata: api.metadata\n  };\n}\nfunction convertSearchResponse(api) {\n  return {\n    results: api.results.map(convertSearchResult),\n    query: api.query,\n    collectionId: api.collection_id,\n    totalResults: api.total_results\n  };\n}\nfunction convertAISearchSource(api) {\n  return {\n    documentId: api.document_id,\n    filename: api.filename,\n    chunkId: api.chunk_id,\n    excerpt: api.excerpt,\n    score: api.score\n  };\n}\nfunction convertAISearchResult(api) {\n  return {\n    answer: api.answer,\n    sources: api.sources.map(convertAISearchSource),\n    query: api.query,\n    model: api.model,\n    usage: {\n      inputTokens: api.usage.input_tokens,\n      outputTokens: api.usage.output_tokens\n    }\n  };\n}\nvar BlinkRAGImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    this.projectId = httpClient.projectId;\n  }\n  projectId;\n  /**\n   * Build URL with project_id prefix\n   */\n  url(path) {\n    return `/api/rag/${this.projectId}${path}`;\n  }\n  // ============================================================================\n  // Collections\n  // ============================================================================\n  /**\n   * Create a new RAG collection\n   */\n  async createCollection(options) {\n    const body = removeUndefined({\n      name: options.name,\n      description: options.description,\n      embedding_model: options.embeddingModel,\n      embedding_dimensions: options.embeddingDimensions,\n      index_metric: options.indexMetric,\n      chunk_max_tokens: options.chunkMaxTokens,\n      chunk_overlap_tokens: options.chunkOverlapTokens,\n      shared: options.shared\n    });\n    const response = await this.httpClient.post(this.url(\"/collections\"), body);\n    return convertCollection(response.data);\n  }\n  /**\n   * List all collections accessible to the current user\n   */\n  async listCollections() {\n    const response = await this.httpClient.get(this.url(\"/collections\"));\n    return response.data.collections.map(convertCollection);\n  }\n  /**\n   * Get a specific collection by ID\n   */\n  async getCollection(collectionId) {\n    const response = await this.httpClient.get(this.url(`/collections/${collectionId}`));\n    return convertCollection(response.data);\n  }\n  /**\n   * Delete a collection and all its documents\n   */\n  async deleteCollection(collectionId) {\n    await this.httpClient.delete(this.url(`/collections/${collectionId}`));\n  }\n  // ============================================================================\n  // Documents\n  // ============================================================================\n  /**\n   * Upload a document for processing\n   * \n   * @example\n   * // Upload text content\n   * const doc = await blink.rag.upload({\n   *   collectionName: 'docs',\n   *   filename: 'notes.txt',\n   *   content: 'My document content...'\n   * })\n   * \n   * @example\n   * // Upload from URL\n   * const doc = await blink.rag.upload({\n   *   collectionId: 'col_abc123',\n   *   filename: 'article.html',\n   *   url: 'https://example.com/article'\n   * })\n   * \n   * @example\n   * // Upload a file (base64)\n   * const doc = await blink.rag.upload({\n   *   collectionName: 'docs',\n   *   filename: 'report.pdf',\n   *   file: { data: base64Data, contentType: 'application/pdf' }\n   * })\n   */\n  async upload(options) {\n    if (!options.collectionId && !options.collectionName) {\n      throw new Error(\"collectionId or collectionName is required\");\n    }\n    const body = removeUndefined({\n      collection_id: options.collectionId,\n      collection_name: options.collectionName,\n      filename: options.filename,\n      content: options.content,\n      url: options.url,\n      metadata: options.metadata\n    });\n    if (options.file) {\n      body.file = {\n        data: options.file.data,\n        content_type: options.file.contentType\n      };\n    }\n    const response = await this.httpClient.post(this.url(\"/documents\"), body);\n    return convertPartialDocument(response.data, options);\n  }\n  /**\n   * Get document status and metadata\n   */\n  async getDocument(documentId) {\n    const response = await this.httpClient.get(this.url(`/documents/${documentId}`));\n    return convertDocument(response.data);\n  }\n  /**\n   * List documents, optionally filtered by collection or status\n   */\n  async listDocuments(options) {\n    const params = {};\n    if (options?.collectionId) params.collection_id = options.collectionId;\n    if (options?.status) params.status = options.status;\n    const queryString = Object.keys(params).length > 0 ? `?${new URLSearchParams(params).toString()}` : \"\";\n    const response = await this.httpClient.get(\n      this.url(`/documents${queryString}`)\n    );\n    return response.data.documents.map(convertDocument);\n  }\n  /**\n   * Delete a document and its chunks\n   */\n  async deleteDocument(documentId) {\n    await this.httpClient.delete(this.url(`/documents/${documentId}`));\n  }\n  /**\n   * Wait for a document to finish processing\n   * \n   * @example\n   * const doc = await blink.rag.upload({ ... })\n   * const readyDoc = await blink.rag.waitForReady(doc.id)\n   * console.log(`Processed ${readyDoc.chunkCount} chunks`)\n   */\n  async waitForReady(documentId, options) {\n    const { timeoutMs = 12e4, pollIntervalMs = 2e3 } = options || {};\n    const start = Date.now();\n    while (Date.now() - start < timeoutMs) {\n      const doc = await this.getDocument(documentId);\n      if (doc.status === \"ready\") {\n        return doc;\n      }\n      if (doc.status === \"error\") {\n        throw new Error(`Document processing failed: ${doc.errorMessage}`);\n      }\n      await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\n    }\n    throw new Error(`Document processing timeout after ${timeoutMs}ms`);\n  }\n  // ============================================================================\n  // Search\n  // ============================================================================\n  /**\n   * Search for similar chunks using vector similarity\n   * \n   * @example\n   * const results = await blink.rag.search({\n   *   collectionName: 'docs',\n   *   query: 'How do I configure authentication?',\n   *   maxResults: 5\n   * })\n   */\n  async search(options) {\n    if (!options.collectionId && !options.collectionName) {\n      throw new Error(\"collectionId or collectionName is required\");\n    }\n    const body = removeUndefined({\n      collection_id: options.collectionId,\n      collection_name: options.collectionName,\n      query: options.query,\n      max_results: options.maxResults,\n      score_threshold: options.scoreThreshold,\n      filters: options.filters,\n      include_content: options.includeContent\n    });\n    const response = await this.httpClient.post(this.url(\"/search\"), body);\n    return convertSearchResponse(response.data);\n  }\n  async aiSearch(options) {\n    if (!options.collectionId && !options.collectionName) {\n      throw new Error(\"collectionId or collectionName is required\");\n    }\n    const body = removeUndefined({\n      collection_id: options.collectionId,\n      collection_name: options.collectionName,\n      query: options.query,\n      model: options.model,\n      max_context_chunks: options.maxContextChunks,\n      score_threshold: options.scoreThreshold,\n      system_prompt: options.systemPrompt,\n      stream: options.stream\n    });\n    if (options.stream) {\n      const response2 = await this.httpClient.ragAiSearchStream(body, options.signal);\n      return response2.body;\n    }\n    const response = await this.httpClient.post(this.url(\"/ai-search\"), body);\n    return convertAISearchResult(response.data);\n  }\n};\n\n// src/sandbox.ts\nvar SANDBOX_TEMPLATES = [\n  \"devtools-base\",\n  // Node 22 + Bun + Python + Git + ripgrep (DEFAULT)\n  \"nextjs-app\",\n  // Next.js + Tailwind + shadcn UI (Node)\n  \"nextjs-app-bun\",\n  // Next.js + Tailwind + shadcn UI (Bun)\n  \"vite-react\",\n  // Vite + React + Tailwind + shadcn (Node)\n  \"vite-react-bun\",\n  // Vite + React + Tailwind + shadcn (Bun)\n  \"expo-app\",\n  // Expo + React Native\n  \"desktop\",\n  // Electron + Vite + React\n  \"claude-code\"\n  // Node 21 + Python + Git + ripgrep\n];\nvar SandboxConnectionError = class extends Error {\n  sandboxId;\n  constructor(sandboxId, cause) {\n    super(`Failed to connect to sandbox ${sandboxId}`);\n    this.name = \"SandboxConnectionError\";\n    this.sandboxId = sandboxId;\n    if (cause) {\n      this.cause = cause;\n    }\n  }\n};\nvar SandboxImpl = class {\n  constructor(id, template, hostPattern) {\n    this.id = id;\n    this.template = template;\n    this.hostPattern = hostPattern;\n  }\n  getHost(port) {\n    return this.hostPattern.replace(\"{port}\", String(port));\n  }\n};\nvar MAX_RETRIES = 3;\nvar INITIAL_RETRY_DELAY_MS = 250;\nvar BlinkSandboxImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    this.projectId = httpClient.projectId;\n  }\n  projectId;\n  /**\n   * Build URL with project_id prefix\n   */\n  url(path) {\n    return `/api/sandbox/${this.projectId}${path}`;\n  }\n  async create(options = {}) {\n    const body = {\n      template: options.template,\n      timeout_ms: options.timeoutMs,\n      metadata: options.metadata,\n      secrets: options.secrets\n    };\n    const response = await this.httpClient.post(this.url(\"/create\"), body);\n    const { id, template, host_pattern } = response.data;\n    return new SandboxImpl(id, template, host_pattern);\n  }\n  async connect(sandboxId, options = {}) {\n    let lastError;\n    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n      try {\n        const body = {\n          sandbox_id: sandboxId,\n          timeout_ms: options.timeoutMs\n        };\n        const response = await this.httpClient.post(this.url(\"/connect\"), body);\n        const { id, template, host_pattern } = response.data;\n        return new SandboxImpl(id, template, host_pattern);\n      } catch (error) {\n        console.error(`[Sandbox] Connect attempt ${attempt + 1} failed:`, error);\n        lastError = error instanceof Error ? error : new Error(String(error));\n        if (lastError.message.includes(\"404\") || lastError.message.includes(\"not found\") || lastError.message.includes(\"unauthorized\")) {\n          throw new SandboxConnectionError(sandboxId, lastError);\n        }\n        if (attempt < MAX_RETRIES - 1) {\n          const delay = INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n    console.error(`[Sandbox] All ${MAX_RETRIES} connection attempts failed for sandbox ${sandboxId}`);\n    throw new SandboxConnectionError(sandboxId, lastError);\n  }\n  async kill(sandboxId) {\n    await this.httpClient.post(this.url(\"/kill\"), { sandbox_id: sandboxId });\n  }\n};\n\n// src/client.ts\nvar defaultClient = null;\nfunction getDefaultClient() {\n  if (!defaultClient) {\n    throw new Error(\n      \"No Blink client initialized. Call createClient() first before using Agent or other SDK features.\"\n    );\n  }\n  return defaultClient;\n}\nfunction _getDefaultHttpClient() {\n  return getDefaultClient()._httpClient;\n}\nvar BlinkClientImpl = class {\n  auth;\n  db;\n  storage;\n  ai;\n  data;\n  realtime;\n  notifications;\n  analytics;\n  connectors;\n  functions;\n  rag;\n  sandbox;\n  /** @internal HTTP client for Agent auto-binding */\n  _httpClient;\n  constructor(config) {\n    if ((config.secretKey || config.serviceToken) && isBrowser) {\n      throw new Error(\"secretKey/serviceToken is server-only. Do not provide it in browser/React Native clients.\");\n    }\n    this.auth = new BlinkAuth(config);\n    this._httpClient = new HttpClient(\n      config,\n      () => this.auth.getToken(),\n      () => this.auth.getValidToken()\n    );\n    this.db = new BlinkDatabase(this._httpClient);\n    this.storage = new BlinkStorageImpl(this._httpClient);\n    this.ai = new BlinkAIImpl(this._httpClient);\n    this.data = new BlinkDataImpl(this._httpClient, config.projectId);\n    this.realtime = new BlinkRealtimeImpl(this._httpClient, config.projectId);\n    this.notifications = new BlinkNotificationsImpl(this._httpClient);\n    this.analytics = new BlinkAnalyticsImpl(this._httpClient, config.projectId);\n    this.connectors = new BlinkConnectorsImpl(this._httpClient);\n    this.functions = new BlinkFunctionsImpl(\n      this._httpClient,\n      config.projectId,\n      () => this.auth.getValidToken()\n    );\n    this.rag = new BlinkRAGImpl(this._httpClient);\n    this.sandbox = new BlinkSandboxImpl(this._httpClient);\n    this.auth.onAuthStateChanged((state) => {\n      if (state.isAuthenticated && state.user) {\n        this.analytics.setUserId(state.user.id);\n        this.analytics.setUserEmail(state.user.email);\n      } else {\n        this.analytics.setUserId(null);\n        this.analytics.setUserEmail(null);\n      }\n    });\n  }\n};\nfunction createClient(config) {\n  if (!config.projectId) {\n    throw new Error(\"projectId is required\");\n  }\n  const client = new BlinkClientImpl(config);\n  defaultClient = client;\n  return client;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmxpbmtkb3RuZXcvc2RrL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLG9CQUFvQixPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTLElBQUksS0FBSyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxHQUFHLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFD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QXFCO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQXlEO0FBQzVGO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0dBQWdHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbURBQW1ELDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVEsY0FBYyxlQUFlO0FBQzlELHdCQUF3QixPQUFPLDBCQUEwQixNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTyxvQ0FBb0MsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU8seUNBQXlDLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE1BQU07QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLGdGQUFnRix5REFBeUQ7QUFDekk7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwwQkFBMEI7QUFDN0U7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHVCQUF1QjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2REFBNkQsdUJBQXVCO0FBQ3BGO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPLCtCQUErQix3QkFBd0IsS0FBSyxrQkFBa0I7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQixPQUFPLGdCQUFnQixvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOENBQThDLGlCQUFpQixJQUFJLHlEQUF5RDtBQUM1SDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOENBQThDLGlCQUFpQixJQUFJLHlEQUF5RDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSwwQkFBMEI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBYTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPLEdBQUcsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWUsU0FBUyxRQUFRO0FBQ25GLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxHQUFHLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxJQUFJLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsWUFBWSxtQ0FBbUMsaUJBQWlCO0FBQ2hFO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZSxFQUFFLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FB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QUFFczJCO0FBQ3QyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmxpbmtkb3RuZXcvc2RrL2Rpc3QvaW5kZXgubWpzPzE1ZmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVxdWlyZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHgpID0+IHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBQcm94eSh4LCB7XG4gIGdldDogKGEsIGIpID0+ICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiBhKVtiXVxufSkgOiB4KShmdW5jdGlvbih4KSB7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHJlcXVpcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhyb3cgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicgKyB4ICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn0pO1xuXG4vLyAuLi9jb3JlL3NyYy9wbGF0Zm9ybS50c1xuZnVuY3Rpb24gZGV0ZWN0UGxhdGZvcm0oKSB7XG4gIGlmICh0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcImRlbm9cIjtcbiAgfVxuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy52ZXJzaW9ucz8ubm9kZSkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCIpIHtcbiAgICAgIHJldHVybiBcInJlYWN0LW5hdGl2ZVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub2RlXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIikge1xuICAgIHJldHVybiBcInJlYWN0LW5hdGl2ZVwiO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcIndlYlwiO1xuICB9XG4gIHJldHVybiBcIm5vZGVcIjtcbn1cbnZhciBwbGF0Zm9ybSA9IGRldGVjdFBsYXRmb3JtKCk7XG52YXIgaXNXZWIgPSBwbGF0Zm9ybSA9PT0gXCJ3ZWJcIjtcbnZhciBpc1JlYWN0TmF0aXZlID0gcGxhdGZvcm0gPT09IFwicmVhY3QtbmF0aXZlXCI7XG52YXIgaXNOb2RlID0gcGxhdGZvcm0gPT09IFwibm9kZVwiO1xudmFyIGlzRGVubyA9IHBsYXRmb3JtID09PSBcImRlbm9cIjtcbnZhciBpc0Jyb3dzZXIgPSBpc1dlYiB8fCBpc1JlYWN0TmF0aXZlO1xudmFyIGlzU2VydmVyID0gaXNOb2RlIHx8IGlzRGVubztcblxuLy8gLi4vY29yZS9zcmMvc3RvcmFnZS1hZGFwdGVyLnRzXG52YXIgV2ViU3RvcmFnZUFkYXB0ZXIgPSBjbGFzcyB7XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZ2V0IGl0ZW0gZnJvbSBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc2V0IGl0ZW0gaW4gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcmVtb3ZlIGl0ZW0gZnJvbSBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNsZWFyIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcbnZhciBBc3luY1N0b3JhZ2VBZGFwdGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihhc3luY1N0b3JhZ2UpIHtcbiAgICB0aGlzLmFzeW5jU3RvcmFnZSA9IGFzeW5jU3RvcmFnZTtcbiAgICBpZiAoIWFzeW5jU3RvcmFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmNTdG9yYWdlIGluc3RhbmNlIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRJdGVtKGtleSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5hc3luY1N0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZ2V0IGl0ZW0gZnJvbSBBc3luY1N0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5hc3luY1N0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNldCBpdGVtIGluIEFzeW5jU3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyByZW1vdmVJdGVtKGtleSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFzeW5jU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byByZW1vdmUgaXRlbSBmcm9tIEFzeW5jU3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjbGVhcigpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5hc3luY1N0b3JhZ2UuY2xlYXIoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNsZWFyIEFzeW5jU3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcbnZhciBOb09wU3RvcmFnZUFkYXB0ZXIgPSBjbGFzcyB7XG4gIGdldEl0ZW0oX2tleSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldEl0ZW0oX2tleSwgX3ZhbHVlKSB7XG4gIH1cbiAgcmVtb3ZlSXRlbShfa2V5KSB7XG4gIH1cbiAgY2xlYXIoKSB7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0U3RvcmFnZUFkYXB0ZXIoKSB7XG4gIGlmIChpc0Rlbm8pIHtcbiAgICByZXR1cm4gbmV3IE5vT3BTdG9yYWdlQWRhcHRlcigpO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJfX3Rlc3RfX1wiLCBcInRlc3RcIik7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcIl9fdGVzdF9fXCIpO1xuICAgICAgcmV0dXJuIG5ldyBXZWJTdG9yYWdlQWRhcHRlcigpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IE5vT3BTdG9yYWdlQWRhcHRlcigpO1xufVxuXG4vLyAuLi9jb3JlL3NyYy90eXBlcy50c1xudmFyIEJsaW5rRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIHRoaXMubmFtZSA9IFwiQmxpbmtFcnJvclwiO1xuICB9XG59O1xudmFyIEJsaW5rQXV0aEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbGlua0Vycm9yIHtcbiAgY29kZTtcbiAgcmV0cnlhYmxlO1xuICB1c2VyTWVzc2FnZTtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgdXNlck1lc3NhZ2UsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjb2RlLCA0MDEsIGRldGFpbHMpO1xuICAgIHRoaXMubmFtZSA9IFwiQmxpbmtBdXRoRXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMucmV0cnlhYmxlID0gW1wiTkVUV09SS19FUlJPUlwiLCBcIlJBVEVfTElNSVRFRFwiXS5pbmNsdWRlcyhjb2RlKTtcbiAgICB0aGlzLnVzZXJNZXNzYWdlID0gdXNlck1lc3NhZ2UgfHwgdGhpcy5nZXREZWZhdWx0VXNlck1lc3NhZ2UoY29kZSk7XG4gIH1cbiAgZ2V0RGVmYXVsdFVzZXJNZXNzYWdlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLzpcbiAgICAgICAgcmV0dXJuIFwiSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcbiAgICAgIGNhc2UgXCJFTUFJTF9OT1RfVkVSSUZJRURcIiAvKiBFTUFJTF9OT1RfVkVSSUZJRUQgKi86XG4gICAgICAgIHJldHVybiBcIlBsZWFzZSB2ZXJpZnkgeW91ciBlbWFpbCBhZGRyZXNzIGJlZm9yZSBzaWduaW5nIGluLlwiO1xuICAgICAgY2FzZSBcIlBPUFVQX0NBTkNFTEVEXCIgLyogUE9QVVBfQ0FOQ0VMRUQgKi86XG4gICAgICAgIHJldHVybiBcIlNpZ24taW4gd2FzIGNhbmNlbGVkLiBQbGVhc2UgdHJ5IGFnYWluLlwiO1xuICAgICAgY2FzZSBcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovOlxuICAgICAgICByZXR1cm4gXCJOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW4uXCI7XG4gICAgICBjYXNlIFwiUkFURV9MSU1JVEVEXCIgLyogUkFURV9MSU1JVEVEICovOlxuICAgICAgICByZXR1cm4gXCJUb28gbWFueSBhdHRlbXB0cy4gUGxlYXNlIHdhaXQgYSBtb21lbnQgYW5kIHRyeSBhZ2Fpbi5cIjtcbiAgICAgIGNhc2UgXCJBVVRIX1RJTUVPVVRcIiAvKiBBVVRIX1RJTUVPVVQgKi86XG4gICAgICAgIHJldHVybiBcIkF1dGhlbnRpY2F0aW9uIHRpbWVkIG91dC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcbiAgICAgIGNhc2UgXCJSRURJUkVDVF9GQUlMRURcIiAvKiBSRURJUkVDVF9GQUlMRUQgKi86XG4gICAgICAgIHJldHVybiBcIlJlZGlyZWN0IGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcbiAgICAgIGNhc2UgXCJUT0tFTl9FWFBJUkVEXCIgLyogVE9LRU5fRVhQSVJFRCAqLzpcbiAgICAgICAgcmV0dXJuIFwiU2Vzc2lvbiBleHBpcmVkLiBQbGVhc2Ugc2lnbiBpbiBhZ2Fpbi5cIjtcbiAgICAgIGNhc2UgXCJVU0VSX05PVF9GT1VORFwiIC8qIFVTRVJfTk9UX0ZPVU5EICovOlxuICAgICAgICByZXR1cm4gXCJVc2VyIG5vdCBmb3VuZC4gUGxlYXNlIGNoZWNrIHlvdXIgZW1haWwgYW5kIHRyeSBhZ2Fpbi5cIjtcbiAgICAgIGNhc2UgXCJFTUFJTF9BTFJFQURZX0VYSVNUU1wiIC8qIEVNQUlMX0FMUkVBRFlfRVhJU1RTICovOlxuICAgICAgICByZXR1cm4gXCJBbiBhY2NvdW50IHdpdGggdGhpcyBlbWFpbCBhbHJlYWR5IGV4aXN0cy5cIjtcbiAgICAgIGNhc2UgXCJXRUFLX1BBU1NXT1JEXCIgLyogV0VBS19QQVNTV09SRCAqLzpcbiAgICAgICAgcmV0dXJuIFwiUGFzc3dvcmQgaXMgdG9vIHdlYWsuIFBsZWFzZSBjaG9vc2UgYSBzdHJvbmdlciBwYXNzd29yZC5cIjtcbiAgICAgIGNhc2UgXCJJTlZBTElEX0VNQUlMXCIgLyogSU5WQUxJRF9FTUFJTCAqLzpcbiAgICAgICAgcmV0dXJuIFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cIjtcbiAgICAgIGNhc2UgXCJNQUdJQ19MSU5LX0VYUElSRURcIiAvKiBNQUdJQ19MSU5LX0VYUElSRUQgKi86XG4gICAgICAgIHJldHVybiBcIk1hZ2ljIGxpbmsgaGFzIGV4cGlyZWQuIFBsZWFzZSByZXF1ZXN0IGEgbmV3IG9uZS5cIjtcbiAgICAgIGNhc2UgXCJWRVJJRklDQVRJT05fRkFJTEVEXCIgLyogVkVSSUZJQ0FUSU9OX0ZBSUxFRCAqLzpcbiAgICAgICAgcmV0dXJuIFwiVmVyaWZpY2F0aW9uIGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIkF1dGhlbnRpY2F0aW9uIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluLlwiO1xuICAgIH1cbiAgfVxufTtcbnZhciBCbGlua05ldHdvcmtFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxpbmtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIFwiTkVUV09SS19FUlJPUlwiLCBzdGF0dXMsIGRldGFpbHMpO1xuICAgIHRoaXMubmFtZSA9IFwiQmxpbmtOZXR3b3JrRXJyb3JcIjtcbiAgfVxufTtcbnZhciBCbGlua1ZhbGlkYXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxpbmtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBcIlZBTElEQVRJT05fRVJST1JcIiwgNDAwLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rVmFsaWRhdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgQmxpbmtTdG9yYWdlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsaW5rRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBcIlNUT1JBR0VfRVJST1JcIiwgc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rU3RvcmFnZUVycm9yXCI7XG4gIH1cbn07XG52YXIgQmxpbmtBSUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbGlua0Vycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJBSV9FUlJPUlwiLCBzdGF0dXMsIGRldGFpbHMpO1xuICAgIHRoaXMubmFtZSA9IFwiQmxpbmtBSUVycm9yXCI7XG4gIH1cbn07XG52YXIgQmxpbmtEYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsaW5rRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBcIkRBVEFfRVJST1JcIiwgc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rRGF0YUVycm9yXCI7XG4gIH1cbn07XG52YXIgQmxpbmtSZWFsdGltZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbGlua0Vycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJSRUFMVElNRV9FUlJPUlwiLCBzdGF0dXMsIGRldGFpbHMpO1xuICAgIHRoaXMubmFtZSA9IFwiQmxpbmtSZWFsdGltZUVycm9yXCI7XG4gIH1cbn07XG52YXIgQmxpbmtOb3RpZmljYXRpb25zRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsaW5rRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBcIk5PVElGSUNBVElPTlNfRVJST1JcIiwgc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rTm90aWZpY2F0aW9uc0Vycm9yXCI7XG4gIH1cbn07XG5cbi8vIC4uL2NvcmUvc3JjL3F1ZXJ5LWJ1aWxkZXIudHNcbmZ1bmN0aW9uIGNhbWVsVG9TbmFrZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bQS1aXS9nLCAobGV0dGVyKSA9PiBgXyR7bGV0dGVyLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RmlsdGVyS2V5c1RvU25ha2VDYXNlKGNvbmRpdGlvbikge1xuICBpZiAoIWNvbmRpdGlvbikgcmV0dXJuIGNvbmRpdGlvbjtcbiAgaWYgKFwiQU5EXCIgaW4gY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEFORDogY29uZGl0aW9uLkFORD8ubWFwKGNvbnZlcnRGaWx0ZXJLZXlzVG9TbmFrZUNhc2UpXG4gICAgfTtcbiAgfVxuICBpZiAoXCJPUlwiIGluIGNvbmRpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBPUjogY29uZGl0aW9uLk9SPy5tYXAoY29udmVydEZpbHRlcktleXNUb1NuYWtlQ2FzZSlcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNvbnZlcnRlZCA9IHt9O1xuICBmb3IgKGNvbnN0IFtmaWVsZCwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNvbmRpdGlvbikpIHtcbiAgICBjb25zdCBzbmFrZUZpZWxkID0gY2FtZWxUb1NuYWtlKGZpZWxkKTtcbiAgICBjb252ZXJ0ZWRbc25ha2VGaWVsZF0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkO1xufVxuZnVuY3Rpb24gYnVpbGRGaWx0ZXJRdWVyeShjb25kaXRpb24pIHtcbiAgaWYgKCFjb25kaXRpb24pIHJldHVybiBcIlwiO1xuICBpZiAoXCJBTkRcIiBpbiBjb25kaXRpb24pIHtcbiAgICBjb25zdCBhbmRDb25kaXRpb25zID0gY29uZGl0aW9uLkFORD8ubWFwKGJ1aWxkRmlsdGVyUXVlcnkpLmZpbHRlcihCb29sZWFuKSB8fCBbXTtcbiAgICByZXR1cm4gYW5kQ29uZGl0aW9ucy5sZW5ndGggPiAwID8gYGFuZD0oJHthbmRDb25kaXRpb25zLmpvaW4oXCIsXCIpfSlgIDogXCJcIjtcbiAgfVxuICBpZiAoXCJPUlwiIGluIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IG9yQ29uZGl0aW9ucyA9IGNvbmRpdGlvbi5PUj8ubWFwKGJ1aWxkRmlsdGVyUXVlcnkpLmZpbHRlcihCb29sZWFuKSB8fCBbXTtcbiAgICByZXR1cm4gb3JDb25kaXRpb25zLmxlbmd0aCA+IDAgPyBgb3I9KCR7b3JDb25kaXRpb25zLmpvaW4oXCIsXCIpfSlgIDogXCJcIjtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgZm9yIChjb25zdCBbZmllbGQsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb25kaXRpb24pKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IFtvcGVyYXRvciwgb3BlcmF0b3JWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gYnVpbGRPcGVyYXRvclF1ZXJ5KGZpZWxkLCBvcGVyYXRvciwgb3BlcmF0b3JWYWx1ZSk7XG4gICAgICAgIGlmIChwYXJhbSkgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMucHVzaChgJHtmaWVsZH09ZXEuJHtlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcy5qb2luKFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkT3BlcmF0b3JRdWVyeShmaWVsZCwgb3BlcmF0b3IsIHZhbHVlKSB7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlIFwiZXFcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09ZXEuJHtlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKX1gO1xuICAgIGNhc2UgXCJuZXFcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09bmVxLiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwiZ3RcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09Z3QuJHtlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKX1gO1xuICAgIGNhc2UgXCJndGVcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09Z3RlLiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwibHRcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09bHQuJHtlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKX1gO1xuICAgIGNhc2UgXCJsdGVcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09bHRlLiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwibGlrZVwiOlxuICAgICAgcmV0dXJuIGAke2ZpZWxkfT1saWtlLiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwiaWxpa2VcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09aWxpa2UuJHtlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKX1gO1xuICAgIGNhc2UgXCJpc1wiOlxuICAgICAgcmV0dXJuIGAke2ZpZWxkfT1pcy4ke3ZhbHVlID09PSBudWxsID8gXCJudWxsXCIgOiBlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKX1gO1xuICAgIGNhc2UgXCJub3RcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09bm90LiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwiaW5cIjpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5tYXAoZW5jb2RlUXVlcnlWYWx1ZSkuam9pbihcIixcIik7XG4gICAgICAgIHJldHVybiBgJHtmaWVsZH09aW4uKCR7dmFsdWVzfSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY2FzZSBcIm5vdF9pblwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlLm1hcChlbmNvZGVRdWVyeVZhbHVlKS5qb2luKFwiLFwiKTtcbiAgICAgICAgcmV0dXJuIGAke2ZpZWxkfT1ub3QuaW4uKCR7dmFsdWVzfSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIFwibnVsbFwiO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZSA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBidWlsZFF1ZXJ5KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuc2VsZWN0ICYmIG9wdGlvbnMuc2VsZWN0Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzbmFrZUZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0Lm1hcChjYW1lbFRvU25ha2UpO1xuICAgIHBhcmFtcy5zZWxlY3QgPSBzbmFrZUZpZWxkcy5qb2luKFwiLFwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMuc2VsZWN0ID0gXCIqXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMud2hlcmUpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWRXaGVyZSA9IGNvbnZlcnRGaWx0ZXJLZXlzVG9TbmFrZUNhc2Uob3B0aW9ucy53aGVyZSk7XG4gICAgY29uc3QgZmlsdGVyUXVlcnkgPSBidWlsZEZpbHRlclF1ZXJ5KGNvbnZlcnRlZFdoZXJlKTtcbiAgICBpZiAoZmlsdGVyUXVlcnkpIHtcbiAgICAgIGNvbnN0IGZpbHRlclBhcmFtcyA9IGZpbHRlclF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgZmlsdGVyUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhcmFtLnNwbGl0KFwiPVwiLCAyKTtcbiAgICAgICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMub3JkZXJCeSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmRlckJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXJhbXMub3JkZXIgPSBvcHRpb25zLm9yZGVyQnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yZGVyQ2xhdXNlcyA9IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMub3JkZXJCeSkubWFwKChbZmllbGQsIGRpcmVjdGlvbl0pID0+IGAke2NhbWVsVG9TbmFrZShmaWVsZCl9LiR7ZGlyZWN0aW9ufWApO1xuICAgICAgcGFyYW1zLm9yZGVyID0gb3JkZXJDbGF1c2VzLmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5saW1pdCAhPT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zLmxpbWl0ID0gb3B0aW9ucy5saW1pdC50b1N0cmluZygpO1xuICB9XG4gIGlmIChvcHRpb25zLm9mZnNldCAhPT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zLm9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY3Vyc29yKSB7XG4gICAgcGFyYW1zLmN1cnNvciA9IG9wdGlvbnMuY3Vyc29yO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8vIC4uL2NvcmUvc3JjL2h0dHAtY2xpZW50LnRzXG5mdW5jdGlvbiBjYW1lbFRvU25ha2UyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tBLVpdL2csIChsZXR0ZXIpID0+IGBfJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX1gKTtcbn1cbmZ1bmN0aW9uIHNuYWtlVG9DYW1lbChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgbGV0dGVyKSA9PiBsZXR0ZXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0S2V5c1RvU25ha2VDYXNlKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwKSByZXR1cm4gb2JqO1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIG9iajtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iai5tYXAoY29udmVydEtleXNUb1NuYWtlQ2FzZSk7XG4gIGNvbnN0IGNvbnZlcnRlZCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgY29uc3Qgc25ha2VLZXkgPSBjYW1lbFRvU25ha2UyKGtleSk7XG4gICAgY29udmVydGVkW3NuYWtlS2V5XSA9IGNvbnZlcnRLZXlzVG9TbmFrZUNhc2UodmFsdWUpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0S2V5c1RvQ2FtZWxDYXNlKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwKSByZXR1cm4gb2JqO1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIG9iajtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iai5tYXAoY29udmVydEtleXNUb0NhbWVsQ2FzZSk7XG4gIGNvbnN0IGNvbnZlcnRlZCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgY29uc3QgY2FtZWxLZXkgPSBzbmFrZVRvQ2FtZWwoa2V5KTtcbiAgICBjb252ZXJ0ZWRbY2FtZWxLZXldID0gY29udmVydEtleXNUb0NhbWVsQ2FzZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbnZhciBIdHRwQ2xpZW50ID0gY2xhc3Mge1xuICBhdXRoVXJsID0gXCJodHRwczovL2JsaW5rLm5ld1wiO1xuICBjb3JlVXJsID0gXCJodHRwczovL2NvcmUuYmxpbmsubmV3XCI7XG4gIHByb2plY3RJZDtcbiAgcHVibGlzaGFibGVLZXk7XG4gIHNlY3JldEtleTtcbiAgLy8gUGVybWFuZW50LCBub24tZXhwaXJpbmcga2V5IChsaWtlIFN0cmlwZSdzIHNrX2xpdmVfLi4uKVxuICBnZXRUb2tlbjtcbiAgZ2V0VmFsaWRUb2tlbjtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBnZXRUb2tlbiwgZ2V0VmFsaWRUb2tlbikge1xuICAgIHRoaXMucHJvamVjdElkID0gY29uZmlnLnByb2plY3RJZDtcbiAgICB0aGlzLnB1Ymxpc2hhYmxlS2V5ID0gY29uZmlnLnB1Ymxpc2hhYmxlS2V5O1xuICAgIHRoaXMuc2VjcmV0S2V5ID0gY29uZmlnLnNlY3JldEtleSB8fCBjb25maWcuc2VydmljZVRva2VuO1xuICAgIHRoaXMuZ2V0VG9rZW4gPSBnZXRUb2tlbjtcbiAgICB0aGlzLmdldFZhbGlkVG9rZW4gPSBnZXRWYWxpZFRva2VuO1xuICB9XG4gIHNob3VsZEF0dGFjaFB1Ymxpc2hhYmxlS2V5KHBhdGgsIG1ldGhvZCkge1xuICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIlBPU1RcIikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKFwiL2FwaS9hbmFseXRpY3MvXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocGF0aC5pbmNsdWRlcyhcIi9hcGkvc3RvcmFnZS9cIikpIHJldHVybiB0cnVlO1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKFwiL2FwaS9kYi9cIikgJiYgcGF0aC5pbmNsdWRlcyhcIi9yZXN0L3YxL1wiKSkgcmV0dXJuIG1ldGhvZCA9PT0gXCJHRVRcIjtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2hvdWxkU2tpcFNlY3JldEtleSh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkID0gbmV3IFVSTCh1cmwpO1xuICAgICAgcmV0dXJuIHBhcnNlZC5ob3N0bmFtZS5lbmRzV2l0aChcIi5mdW5jdGlvbnMuYmxpbmsubmV3XCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXRBdXRob3JpemF0aW9uSGVhZGVyKHVybCwgdG9rZW4pIHtcbiAgICBpZiAodGhpcy5zZWNyZXRLZXkgJiYgIXRoaXMuc2hvdWxkU2tpcFNlY3JldEtleSh1cmwpKSB7XG4gICAgICByZXR1cm4gYEJlYXJlciAke3RoaXMuc2VjcmV0S2V5fWA7XG4gICAgfVxuICAgIGlmICh0b2tlbikge1xuICAgICAgcmV0dXJuIGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTWFrZSBhbiBhdXRoZW50aWNhdGVkIHJlcXVlc3QgdG8gdGhlIEJsaW5rIEFQSVxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdChwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVXJsKHBhdGgsIG9wdGlvbnMuc2VhcmNoUGFyYW1zKTtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VmFsaWRUb2tlbiA/IGF3YWl0IHRoaXMuZ2V0VmFsaWRUb2tlbigpIDogdGhpcy5nZXRUb2tlbigpO1xuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCI7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgfTtcbiAgICBjb25zdCBhdXRoID0gdGhpcy5nZXRBdXRob3JpemF0aW9uSGVhZGVyKHVybCwgdG9rZW4pO1xuICAgIGlmIChhdXRoKSB7XG4gICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBhdXRoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wdWJsaXNoYWJsZUtleSAmJiAhaGVhZGVyc1tcIngtYmxpbmstcHVibGlzaGFibGUta2V5XCJdICYmIHRoaXMuc2hvdWxkQXR0YWNoUHVibGlzaGFibGVLZXkocGF0aCwgbWV0aG9kKSkge1xuICAgICAgaGVhZGVyc1tcIngtYmxpbmstcHVibGlzaGFibGUta2V5XCJdID0gdGhpcy5wdWJsaXNoYWJsZUtleTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMuYm9keSAmJiBtZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSB0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5ib2R5IDogSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCByZXF1ZXN0SW5pdCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5wYXJzZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0Vycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rTmV0d29ya0Vycm9yKFxuICAgICAgICBgTmV0d29yayByZXF1ZXN0IGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdFVCByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBnZXQocGF0aCwgc2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChwYXRoLCB7IG1ldGhvZDogXCJHRVRcIiwgc2VhcmNoUGFyYW1zIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQT1NUIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIHBvc3QocGF0aCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QocGF0aCwgeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5LCBoZWFkZXJzIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQQVRDSCByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBwYXRjaChwYXRoLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChwYXRoLCB7IG1ldGhvZDogXCJQQVRDSFwiLCBib2R5LCBoZWFkZXJzIH0pO1xuICB9XG4gIC8qKlxuICAgKiBERUxFVEUgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKHBhdGgsIHNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QocGF0aCwgeyBtZXRob2Q6IFwiREVMRVRFXCIsIHNlYXJjaFBhcmFtcyB9KTtcbiAgfVxuICAvKipcbiAgICogRGF0YWJhc2Utc3BlY2lmaWMgcmVxdWVzdHNcbiAgICovXG4gIC8vIFRhYmxlIG9wZXJhdGlvbnMgKFBvc3RnUkVTVC1jb21wYXRpYmxlKVxuICBhc3luYyBkYkdldCh0YWJsZSwgc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldChgL2FwaS9kYi8ke3RoaXMucHJvamVjdElkfS9yZXN0L3YxLyR7dGFibGV9YCwgc2VhcmNoUGFyYW1zKTtcbiAgICBjb25zdCBjb252ZXJ0ZWREYXRhID0gY29udmVydEtleXNUb0NhbWVsQ2FzZShyZXNwb25zZS5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBkYXRhOiBjb252ZXJ0ZWREYXRhXG4gICAgfTtcbiAgfVxuICBhc3luYyBkYlBvc3QodGFibGUsIGJvZHksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGhlYWRlcnMuUHJlZmVyID0gXCJyZXR1cm49cmVwcmVzZW50YXRpb25cIjtcbiAgICB9XG4gICAgY29uc3QgY29udmVydGVkQm9keSA9IGNvbnZlcnRLZXlzVG9TbmFrZUNhc2UoYm9keSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3QoYC9hcGkvZGIvJHt0aGlzLnByb2plY3RJZH0vcmVzdC92MS8ke3RhYmxlfWAsIGNvbnZlcnRlZEJvZHksIGhlYWRlcnMpO1xuICAgIGNvbnN0IGNvbnZlcnRlZERhdGEgPSBjb252ZXJ0S2V5c1RvQ2FtZWxDYXNlKHJlc3BvbnNlLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGRhdGE6IGNvbnZlcnRlZERhdGFcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRiUGF0Y2godGFibGUsIGJvZHksIHNlYXJjaFBhcmFtcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgaGVhZGVycy5QcmVmZXIgPSBcInJldHVybj1yZXByZXNlbnRhdGlvblwiO1xuICAgIH1cbiAgICBjb25zdCBjb252ZXJ0ZWRCb2R5ID0gY29udmVydEtleXNUb1NuYWtlQ2FzZShib2R5KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdChgL2FwaS9kYi8ke3RoaXMucHJvamVjdElkfS9yZXN0L3YxLyR7dGFibGV9YCwge1xuICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICBib2R5OiBjb252ZXJ0ZWRCb2R5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNlYXJjaFBhcmFtc1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbnZlcnRlZERhdGEgPSBjb252ZXJ0S2V5c1RvQ2FtZWxDYXNlKHJlc3BvbnNlLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGRhdGE6IGNvbnZlcnRlZERhdGFcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRiRGVsZXRlKHRhYmxlLCBzZWFyY2hQYXJhbXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGhlYWRlcnMuUHJlZmVyID0gXCJyZXR1cm49cmVwcmVzZW50YXRpb25cIjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYC9hcGkvZGIvJHt0aGlzLnByb2plY3RJZH0vcmVzdC92MS8ke3RhYmxlfWAsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZWFyY2hQYXJhbXNcbiAgICB9KTtcbiAgICBjb25zdCBjb252ZXJ0ZWREYXRhID0gY29udmVydEtleXNUb0NhbWVsQ2FzZShyZXNwb25zZS5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBkYXRhOiBjb252ZXJ0ZWREYXRhXG4gICAgfTtcbiAgfVxuICAvLyBSYXcgU1FMIG9wZXJhdGlvbnNcbiAgYXN5bmMgZGJTcWwocXVlcnksIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KGAvYXBpL2RiLyR7dGhpcy5wcm9qZWN0SWR9L3NxbGAsIHsgcXVlcnksIHBhcmFtcyB9KTtcbiAgICBjb25zdCBjb252ZXJ0ZWREYXRhID0ge1xuICAgICAgLi4ucmVzcG9uc2UuZGF0YSxcbiAgICAgIHJvd3M6IGNvbnZlcnRLZXlzVG9DYW1lbENhc2UocmVzcG9uc2UuZGF0YS5yb3dzKVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgZGF0YTogY29udmVydGVkRGF0YVxuICAgIH07XG4gIH1cbiAgLy8gQmF0Y2ggU1FMIG9wZXJhdGlvbnNcbiAgYXN5bmMgZGJCYXRjaChzdGF0ZW1lbnRzLCBtb2RlID0gXCJ3cml0ZVwiKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3QoYC9hcGkvZGIvJHt0aGlzLnByb2plY3RJZH0vYmF0Y2hgLCB7IHN0YXRlbWVudHMsIG1vZGUgfSk7XG4gICAgY29uc3QgY29udmVydGVkRGF0YSA9IHtcbiAgICAgIC4uLnJlc3BvbnNlLmRhdGEsXG4gICAgICByZXN1bHRzOiByZXNwb25zZS5kYXRhLnJlc3VsdHMubWFwKChyZXN1bHQpID0+ICh7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgcm93czogY29udmVydEtleXNUb0NhbWVsQ2FzZShyZXN1bHQucm93cylcbiAgICAgIH0pKVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgZGF0YTogY29udmVydGVkRGF0YVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZCBmaWxlIHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmdcbiAgICovXG4gIGFzeW5jIHVwbG9hZEZpbGUocGF0aCwgZmlsZSwgZmlsZVBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVcmwocGF0aCk7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFZhbGlkVG9rZW4gPyBhd2FpdCB0aGlzLmdldFZhbGlkVG9rZW4oKSA6IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTtcbiAgICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICBjb25zdCBibG9iV2l0aFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlID8gbmV3IEJsb2IoW2ZpbGVdLCB7IHR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUgfSkgOiBmaWxlO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBibG9iV2l0aFR5cGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2ZpbGVdLCB7IHR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUgfHwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9KTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgYmxvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBCbGlua1ZhbGlkYXRpb25FcnJvcihcIlVuc3VwcG9ydGVkIGZpbGUgdHlwZVwiKTtcbiAgICB9XG4gICAgZm9ybURhdGEuYXBwZW5kKFwicGF0aFwiLCBmaWxlUGF0aCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGNvbnN0IGF1dGggPSB0aGlzLmdldEF1dGhvcml6YXRpb25IZWFkZXIodXJsLCB0b2tlbik7XG4gICAgaWYgKGF1dGgpIHtcbiAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGF1dGg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnB1Ymxpc2hhYmxlS2V5ICYmIHBhdGguaW5jbHVkZXMoXCIvYXBpL3N0b3JhZ2UvXCIpICYmICFoZWFkZXJzW1wieC1ibGluay1wdWJsaXNoYWJsZS1rZXlcIl0pIHtcbiAgICAgIGhlYWRlcnNbXCJ4LWJsaW5rLXB1Ymxpc2hhYmxlLWtleVwiXSA9IHRoaXMucHVibGlzaGFibGVLZXk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiICYmIG9wdGlvbnMub25Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy51cGxvYWRXaXRoUHJvZ3Jlc3ModXJsLCBmb3JtRGF0YSwgaGVhZGVycywgb3B0aW9ucy5vblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnBhcnNlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBGaWxlIHVwbG9hZCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgd2l0aCBwcm9ncmVzcyB0cmFja2luZyB1c2luZyBYTUxIdHRwUmVxdWVzdFxuICAgKi9cbiAgdXBsb2FkV2l0aFByb2dyZXNzKHVybCwgZm9ybURhdGEsIGhlYWRlcnMsIG9uUHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5yb3VuZChldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCAqIDEwMCk7XG4gICAgICAgICAgb25Qcm9ncmVzcyhwZXJjZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKClcbiAgICAgICAgICAgICAgLy8gWE1MSHR0cFJlcXVlc3QgZG9lc24ndCBwcm92aWRlIGVhc3kgYWNjZXNzIHRvIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEJsaW5rTmV0d29ya0Vycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlXCIsIHhoci5zdGF0dXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yPy5tZXNzYWdlIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8IGBIVFRQICR7eGhyLnN0YXR1c31gO1xuICAgICAgICAgICAgc3dpdGNoICh4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtBdXRoRXJyb3IobWVzc2FnZSwgZXJyb3JEYXRhKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtWYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZXJyb3JEYXRhKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua05ldHdvcmtFcnJvcihtZXNzYWdlLCB4aHIuc3RhdHVzLCBlcnJvckRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtOZXR3b3JrRXJyb3IoYEhUVFAgJHt4aHIuc3RhdHVzfWAsIHhoci5zdGF0dXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgQmxpbmtOZXR3b3JrRXJyb3IoXCJOZXR3b3JrIGVycm9yIGR1cmluZyBmaWxlIHVwbG9hZFwiKSk7XG4gICAgICB9KTtcbiAgICAgIHhoci5vcGVuKFwiUE9TVFwiLCB1cmwpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFJLXNwZWNpZmljIHJlcXVlc3RzXG4gICAqL1xuICBhc3luYyBhaVRleHQocHJvbXB0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4uYm9keSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHsgLi4uYm9keSB9O1xuICAgIGlmIChwcm9tcHQpIHtcbiAgICAgIHJlcXVlc3RCb2R5LnByb21wdCA9IHByb21wdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS90ZXh0YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHJlcXVlc3RCb2R5LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0cmVhbSBBSSB0ZXh0IGdlbmVyYXRpb24gLSB1c2VzIFZlcmNlbCBBSSBTREsncyBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSAoRGF0YSBTdHJlYW0gUHJvdG9jb2wpXG4gICAqL1xuICBhc3luYyBzdHJlYW1BaVRleHQocHJvbXB0LCBvcHRpb25zID0ge30sIG9uQ2h1bmspIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVXJsKGAvYXBpL2FpLyR7dGhpcy5wcm9qZWN0SWR9L3RleHRgKTtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VmFsaWRUb2tlbiA/IGF3YWl0IHRoaXMuZ2V0VmFsaWRUb2tlbigpIDogdGhpcy5nZXRUb2tlbigpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgY29uc3QgYXV0aCA9IHRoaXMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlcih1cmwsIHRva2VuKTtcbiAgICBpZiAoYXV0aCkgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYXV0aDtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgcHJvbXB0LFxuICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgeyBzaWduYWw6IF9zaWduYWwsIC4uLmpzb25Cb2R5IH0gPSBib2R5O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uQm9keSksXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua05ldHdvcmtFcnJvcihcIk5vIHJlc3BvbnNlIGJvZHkgZm9yIHN0cmVhbWluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0YVN0cmVhbVByb3RvY29sKHJlc3BvbnNlLmJvZHksIG9uQ2h1bmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0Vycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rTmV0d29ya0Vycm9yKFxuICAgICAgICBgU3RyZWFtaW5nIHJlcXVlc3QgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBhc3luYyBhaU9iamVjdChwcm9tcHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmFsLCAuLi5ib2R5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0geyAuLi5ib2R5IH07XG4gICAgaWYgKHByb21wdCkge1xuICAgICAgcmVxdWVzdEJvZHkucHJvbXB0ID0gcHJvbXB0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FpLyR7dGhpcy5wcm9qZWN0SWR9L29iamVjdGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiByZXF1ZXN0Qm9keSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdHJlYW0gQUkgb2JqZWN0IGdlbmVyYXRpb24gLSB1c2VzIFZlcmNlbCBBSSBTREsncyBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIHN0cmVhbUFpT2JqZWN0KHByb21wdCwgb3B0aW9ucyA9IHt9LCBvblBhcnRpYWwpIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVXJsKGAvYXBpL2FpLyR7dGhpcy5wcm9qZWN0SWR9L29iamVjdGApO1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5nZXRWYWxpZFRva2VuID8gYXdhaXQgdGhpcy5nZXRWYWxpZFRva2VuKCkgOiB0aGlzLmdldFRva2VuKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfTtcbiAgICBjb25zdCBhdXRoID0gdGhpcy5nZXRBdXRob3JpemF0aW9uSGVhZGVyKHVybCwgdG9rZW4pO1xuICAgIGlmIChhdXRoKSBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBhdXRoO1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBwcm9tcHQsXG4gICAgICBzdHJlYW06IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCB7IHNpZ25hbDogX3NpZ25hbDIsIC4uLmpzb25Cb2R5MiB9ID0gYm9keTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkJvZHkyKSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rTmV0d29ya0Vycm9yKFwiTm8gcmVzcG9uc2UgYm9keSBmb3Igc3RyZWFtaW5nXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgICAgbGV0IGxhdGVzdE9iamVjdCA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICBidWZmZXIgKz0gY2h1bms7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoYnVmZmVyKTtcbiAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IHBhcnNlZDtcbiAgICAgICAgICAgIGlmIChvblBhcnRpYWwpIHtcbiAgICAgICAgICAgICAgb25QYXJ0aWFsKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gSlNPTi5wYXJzZShidWZmZXIpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBvYmplY3Q6IGxhdGVzdE9iamVjdCB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtOZXR3b3JrRXJyb3IoXG4gICAgICAgIGBTdHJlYW1pbmcgcmVxdWVzdCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFpSW1hZ2UocHJvbXB0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4uYm9keSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FpLyR7dGhpcy5wcm9qZWN0SWR9L2ltYWdlYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWlTcGVlY2godGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYWwsIC4uLmJvZHkgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS9zcGVlY2hgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keToge1xuICAgICAgICB0ZXh0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWlUcmFuc2NyaWJlKGF1ZGlvLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4uYm9keSB9ID0gb3B0aW9ucztcbiAgICBsZXQgcGF5bG9hZEF1ZGlvO1xuICAgIGlmICh0eXBlb2YgYXVkaW8gPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShhdWRpbykpIHtcbiAgICAgIHBheWxvYWRBdWRpbyA9IGF1ZGlvO1xuICAgIH0gZWxzZSBpZiAoYXVkaW8gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBwYXlsb2FkQXVkaW8gPSBBcnJheS5mcm9tKGF1ZGlvKTtcbiAgICB9IGVsc2UgaWYgKGF1ZGlvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHBheWxvYWRBdWRpbyA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYXVkaW8pKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgQnVmZmVyLmlzQnVmZmVyKGF1ZGlvKSkge1xuICAgICAgcGF5bG9hZEF1ZGlvID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShhdWRpbykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtWYWxpZGF0aW9uRXJyb3IoXCJVbnN1cHBvcnRlZCBhdWRpbyBpbnB1dCB0eXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FpLyR7dGhpcy5wcm9qZWN0SWR9L3RyYW5zY3JpYmVgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keToge1xuICAgICAgICBhdWRpbzogcGF5bG9hZEF1ZGlvLFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWlWaWRlbyhwcm9tcHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmFsLCAuLi5ib2R5IH0gPSBvcHRpb25zO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvYWkvJHt0aGlzLnByb2plY3RJZH0vdmlkZW9gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keToge1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0sXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQUkgQWdlbnQgcmVxdWVzdCAobm9uLXN0cmVhbWluZylcbiAgICogUmV0dXJucyBKU09OIHJlc3BvbnNlIHdpdGggdGV4dCwgc3RlcHMsIHVzYWdlLCBhbmQgYmlsbGluZ1xuICAgKi9cbiAgYXN5bmMgYWlBZ2VudChyZXF1ZXN0Qm9keSwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS9hZ2VudGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiByZXF1ZXN0Qm9keSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBSSBBZ2VudCBzdHJlYW1pbmcgcmVxdWVzdFxuICAgKiBSZXR1cm5zIHJhdyBSZXNwb25zZSBmb3IgU1NFIHN0cmVhbWluZyAoY29tcGF0aWJsZSB3aXRoIEFJIFNESyB1c2VDaGF0KVxuICAgKi9cbiAgYXN5bmMgYWlBZ2VudFN0cmVhbShyZXF1ZXN0Qm9keSwgc2lnbmFsKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS9hZ2VudGApO1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5nZXRWYWxpZFRva2VuID8gYXdhaXQgdGhpcy5nZXRWYWxpZFRva2VuKCkgOiB0aGlzLmdldFRva2VuKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfTtcbiAgICBjb25zdCBhdXRoID0gdGhpcy5nZXRBdXRob3JpemF0aW9uSGVhZGVyKHVybCwgdG9rZW4pO1xuICAgIGlmIChhdXRoKSBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBhdXRoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogUkFHIEFJIFNlYXJjaCBzdHJlYW1pbmcgcmVxdWVzdFxuICAgKiBSZXR1cm5zIHJhdyBSZXNwb25zZSBmb3IgU1NFIHN0cmVhbWluZ1xuICAgKi9cbiAgYXN5bmMgcmFnQWlTZWFyY2hTdHJlYW0oYm9keSwgc2lnbmFsKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChgL2FwaS9yYWcvJHt0aGlzLnByb2plY3RJZH0vYWktc2VhcmNoYCk7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFZhbGlkVG9rZW4gPyBhd2FpdCB0aGlzLmdldFZhbGlkVG9rZW4oKSA6IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9O1xuICAgIGNvbnN0IGF1dGggPSB0aGlzLmdldEF1dGhvcml6YXRpb25IZWFkZXIodXJsLCB0b2tlbik7XG4gICAgaWYgKGF1dGgpIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGF1dGg7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIERhdGEtc3BlY2lmaWMgcmVxdWVzdHNcbiAgICovXG4gIGFzeW5jIGRhdGFFeHRyYWN0RnJvbVVybChwcm9qZWN0SWQsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2RhdGEvJHtwcm9qZWN0SWR9L2V4dHJhY3QtZnJvbS11cmxgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdClcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkYXRhRXh0cmFjdEZyb21CbG9iKHByb2plY3RJZCwgZmlsZSwgY2h1bmtpbmcsIGNodW5rU2l6ZSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTtcbiAgICBpZiAoY2h1bmtpbmcgIT09IHZvaWQgMCkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiY2h1bmtpbmdcIiwgU3RyaW5nKGNodW5raW5nKSk7XG4gICAgfVxuICAgIGlmIChjaHVua1NpemUgIT09IHZvaWQgMCkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiY2h1bmtTaXplXCIsIFN0cmluZyhjaHVua1NpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9kYXRhLyR7cHJvamVjdElkfS9leHRyYWN0LWZyb20tYmxvYmAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBmb3JtRGF0YVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRhdGFTY3JhcGUocHJvamVjdElkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9kYXRhLyR7cHJvamVjdElkfS9zY3JhcGVgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdClcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkYXRhU2NyZWVuc2hvdChwcm9qZWN0SWQsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2RhdGEvJHtwcm9qZWN0SWR9L3NjcmVlbnNob3RgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdClcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkYXRhRmV0Y2gocHJvamVjdElkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChgL2FwaS9kYXRhLyR7cHJvamVjdElkfS9mZXRjaGAsIHJlcXVlc3QpO1xuICB9XG4gIGFzeW5jIGRhdGFTZWFyY2gocHJvamVjdElkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucG9zdChgL2FwaS9kYXRhLyR7cHJvamVjdElkfS9zZWFyY2hgLCByZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ29ubmVjdG9yIHJlcXVlc3RzXG4gICAqL1xuICBmb3JtYXRQcm92aWRlckZvclBhdGgocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gcHJvdmlkZXIucmVwbGFjZShcIl9cIiwgXCItXCIpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3RvclN0YXR1cyhwcm92aWRlcikge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvY29ubmVjdG9ycy8ke3RoaXMuZm9ybWF0UHJvdmlkZXJGb3JQYXRoKHByb3ZpZGVyKX0vJHt0aGlzLnByb2plY3RJZH0vc3RhdHVzYCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdG9yRXhlY3V0ZShwcm92aWRlciwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHBhdGggPSByZXF1ZXN0Lm1ldGhvZC5zdGFydHNXaXRoKFwiL1wiKSA/IHJlcXVlc3QubWV0aG9kIDogYC8ke3JlcXVlc3QubWV0aG9kfWA7XG4gICAgY29uc3QgdXJsID0gYC9hcGkvY29ubmVjdG9ycy8ke3RoaXMuZm9ybWF0UHJvdmlkZXJGb3JQYXRoKHByb3ZpZGVyKX0vJHt0aGlzLnByb2plY3RJZH0ke3BhdGh9YDtcbiAgICBjb25zdCBtZXRob2QgPSAocmVxdWVzdC5odHRwX21ldGhvZCB8fCBcIkdFVFwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChtZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgc2VhcmNoUGFyYW1zOiByZXF1ZXN0LnBhcmFtc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXJsLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBib2R5OiByZXF1ZXN0LnBhcmFtcyB8fCB7fVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbm5lY3RvclNhdmVBcGlLZXkocHJvdmlkZXIsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2Nvbm5lY3RvcnMvJHt0aGlzLmZvcm1hdFByb3ZpZGVyRm9yUGF0aChwcm92aWRlcil9LyR7dGhpcy5wcm9qZWN0SWR9L2FwaS1rZXlgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcmVxdWVzdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZWFsdGltZS1zcGVjaWZpYyByZXF1ZXN0c1xuICAgKi9cbiAgYXN5bmMgcmVhbHRpbWVQdWJsaXNoKHByb2plY3RJZCwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC9hcGkvcmVhbHRpbWUvJHtwcm9qZWN0SWR9L3B1Ymxpc2hgLCByZXF1ZXN0KTtcbiAgfVxuICBhc3luYyByZWFsdGltZUdldFByZXNlbmNlKHByb2plY3RJZCwgY2hhbm5lbCkge1xuICAgIHJldHVybiB0aGlzLmdldChgL2FwaS9yZWFsdGltZS8ke3Byb2plY3RJZH0vcHJlc2VuY2VgLCB7IGNoYW5uZWwgfSk7XG4gIH1cbiAgYXN5bmMgcmVhbHRpbWVHZXRNZXNzYWdlcyhwcm9qZWN0SWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoYW5uZWwsIC4uLnNlYXJjaFBhcmFtcyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9hcGkvcmVhbHRpbWUvJHtwcm9qZWN0SWR9L21lc3NhZ2VzYCwge1xuICAgICAgY2hhbm5lbCxcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc2VhcmNoUGFyYW1zKS5maWx0ZXIoKFtrLCB2XSkgPT4gdiAhPT0gdm9pZCAwKS5tYXAoKFtrLCB2XSkgPT4gW2ssIFN0cmluZyh2KV0pXG4gICAgICApXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZHNcbiAgICovXG4gIGJ1aWxkVXJsKHBhdGgsIHNlYXJjaFBhcmFtcykge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBwYXRoLmluY2x1ZGVzKFwiL2FwaS9hdXRoL1wiKSA/IHRoaXMuYXV0aFVybCA6IHRoaXMuY29yZVVybDtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICAgIGlmIChzZWFyY2hQYXJhbXMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNlYXJjaFBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfVxuICBhc3luYyBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAoY29udGVudFR5cGU/LmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnRUeXBlPy5pbmNsdWRlcyhcInRleHQvXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICB9XG4gIGFzeW5jIGhhbmRsZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBsZXQgZXJyb3JEYXRhO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlPy5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JEYXRhID0geyBtZXNzYWdlOiBhd2FpdCByZXNwb25zZS50ZXh0KCkgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogXCJVbmtub3duIGVycm9yIG9jY3VycmVkXCIgfTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvckRhdGEubWVzc2FnZSB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gO1xuICAgIGVycm9yRGF0YS5lcnJvcj8uY29kZSB8fCBlcnJvckRhdGEuY29kZTtcbiAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgY2FzZSA0MDE6XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihtZXNzYWdlLCBlcnJvckRhdGEpO1xuICAgICAgY2FzZSA0MDA6XG4gICAgICAgIHRocm93IG5ldyBCbGlua1ZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCBlcnJvckRhdGEpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rTmV0d29ya0Vycm9yKG1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JEYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIFZlcmNlbCBBSSBTREsgdjUgRGF0YSBTdHJlYW0gUHJvdG9jb2wgKFNlcnZlci1TZW50IEV2ZW50cylcbiAgICogU3VwcG9ydHMgYWxsIGV2ZW50IHR5cGVzIGZyb20gdGhlIFVJIE1lc3NhZ2UgU3RyZWFtIHByb3RvY29sXG4gICAqL1xuICBhc3luYyBwYXJzZURhdGFTdHJlYW1Qcm90b2NvbChib2R5LCBvbkNodW5rKSB7XG4gICAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgY29uc3QgZmluYWxSZXN1bHQgPSB7XG4gICAgICB0ZXh0OiBcIlwiLFxuICAgICAgdG9vbENhbGxzOiBbXSxcbiAgICAgIHRvb2xSZXN1bHRzOiBbXSxcbiAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgcmVhc29uaW5nOiBbXVxuICAgIH07XG4gICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGJ1ZmZlciA9IGxpbmVzLnBvcCgpIHx8IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgIGlmICghbGluZS50cmltKCkpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChsaW5lID09PSBcIltET05FXVwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFsaW5lLnN0YXJ0c1dpdGgoXCJkYXRhOiBcIikpIGNvbnRpbnVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqc29uU3RyID0gbGluZS5zbGljZSg2KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFydC5kZWx0YSkge1xuICAgICAgICAgICAgICAgICAgZmluYWxSZXN1bHQudGV4dCArPSBwYXJ0LmRlbHRhO1xuICAgICAgICAgICAgICAgICAgaWYgKG9uQ2h1bmspIG9uQ2h1bmsocGFydC5kZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRleHREZWx0YSkge1xuICAgICAgICAgICAgICAgICAgZmluYWxSZXN1bHQudGV4dCArPSBwYXJ0LnRleHREZWx0YTtcbiAgICAgICAgICAgICAgICAgIGlmIChvbkNodW5rKSBvbkNodW5rKHBhcnQudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWVuZFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQudG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0LmFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQudG9vbFJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDogcGFydC5yZXN1bHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInNvdXJjZS11cmxcIjpcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5zb3VyY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgICB1cmw6IHBhcnQudXJsLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnQudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5maWxlcy5wdXNoKHBhcnQuZmlsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjpcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5yZWFzb25pbmcucHVzaChwYXJ0LmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQuZmluaXNoUmVhc29uID0gcGFydC5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQudXNhZ2UgPSBwYXJ0LnVzYWdlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnJlc3BvbnNlKSBmaW5hbFJlc3VsdC5yZXNwb25zZSA9IHBhcnQucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LmVycm9yID0gcGFydC5lcnJvcjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFydC5lcnJvcik7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFJlc3VsdC5jdXN0b21EYXRhKSBmaW5hbFJlc3VsdC5jdXN0b21EYXRhID0gW107XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQuY3VzdG9tRGF0YS5wdXNoKHBhcnQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5hbFJlc3VsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvYnJvd3Nlci1lbnYudHNcbmZ1bmN0aW9uIGhhc1dpbmRvdygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBoYXNXaW5kb3dMb2NhdGlvbigpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5sb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGhhc0RvY3VtZW50KCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZTIoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dMb2NhdGlvbigpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uSHJlZigpIHtcbiAgY29uc3QgbG9jID0gZ2V0V2luZG93TG9jYXRpb24oKTtcbiAgaWYgKCFsb2MpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBsb2MuaHJlZjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCBsb2MgPSBnZXRXaW5kb3dMb2NhdGlvbigpO1xuICBpZiAoIWxvYykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvYy5vcmlnaW47XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbkhvc3RuYW1lKCkge1xuICBjb25zdCBsb2MgPSBnZXRXaW5kb3dMb2NhdGlvbigpO1xuICBpZiAoIWxvYykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvYy5ob3N0bmFtZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uUGF0aG5hbWUoKSB7XG4gIGNvbnN0IGxvYyA9IGdldFdpbmRvd0xvY2F0aW9uKCk7XG4gIGlmICghbG9jKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jLnBhdGhuYW1lO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb25TZWFyY2goKSB7XG4gIGNvbnN0IGxvYyA9IGdldFdpbmRvd0xvY2F0aW9uKCk7XG4gIGlmICghbG9jKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jLnNlYXJjaDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uSGFzaCgpIHtcbiAgY29uc3QgbG9jID0gZ2V0V2luZG93TG9jYXRpb24oKTtcbiAgaWYgKCFsb2MpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBsb2MuaGFzaDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uUHJvdG9jb2woKSB7XG4gIGNvbnN0IGxvYyA9IGdldFdpbmRvd0xvY2F0aW9uKCk7XG4gIGlmICghbG9jKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jLnByb3RvY29sO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb25Ib3N0KCkge1xuICBjb25zdCBsb2MgPSBnZXRXaW5kb3dMb2NhdGlvbigpO1xuICBpZiAoIWxvYykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvYy5ob3N0O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gY29uc3RydWN0RnVsbFVybCgpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHByb3RvY29sID0gZ2V0TG9jYXRpb25Qcm90b2NvbCgpO1xuICBjb25zdCBob3N0ID0gZ2V0TG9jYXRpb25Ib3N0KCk7XG4gIGNvbnN0IHBhdGhuYW1lID0gZ2V0TG9jYXRpb25QYXRobmFtZSgpO1xuICBjb25zdCBzZWFyY2ggPSBnZXRMb2NhdGlvblNlYXJjaCgpO1xuICBjb25zdCBoYXNoID0gZ2V0TG9jYXRpb25IYXNoKCk7XG4gIGlmICghcHJvdG9jb2wgfHwgIWhvc3QpIHJldHVybiBudWxsO1xuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwYXRobmFtZSB8fCBcIlwifSR7c2VhcmNoIHx8IFwiXCJ9JHtoYXNoIHx8IFwiXCJ9YDtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVmZXJyZXIoKSB7XG4gIGlmICghaGFzRG9jdW1lbnQoKSkgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnJlZmVycmVyIHx8IG51bGw7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dJbm5lcldpZHRoKCkge1xuICBpZiAoIWhhc1dpbmRvdygpKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGg7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBpc0lmcmFtZSgpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlc3Npb25TdG9yYWdlKCkge1xuICBpZiAoIWhhc1dpbmRvdygpKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LnNlc3Npb25TdG9yYWdlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBzcmMvYXV0aC50c1xudmFyIEJsaW5rQXV0aCA9IGNsYXNzIHtcbiAgY29uZmlnO1xuICBhdXRoQ29uZmlnO1xuICBhdXRoU3RhdGU7XG4gIGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGF1dGhVcmw7XG4gIGNvcmVVcmw7XG4gIHBhcmVudFdpbmRvd1Rva2VucyA9IG51bGw7XG4gIGlzSWZyYW1lID0gZmFsc2U7XG4gIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7XG4gIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgc3RvcmFnZTtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgaWYgKCFjb25maWcucHJvamVjdElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9qZWN0SWQgaXMgcmVxdWlyZWQgZm9yIGF1dGhlbnRpY2F0aW9uXCIpO1xuICAgIH1cbiAgICB0aGlzLmF1dGhDb25maWcgPSB7XG4gICAgICBtb2RlOiBcIm1hbmFnZWRcIixcbiAgICAgIC8vIERlZmF1bHQgbW9kZVxuICAgICAgYXV0aFVybDogXCJodHRwczovL2JsaW5rLm5ld1wiLFxuICAgICAgY29yZVVybDogXCJodHRwczovL2NvcmUuYmxpbmsubmV3XCIsXG4gICAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgICAvLyBEZWZhdWx0IHRvIHRydWUgZm9yIHdlYiBjb21wYXRpYmlsaXR5XG4gICAgICAuLi5jb25maWcuYXV0aFxuICAgIH07XG4gICAgdGhpcy5hdXRoVXJsID0gdGhpcy5hdXRoQ29uZmlnLmF1dGhVcmwgfHwgXCJodHRwczovL2JsaW5rLm5ld1wiO1xuICAgIHRoaXMuY29yZVVybCA9IHRoaXMuYXV0aENvbmZpZy5jb3JlVXJsIHx8IFwiaHR0cHM6Ly9jb3JlLmJsaW5rLm5ld1wiO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gZ2V0TG9jYXRpb25Ib3N0bmFtZSgpO1xuICAgIGlmIChob3N0bmFtZSAmJiB0aGlzLmF1dGhVcmwgPT09IFwiaHR0cHM6Ly9ibGluay5uZXdcIiAmJiAoaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgfHwgaG9zdG5hbWUgPT09IFwiMTI3LjAuMC4xXCIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJcXHUyNkEwXFx1RkUwRiBVc2luZyBkZWZhdWx0IGF1dGhVcmwgaW4gZGV2ZWxvcG1lbnQuIFNldCBhdXRoLmF1dGhVcmwgdG8geW91ciBhcHAgb3JpZ2luIGZvciBoZWFkbGVzcyBhdXRoIGVuZHBvaW50cyB0byB3b3JrLlwiKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5hdXRoUmVxdWlyZWQgIT09IHZvaWQgMCAmJiAhY29uZmlnLmF1dGg/Lm1vZGUpIHtcbiAgICAgIHRoaXMuYXV0aENvbmZpZy5tb2RlID0gY29uZmlnLmF1dGhSZXF1aXJlZCA/IFwibWFuYWdlZFwiIDogXCJoZWFkbGVzc1wiO1xuICAgIH1cbiAgICB0aGlzLmF1dGhTdGF0ZSA9IHtcbiAgICAgIHVzZXI6IG51bGwsXG4gICAgICB0b2tlbnM6IG51bGwsXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5zdG9yYWdlID0gY29uZmlnLmF1dGg/LnN0b3JhZ2UgfHwgY29uZmlnLnN0b3JhZ2UgfHwgZ2V0RGVmYXVsdFN0b3JhZ2VBZGFwdGVyKCk7XG4gICAgaWYgKGlzV2ViKSB7XG4gICAgICB0aGlzLmlzSWZyYW1lID0gaXNJZnJhbWUoKTtcbiAgICAgIHRoaXMuc2V0dXBQYXJlbnRXaW5kb3dMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5zZXR1cENyb3NzVGFiU3luYygpO1xuICAgICAgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UgPSB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHByb2plY3Qtc2NvcGVkIHN0b3JhZ2Uga2V5XG4gICAqL1xuICBnZXRTdG9yYWdlS2V5KHN1ZmZpeCkge1xuICAgIHJldHVybiBgYmxpbmtfJHtzdWZmaXh9XyR7dGhpcy5jb25maWcucHJvamVjdElkfWA7XG4gIH1cbiAgLyoqXG4gICAqIE1pZ3JhdGUgZXhpc3RpbmcgZ2xvYmFsIHRva2VucyB0byBwcm9qZWN0LXNjb3BlZCBzdG9yYWdlXG4gICAqIERJU0FCTEVEOiBXZSBkb24ndCBtaWdyYXRlIGdsb2JhbCBibGlua190b2tlbnMgYW55bW9yZSBiZWNhdXNlOlxuICAgKiAxLiBQbGF0Zm9ybSB1c2VzIGJsaW5rX3Rva2VucyBmb3IgcGxhdGZvcm0gYXV0aCAoZGlmZmVyZW50IHVzZXIpXG4gICAqIDIuIE1pZ3JhdGluZyBwbGF0Zm9ybSB0b2tlbnMgd291bGQgY2F1c2UgcHJvamVjdCB0byBzaG93IHdyb25nIHVzZXJcbiAgICogMy4gUHJvamVjdHMgc2hvdWxkIGFsd2F5cyBhdXRoZW50aWNhdGUgZnJlc2ggdmlhIHRoZWlyIG93biBmbG93XG4gICAqL1xuICBtaWdyYXRlRXhpc3RpbmdUb2tlbnMoKSB7XG4gIH1cbiAgLyoqXG4gICAqIFdhaXQgZm9yIGF1dGhlbnRpY2F0aW9uIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlXG4gICAqL1xuICBhc3luYyB3YWl0Rm9ySW5pdGlhbGl6YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXR1cCBsaXN0ZW5lciBmb3IgdG9rZW5zIGZyb20gcGFyZW50IHdpbmRvd1xuICAgKi9cbiAgc2V0dXBQYXJlbnRXaW5kb3dMaXN0ZW5lcigpIHtcbiAgICBpZiAoIWlzV2ViIHx8ICF0aGlzLmlzSWZyYW1lIHx8ICFoYXNXaW5kb3coKSkgcmV0dXJuO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IFwiaHR0cHM6Ly9ibGluay5uZXdcIiAmJiBldmVudC5vcmlnaW4gIT09IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCIgJiYgZXZlbnQub3JpZ2luICE9PSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIkJMSU5LX0FVVEhfVE9LRU5TXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0RTV9IFJlY2VpdmVkIGF1dGggdG9rZW5zIGZyb20gcGFyZW50IHdpbmRvd1wiKTtcbiAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmICh0b2tlbnMpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFdpbmRvd1Rva2VucyA9IHRva2VucztcbiAgICAgICAgICB0aGlzLnNldFRva2Vucyh0b2tlbnMsIGZhbHNlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBUb2tlbnMgZnJvbSBwYXJlbnQgd2luZG93IGFwcGxpZWRcIik7XG4gICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGFwcGx5IHBhcmVudCB3aW5kb3cgdG9rZW5zOlwiLCBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIkJMSU5LX0FVVEhfTE9HT1VUXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0RTR9IFJlY2VpdmVkIGxvZ291dCBjb21tYW5kIGZyb20gcGFyZW50IHdpbmRvd1wiKTtcbiAgICAgICAgdGhpcy5jbGVhclRva2VucygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChoYXNXaW5kb3coKSAmJiB3aW5kb3cucGFyZW50ICE9PSB3aW5kb3cpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTA0fSBSZXF1ZXN0aW5nIGF1dGggdG9rZW5zIGZyb20gcGFyZW50IHdpbmRvd1wiKTtcbiAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIkJMSU5LX1JFUVVFU1RfQVVUSF9UT0tFTlNcIixcbiAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5wcm9qZWN0SWRcbiAgICAgIH0sIFwiKlwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYXV0aGVudGljYXRpb24gZnJvbSBzdG9yZWQgdG9rZW5zIG9yIFVSTCBmcmFnbWVudHNcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgY29uc29sZS5sb2coXCJcXHV7MUY2ODB9IEluaXRpYWxpemluZyBCbGluayBBdXRoLi4uXCIpO1xuICAgIHRoaXMuc2V0TG9hZGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5taWdyYXRlRXhpc3RpbmdUb2tlbnMoKTtcbiAgICAgIGlmICh0aGlzLmlzSWZyYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTBEfSBEZXRlY3RlZCBpZnJhbWUgZW52aXJvbm1lbnQsIHdhaXRpbmcgZm9yIHBhcmVudCB0b2tlbnMuLi5cIik7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaW5kb3dUb2tlbnMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3MDUgVXNpbmcgdG9rZW5zIGZyb20gcGFyZW50IHdpbmRvd1wiKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh0aGlzLnBhcmVudFdpbmRvd1Rva2VucywgZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXV0aENvbmZpZy5kZXRlY3RTZXNzaW9uSW5VcmwgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHRva2Vuc0Zyb21VcmwgPSB0aGlzLmV4dHJhY3RUb2tlbnNGcm9tVXJsKCk7XG4gICAgICAgIGlmICh0b2tlbnNGcm9tVXJsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0RTV9IEZvdW5kIHRva2VucyBpbiBVUkwsIHNldHRpbmcgdGhlbS4uLlwiKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh0b2tlbnNGcm9tVXJsLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmNsZWFyVXJsVG9rZW5zKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IEF1dGggaW5pdGlhbGl6YXRpb24gY29tcGxldGUgKGZyb20gVVJMKVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JlZFRva2VucyA9IGF3YWl0IHRoaXMuZ2V0U3RvcmVkVG9rZW5zKCk7XG4gICAgICBpZiAoc3RvcmVkVG9rZW5zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEJFfSBGb3VuZCBzdG9yZWQgdG9rZW5zLCB2YWxpZGF0aW5nLi4uXCIsIHtcbiAgICAgICAgICBoYXNBY2Nlc3NUb2tlbjogISFzdG9yZWRUb2tlbnMuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIGhhc1JlZnJlc2hUb2tlbjogISFzdG9yZWRUb2tlbnMucmVmcmVzaF90b2tlbixcbiAgICAgICAgICBpc3N1ZWRBdDogc3RvcmVkVG9rZW5zLmlzc3VlZF9hdCxcbiAgICAgICAgICBleHBpcmVzSW46IHN0b3JlZFRva2Vucy5leHBpcmVzX2luLFxuICAgICAgICAgIHJlZnJlc2hFeHBpcmVzSW46IHN0b3JlZFRva2Vucy5yZWZyZXNoX2V4cGlyZXNfaW4sXG4gICAgICAgICAgY3VycmVudFRpbWU6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnRva2VucyA9IHN0b3JlZFRva2VucztcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY1Mjd9IFRva2VucyBzZXQgaW4gYXV0aCBzdGF0ZSwgcmVmcmVzaCB0b2tlbiBhdmFpbGFibGU6XCIsICEhdGhpcy5hdXRoU3RhdGUudG9rZW5zPy5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVTdG9yZWRUb2tlbnMoc3RvcmVkVG9rZW5zKTtcbiAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3MDUgQXV0aCBpbml0aWFsaXphdGlvbiBjb21wbGV0ZSAoZnJvbSBzdG9yYWdlKVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY1MDR9IFN0b3JlZCB0b2tlbnMgaW52YWxpZCwgY2xlYXJpbmcuLi5cIik7XG4gICAgICAgICAgdGhpcy5jbGVhclRva2VucygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgTm8gdG9rZW5zIGZvdW5kXCIpO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGhSZXF1aXJlZCAmJiBoYXNXaW5kb3dMb2NhdGlvbigpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTA0fSBBdXRoIHJlcXVpcmVkLCByZWRpcmVjdGluZyB0byBhdXRoIHBhZ2UuLi5cIik7XG4gICAgICAgIHRoaXMucmVkaXJlY3RUb0F1dGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjZBMFxcdUZFMEYgQXV0aCBub3QgcmVxdWlyZWQgb3Igbm8gd2luZG93LmxvY2F0aW9uLCBjb250aW51aW5nIHdpdGhvdXQgYXV0aGVudGljYXRpb25cIik7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVkaXJlY3QgdG8gQmxpbmsgYXV0aCBwYWdlXG4gICAqL1xuICBsb2dpbihuZXh0VXJsKSB7XG4gICAgaWYgKCFoYXNXaW5kb3dMb2NhdGlvbigpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJsb2dpbigpIGNhbGxlZCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudCAobm8gd2luZG93LmxvY2F0aW9uIGF2YWlsYWJsZSlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZWRpcmVjdFVybCA9IG5leHRVcmwgfHwgdGhpcy5hdXRoQ29uZmlnLnJlZGlyZWN0VXJsO1xuICAgIGlmICghcmVkaXJlY3RVcmwpIHtcbiAgICAgIGNvbnN0IGhyZWYgPSBnZXRMb2NhdGlvbkhyZWYoKTtcbiAgICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgcmVkaXJlY3RVcmwgPSBocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkaXJlY3RVcmwgPSBjb25zdHJ1Y3RGdWxsVXJsKCkgfHwgdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVkaXJlY3RVcmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVkaXJlY3RVcmwpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcInJlZGlyZWN0X3VybFwiKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJyZWRpcmVjdFwiKTtcbiAgICAgICAgcmVkaXJlY3RVcmwgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIHJlZGlyZWN0IFVSTDpcIiwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGF1dGhVcmwgPSBuZXcgVVJMKFwiL2F1dGhcIiwgdGhpcy5hdXRoVXJsKTtcbiAgICBhdXRoVXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJyZWRpcmVjdF91cmxcIiwgcmVkaXJlY3RVcmwgfHwgXCJcIik7XG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2plY3RJZCkge1xuICAgICAgYXV0aFVybC5zZWFyY2hQYXJhbXMuc2V0KFwicHJvamVjdF9pZFwiLCB0aGlzLmNvbmZpZy5wcm9qZWN0SWQpO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGF1dGhVcmwudG9TdHJpbmcoKTtcbiAgfVxuICAvKipcbiAgICogTG9nb3V0IGFuZCBjbGVhciBzdG9yZWQgdG9rZW5zXG4gICAqL1xuICBsb2dvdXQocmVkaXJlY3RVcmwpIHtcbiAgICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gICAgaWYgKHJlZGlyZWN0VXJsICYmIGhhc1dpbmRvd0xvY2F0aW9uKCkpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcmVkaXJlY3RVcmw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGlzIGF1dGhlbnRpY2F0ZWRcbiAgICovXG4gIGlzQXV0aGVudGljYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoU3RhdGUuaXNBdXRoZW50aWNhdGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB1c2VyIChzeW5jKVxuICAgKi9cbiAgY3VycmVudFVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aFN0YXRlLnVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGFjY2VzcyB0b2tlblxuICAgKi9cbiAgZ2V0VG9rZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aFN0YXRlLnRva2Vucz8uYWNjZXNzX3Rva2VuIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFjY2VzcyB0b2tlbiBpcyBleHBpcmVkIGJhc2VkIG9uIHRpbWVzdGFtcFxuICAgKi9cbiAgaXNBY2Nlc3NUb2tlbkV4cGlyZWQoKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy5hdXRoU3RhdGUudG9rZW5zO1xuICAgIGlmICghdG9rZW5zIHx8ICF0b2tlbnMuaXNzdWVkX2F0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBjb25zdCBleHBpcmVzQXQgPSB0b2tlbnMuaXNzdWVkX2F0ICsgdG9rZW5zLmV4cGlyZXNfaW47XG4gICAgY29uc3QgYnVmZmVyVGltZSA9IDMwO1xuICAgIHJldHVybiBub3cgPj0gZXhwaXJlc0F0IC0gYnVmZmVyVGltZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVmcmVzaCB0b2tlbiBpcyBleHBpcmVkIGJhc2VkIG9uIHRpbWVzdGFtcFxuICAgKi9cbiAgaXNSZWZyZXNoVG9rZW5FeHBpcmVkKCkge1xuICAgIGNvbnN0IHRva2VucyA9IHRoaXMuYXV0aFN0YXRlLnRva2VucztcbiAgICBpZiAoIXRva2VucyB8fCAhdG9rZW5zLnJlZnJlc2hfdG9rZW4gfHwgIXRva2Vucy5pc3N1ZWRfYXQgfHwgIXRva2Vucy5yZWZyZXNoX2V4cGlyZXNfaW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIGNvbnN0IGV4cGlyZXNBdCA9IHRva2Vucy5pc3N1ZWRfYXQgKyB0b2tlbnMucmVmcmVzaF9leHBpcmVzX2luO1xuICAgIHJldHVybiBub3cgPj0gZXhwaXJlc0F0O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCBhY2Nlc3MgdG9rZW4sIHJlZnJlc2hpbmcgaWYgbmVjZXNzYXJ5XG4gICAqL1xuICBhc3luYyBnZXRWYWxpZFRva2VuKCkge1xuICAgIGNvbnN0IHRva2VucyA9IHRoaXMuYXV0aFN0YXRlLnRva2VucztcbiAgICBpZiAoIXRva2Vucykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0FjY2Vzc1Rva2VuRXhwaXJlZCgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdTI3MDUgQWNjZXNzIHRva2VuIGlzIHN0aWxsIHZhbGlkXCIpO1xuICAgICAgcmV0dXJuIHRva2Vucy5hY2Nlc3NfdG9rZW47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiXFx1MjNGMCBBY2Nlc3MgdG9rZW4gZXhwaXJlZCwgYXR0ZW1wdGluZyByZWZyZXNoLi4uXCIpO1xuICAgIGlmICh0aGlzLmlzUmVmcmVzaFRva2VuRXhwaXJlZCgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgUmVmcmVzaCB0b2tlbiBhbHNvIGV4cGlyZWQsIGNsZWFyaW5nIHRva2Vuc1wiKTtcbiAgICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoUmVxdWlyZWQpIHtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFRvQXV0aCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZnJlc2hlZCA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKCk7XG4gICAgaWYgKHJlZnJlc2hlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IFRva2VuIHJlZnJlc2hlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICByZXR1cm4gdGhpcy5hdXRoU3RhdGUudG9rZW5zPy5hY2Nlc3NfdG9rZW4gfHwgbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIFRva2VuIHJlZnJlc2ggZmFpbGVkXCIpO1xuICAgICAgdGhpcy5jbGVhclRva2VucygpO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGhSZXF1aXJlZCkge1xuICAgICAgICB0aGlzLnJlZGlyZWN0VG9BdXRoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGN1cnJlbnQgdXNlciBwcm9maWxlIGZyb20gQVBJXG4gICAqIEdyYWNlZnVsbHkgd2FpdHMgZm9yIGF1dGggaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUgYmVmb3JlIHRocm93aW5nIGVycm9yc1xuICAgKi9cbiAgYXN5bmMgbWUoKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9ySW5pdGlhbGl6YXRpb24oKTtcbiAgICBpZiAodGhpcy5hdXRoU3RhdGUuaXNBdXRoZW50aWNhdGVkICYmIHRoaXMuYXV0aFN0YXRlLnVzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF1dGhTdGF0ZS51c2VyO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYXV0aFN0YXRlLmlzQXV0aGVudGljYXRlZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aFN0YXRlLnVzZXIpIHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuYXV0aFN0YXRlLnVzZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZWplY3QobmV3IEJsaW5rQXV0aEVycm9yKFwiQVVUSF9USU1FT1VUXCIgLyogQVVUSF9USU1FT1VUICovLCBcIkF1dGhlbnRpY2F0aW9uIHRpbWVvdXQgLSBubyB1c2VyIGF2YWlsYWJsZVwiKSk7XG4gICAgICAgIH0sIDVlMyk7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbkF1dGhTdGF0ZUNoYW5nZWQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXRlLnVzZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXNvbHZlKHN0YXRlLnVzZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmlzTG9hZGluZyAmJiAhc3RhdGUuaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua0F1dGhFcnJvcihcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLCBcIk5vdCBhdXRoZW50aWNhdGVkXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCB0b2tlbiA9IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJUT0tFTl9FWFBJUkVEXCIgLyogVE9LRU5fRVhQSVJFRCAqLywgXCJObyBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL21lYCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICBjb25zdCByZWZyZXNoZWQgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgICAgICAgIGlmIChyZWZyZXNoZWQpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRUb2tlbigpO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJldHJ5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL21lYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXRyeVJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEYXRhID0gYXdhaXQgcmV0cnlSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcjIgPSByZXRyeURhdGEudXNlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF1dGhTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAuLi50aGlzLmF1dGhTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHVzZXIyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXIyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0aFJlcXVpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0VG9BdXRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBmZXRjaCB1c2VyOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgIHRoaXMudXBkYXRlQXV0aFN0YXRlKHtcbiAgICAgICAgLi4udGhpcy5hdXRoU3RhdGUsXG4gICAgICAgIHVzZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sIGBOZXR3b3JrIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTaWduIHVwIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIChoZWFkbGVzcyBtb2RlKVxuICAgKi9cbiAgYXN5bmMgc2lnblVwKGRhdGEpIHtcbiAgICBpZiAodGhpcy5hdXRoQ29uZmlnLm1vZGUgIT09IFwiaGVhZGxlc3NcIikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiSU5WQUxJRF9DUkVERU5USUFMU1wiIC8qIElOVkFMSURfQ1JFREVOVElBTFMgKi8sIFwic2lnblVwIGlzIG9ubHkgYXZhaWxhYmxlIGluIGhlYWRsZXNzIG1vZGVcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvc2lnbnVwYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5wcm9qZWN0SWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiU2lnbiB1cCBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh7XG4gICAgICAgIGFjY2Vzc190b2tlbjogcmVzdWx0LmFjY2Vzc190b2tlbixcbiAgICAgICAgcmVmcmVzaF90b2tlbjogcmVzdWx0LnJlZnJlc2hfdG9rZW4sXG4gICAgICAgIHRva2VuX3R5cGU6IHJlc3VsdC50b2tlbl90eXBlLFxuICAgICAgICBleHBpcmVzX2luOiByZXN1bHQuZXhwaXJlc19pbixcbiAgICAgICAgcmVmcmVzaF9leHBpcmVzX2luOiByZXN1bHQucmVmcmVzaF9leHBpcmVzX2luXG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHJldHVybiByZXN1bHQudXNlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gaW4gd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgKGhlYWRsZXNzIG1vZGUpXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoRW1haWwoZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgaWYgKHRoaXMuYXV0aENvbmZpZy5tb2RlICE9PSBcImhlYWRsZXNzXCIpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLCBcInNpZ25JbldpdGhFbWFpbCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBoZWFkbGVzcyBtb2RlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3NpZ25pbi9lbWFpbGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuY29uZmlnLnByb2plY3RJZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRhdGEuZXJyb3IgfHwgXCJTaWduIGluIGZhaWxlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0VG9rZW5zKHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiByZXN1bHQuYWNjZXNzX3Rva2VuLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiByZXN1bHQucmVmcmVzaF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZTogcmVzdWx0LnRva2VuX3R5cGUsXG4gICAgICAgIGV4cGlyZXNfaW46IHJlc3VsdC5leHBpcmVzX2luLFxuICAgICAgICByZWZyZXNoX2V4cGlyZXNfaW46IHJlc3VsdC5yZWZyZXNoX2V4cGlyZXNfaW5cbiAgICAgIH0sIHRydWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdC51c2VyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLCBgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2lnbiBpbiB3aXRoIEdvb2dsZSAoaGVhZGxlc3MgbW9kZSlcbiAgICogXG4gICAqICoqVW5pdmVyc2FsIE9BdXRoKiogLSBXb3JrcyBvbiBib3RoIFdlYiBhbmQgUmVhY3QgTmF0aXZlIVxuICAgKiBcbiAgICogT24gUmVhY3QgTmF0aXZlLCByZXF1aXJlcyBgd2ViQnJvd3NlcmAgdG8gYmUgY29uZmlndXJlZCBpbiBjbGllbnQ6XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgYmxpbmsgPSBjcmVhdGVDbGllbnQoe1xuICAgKiAgIGF1dGg6IHsgbW9kZTogJ2hlYWRsZXNzJywgd2ViQnJvd3NlcjogV2ViQnJvd3NlciB9XG4gICAqIH0pXG4gICAqIGF3YWl0IGJsaW5rLmF1dGguc2lnbkluV2l0aEdvb2dsZSgpIC8vIFdvcmtzIG9uIGJvdGggcGxhdGZvcm1zIVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhHb29nbGUob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmF1dGhDb25maWcubW9kZSAhPT0gXCJoZWFkbGVzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLywgXCJzaWduSW5XaXRoR29vZ2xlIGlzIG9ubHkgYXZhaWxhYmxlIGluIGhlYWRsZXNzIG1vZGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25JbldpdGhQcm92aWRlcihcImdvb2dsZVwiLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiBpbiB3aXRoIEdpdEh1YiAoaGVhZGxlc3MgbW9kZSlcbiAgICogXG4gICAqICoqVW5pdmVyc2FsIE9BdXRoKiogLSBXb3JrcyBvbiBib3RoIFdlYiBhbmQgUmVhY3QgTmF0aXZlIVxuICAgKiBTZWUgc2lnbkluV2l0aEdvb2dsZSgpIGZvciBzZXR1cCBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoR2l0SHViKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5hdXRoQ29uZmlnLm1vZGUgIT09IFwiaGVhZGxlc3NcIikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiSU5WQUxJRF9DUkVERU5USUFMU1wiIC8qIElOVkFMSURfQ1JFREVOVElBTFMgKi8sIFwic2lnbkluV2l0aEdpdEh1YiBpcyBvbmx5IGF2YWlsYWJsZSBpbiBoZWFkbGVzcyBtb2RlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduSW5XaXRoUHJvdmlkZXIoXCJnaXRodWJcIiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gaW4gd2l0aCBBcHBsZSAoaGVhZGxlc3MgbW9kZSlcbiAgICogXG4gICAqICoqVW5pdmVyc2FsIE9BdXRoKiogLSBXb3JrcyBvbiBib3RoIFdlYiBhbmQgUmVhY3QgTmF0aXZlIVxuICAgKiBTZWUgc2lnbkluV2l0aEdvb2dsZSgpIGZvciBzZXR1cCBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoQXBwbGUob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmF1dGhDb25maWcubW9kZSAhPT0gXCJoZWFkbGVzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLywgXCJzaWduSW5XaXRoQXBwbGUgaXMgb25seSBhdmFpbGFibGUgaW4gaGVhZGxlc3MgbW9kZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnbkluV2l0aFByb3ZpZGVyKFwiYXBwbGVcIiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gaW4gd2l0aCBNaWNyb3NvZnQgKGhlYWRsZXNzIG1vZGUpXG4gICAqIFxuICAgKiAqKlVuaXZlcnNhbCBPQXV0aCoqIC0gV29ya3Mgb24gYm90aCBXZWIgYW5kIFJlYWN0IE5hdGl2ZSFcbiAgICogU2VlIHNpZ25JbldpdGhHb29nbGUoKSBmb3Igc2V0dXAgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aE1pY3Jvc29mdChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuYXV0aENvbmZpZy5tb2RlICE9PSBcImhlYWRsZXNzXCIpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLCBcInNpZ25JbldpdGhNaWNyb3NvZnQgaXMgb25seSBhdmFpbGFibGUgaW4gaGVhZGxlc3MgbW9kZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnbkluV2l0aFByb3ZpZGVyKFwibWljcm9zb2Z0XCIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZSBPQXV0aCBmb3IgbW9iaWxlIHdpdGhvdXQgZGVlcCBsaW5raW5nIChleHBvLXdlYi1icm93c2VyIHBhdHRlcm4pXG4gICAqIFxuICAgKiBUaGlzIG1ldGhvZDpcbiAgICogMS4gR2VuZXJhdGVzIGEgdW5pcXVlIHNlc3Npb24gSURcbiAgICogMi4gUmV0dXJucyBPQXV0aCBVUkwgd2l0aCBzZXNzaW9uIHBhcmFtZXRlclxuICAgKiAzLiBBcHAgb3BlbnMgVVJMIGluIGV4cG8td2ViLWJyb3dzZXJcbiAgICogNC4gQXBwIHBvbGxzIGNoZWNrTW9iaWxlT0F1dGhTZXNzaW9uKCkgdW50aWwgY29tcGxldGVcbiAgICogXG4gICAqIEBwYXJhbSBwcm92aWRlciAtIE9BdXRoIHByb3ZpZGVyIChnb29nbGUsIGdpdGh1YiwgYXBwbGUsIGV0Yy4pXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICogQHJldHVybnMgU2Vzc2lvbiBJRCBhbmQgT0F1dGggVVJMXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZWFjdCBOYXRpdmUgd2l0aCBleHBvLXdlYi1icm93c2VyXG4gICAqIGltcG9ydCAqIGFzIFdlYkJyb3dzZXIgZnJvbSAnZXhwby13ZWItYnJvd3Nlcic7XG4gICAqIFxuICAgKiBjb25zdCB7IHNlc3Npb25JZCwgYXV0aFVybCB9ID0gYXdhaXQgYmxpbmsuYXV0aC5pbml0aWF0ZU1vYmlsZU9BdXRoKCdnb29nbGUnKTtcbiAgICogXG4gICAqIC8vIE9wZW4gYnJvd3NlclxuICAgKiBhd2FpdCBXZWJCcm93c2VyLm9wZW5BdXRoU2Vzc2lvbkFzeW5jKGF1dGhVcmwpO1xuICAgKiBcbiAgICogLy8gUG9sbCBmb3IgY29tcGxldGlvblxuICAgKiBjb25zdCB1c2VyID0gYXdhaXQgYmxpbmsuYXV0aC5wb2xsTW9iaWxlT0F1dGhTZXNzaW9uKHNlc3Npb25JZCk7XG4gICAqIGNvbnNvbGUubG9nKCdBdXRoZW50aWNhdGVkOicsIHVzZXIuZW1haWwpO1xuICAgKi9cbiAgYXN5bmMgaW5pdGlhdGVNb2JpbGVPQXV0aChwcm92aWRlciwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLmF1dGhDb25maWcubW9kZSAhPT0gXCJoZWFkbGVzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgIFwiSU5WQUxJRF9DUkVERU5USUFMU1wiIC8qIElOVkFMSURfQ1JFREVOVElBTFMgKi8sXG4gICAgICAgIFwiaW5pdGlhdGVNb2JpbGVPQXV0aCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBoZWFkbGVzcyBtb2RlXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNlc3Npb25JZCA9IHRoaXMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgICBjb25zdCBhdXRoVXJsID0gbmV3IFVSTChcIi9hdXRoXCIsIHRoaXMuYXV0aFVybCk7XG4gICAgYXV0aFVybC5zZWFyY2hQYXJhbXMuc2V0KFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgIGF1dGhVcmwuc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RfaWRcIiwgdGhpcy5jb25maWcucHJvamVjdElkKTtcbiAgICBhdXRoVXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJtb2RlXCIsIFwibW9iaWxlLXNlc3Npb25cIik7XG4gICAgYXV0aFVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2Vzc2lvbl9pZFwiLCBzZXNzaW9uSWQpO1xuICAgIGlmIChvcHRpb25zPy5tZXRhZGF0YSkge1xuICAgICAgYXV0aFVybC5zZWFyY2hQYXJhbXMuc2V0KFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5tZXRhZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2Vzc2lvbklkLFxuICAgICAgYXV0aFVybDogYXV0aFVybC50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgbW9iaWxlIE9BdXRoIHNlc3Npb24gc3RhdHVzIChzaW5nbGUgY2hlY2spXG4gICAqIFxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gU2Vzc2lvbiBJRCBmcm9tIGluaXRpYXRlTW9iaWxlT0F1dGhcbiAgICogQHJldHVybnMgVG9rZW5zIGlmIHNlc3Npb24gaXMgY29tcGxldGUsIG51bGwgaWYgc3RpbGwgcGVuZGluZ1xuICAgKi9cbiAgYXN5bmMgY2hlY2tNb2JpbGVPQXV0aFNlc3Npb24oc2Vzc2lvbklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9tb2JpbGUtc2Vzc2lvbi8ke3Nlc3Npb25JZH1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICAgIGVycm9yQ29kZSxcbiAgICAgICAgICBlcnJvckRhdGEuZXJyb3IgfHwgXCJGYWlsZWQgdG8gY2hlY2sgT0F1dGggc2Vzc2lvblwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiBkYXRhLmFjY2Vzc190b2tlbixcbiAgICAgICAgcmVmcmVzaF90b2tlbjogZGF0YS5yZWZyZXNoX3Rva2VuLFxuICAgICAgICB0b2tlbl90eXBlOiBkYXRhLnRva2VuX3R5cGUgfHwgXCJCZWFyZXJcIixcbiAgICAgICAgZXhwaXJlc19pbjogZGF0YS5leHBpcmVzX2luIHx8IDM2MDAsXG4gICAgICAgIHJlZnJlc2hfZXhwaXJlc19pbjogZGF0YS5yZWZyZXNoX2V4cGlyZXNfaW5cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICBcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLFxuICAgICAgICBgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQb2xsIG1vYmlsZSBPQXV0aCBzZXNzaW9uIHVudGlsIGNvbXBsZXRlIChjb252ZW5pZW5jZSBtZXRob2QpXG4gICAqIFxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gU2Vzc2lvbiBJRCBmcm9tIGluaXRpYXRlTW9iaWxlT0F1dGhcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2xsaW5nIG9wdGlvbnNcbiAgICogQHJldHVybnMgQXV0aGVudGljYXRlZCB1c2VyXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCB7IHNlc3Npb25JZCwgYXV0aFVybCB9ID0gYXdhaXQgYmxpbmsuYXV0aC5pbml0aWF0ZU1vYmlsZU9BdXRoKCdnb29nbGUnKTtcbiAgICogYXdhaXQgV2ViQnJvd3Nlci5vcGVuQXV0aFNlc3Npb25Bc3luYyhhdXRoVXJsKTtcbiAgICogY29uc3QgdXNlciA9IGF3YWl0IGJsaW5rLmF1dGgucG9sbE1vYmlsZU9BdXRoU2Vzc2lvbihzZXNzaW9uSWQsIHtcbiAgICogICBtYXhBdHRlbXB0czogNjAsXG4gICAqICAgaW50ZXJ2YWxNczogMTAwMFxuICAgKiB9KTtcbiAgICovXG4gIGFzeW5jIHBvbGxNb2JpbGVPQXV0aFNlc3Npb24oc2Vzc2lvbklkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSBvcHRpb25zPy5tYXhBdHRlbXB0cyB8fCA2MDtcbiAgICBjb25zdCBpbnRlcnZhbE1zID0gb3B0aW9ucz8uaW50ZXJ2YWxNcyB8fCAxZTM7XG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCB0aGlzLmNoZWNrTW9iaWxlT0F1dGhTZXNzaW9uKHNlc3Npb25JZCk7XG4gICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0VG9rZW5zKHRva2VucywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhTdGF0ZS51c2VyO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWxNcykpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICBcIkFVVEhfVElNRU9VVFwiIC8qIEFVVEhfVElNRU9VVCAqLyxcbiAgICAgIFwiTW9iaWxlIE9BdXRoIHNlc3Npb24gdGltZWQgb3V0XCJcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIGluIHdpdGggT0F1dGggcHJvdmlkZXIgdXNpbmcgZXhwby13ZWItYnJvd3NlciAoUmVhY3QgTmF0aXZlKVxuICAgKiBcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGhhbmRsZXMgdGhlIGVudGlyZSBmbG93OlxuICAgKiAxLiBJbml0aWF0ZXMgbW9iaWxlIE9BdXRoIHNlc3Npb25cbiAgICogMi4gUmV0dXJucyBhdXRoIFVSTCB0byBvcGVuIGluIFdlYkJyb3dzZXJcbiAgICogMy4gUHJvdmlkZXMgcG9sbGluZyBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIGJyb3dzZXIgb3BlbnNcbiAgICogXG4gICAqIEBwYXJhbSBwcm92aWRlciAtIE9BdXRoIHByb3ZpZGVyXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGF1dGhVcmwgYW5kIGF1dGhlbnRpY2F0ZSBmdW5jdGlvblxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0ICogYXMgV2ViQnJvd3NlciBmcm9tICdleHBvLXdlYi1icm93c2VyJztcbiAgICogXG4gICAqIGNvbnN0IHsgYXV0aFVybCwgYXV0aGVudGljYXRlIH0gPSBhd2FpdCBibGluay5hdXRoLnNpZ25JbldpdGhQcm92aWRlck1vYmlsZSgnZ29vZ2xlJyk7XG4gICAqIFxuICAgKiAvLyBPcGVuIGJyb3dzZXJcbiAgICogYXdhaXQgV2ViQnJvd3Nlci5vcGVuQXV0aFNlc3Npb25Bc3luYyhhdXRoVXJsKTtcbiAgICogXG4gICAqIC8vIFdhaXQgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICAqIGNvbnN0IHVzZXIgPSBhd2FpdCBhdXRoZW50aWNhdGUoKTtcbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhQcm92aWRlck1vYmlsZShwcm92aWRlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBhdXRoVXJsIH0gPSBhd2FpdCB0aGlzLmluaXRpYXRlTW9iaWxlT0F1dGgocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICBhdXRoVXJsLFxuICAgICAgYXV0aGVudGljYXRlOiAoKSA9PiB0aGlzLnBvbGxNb2JpbGVPQXV0aFNlc3Npb24oc2Vzc2lvbklkLCB7XG4gICAgICAgIG1heEF0dGVtcHRzOiA2MCxcbiAgICAgICAgaW50ZXJ2YWxNczogMWUzXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVuaXZlcnNhbCBPQXV0aCBmbG93IHVzaW5nIHNlc3Npb24tYmFzZWQgYXV0aGVudGljYXRpb24gKGludGVybmFsKVxuICAgKiBXb3JrcyBvbiBBTEwgcGxhdGZvcm1zOiBXZWIsIGlPUywgQW5kcm9pZFxuICAgKiBVc2VzIGV4cG8td2ViLWJyb3dzZXIgdG8gb3BlbiBhdXRoIFVSTCBhbmQgcG9sbHMgZm9yIGNvbXBsZXRpb25cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhQcm92aWRlclVuaXZlcnNhbChwcm92aWRlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHdlYkJyb3dzZXIgPSB0aGlzLmF1dGhDb25maWcud2ViQnJvd3NlcjtcbiAgICBpZiAoIXdlYkJyb3dzZXIpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcbiAgICAgICAgXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLyxcbiAgICAgICAgXCJ3ZWJCcm93c2VyIG1vZHVsZSBpcyByZXF1aXJlZCBmb3IgdW5pdmVyc2FsIE9BdXRoIGZsb3dcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgeyBzZXNzaW9uSWQsIGF1dGhVcmwgfSA9IGF3YWl0IHRoaXMuaW5pdGlhdGVNb2JpbGVPQXV0aChwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgY29uc29sZS5sb2coXCJcXHV7MUY1MTB9IE9wZW5pbmcgT0F1dGggYnJvd3NlciBmb3JcIiwgcHJvdmlkZXIpO1xuICAgIGNvbnN0IGJyb3dzZXJQcm9taXNlID0gd2ViQnJvd3Nlci5vcGVuQXV0aFNlc3Npb25Bc3luYyhhdXRoVXJsKTtcbiAgICBjb25zdCByYWNlUmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgIGJyb3dzZXJQcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4gKHsgY2xvc2VkOiB0cnVlLCByZXN1bHQgfSkpLmNhdGNoKChlcnIpID0+ICh7IGNsb3NlZDogdHJ1ZSwgZXJyb3I6IGVyciB9KSksXG4gICAgICBuZXcgUHJvbWlzZShcbiAgICAgICAgKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh7IGNsb3NlZDogZmFsc2UgfSksIDVlMylcbiAgICAgIClcbiAgICBdKTtcbiAgICBpZiAocmFjZVJlc3VsdC5jbG9zZWQpIHtcbiAgICAgIGlmIChcInJlc3VsdFwiIGluIHJhY2VSZXN1bHQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY1MTB9IEJyb3dzZXIgY2xvc2VkIHdpdGggcmVzdWx0OlwiLCByYWNlUmVzdWx0LnJlc3VsdC50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTEwfSBCcm93c2VyIGNsb3NlZCB3aXRoIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUxMH0gQnJvd3NlciBzdGlsbCBvcGVuIChuZXcgdGFiL3N0dWNrIHBvcHVwKSwgc3RhcnRpbmcgdG8gcG9sbC4uLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMucG9sbE1vYmlsZU9BdXRoU2Vzc2lvbihzZXNzaW9uSWQsIHtcbiAgICAgIG1heEF0dGVtcHRzOiAxMjAsXG4gICAgICAvLyA2MCBzZWNvbmRzIChnaXZlIHVzZXIgdGltZSB0byBjb21wbGV0ZSBhdXRoKVxuICAgICAgaW50ZXJ2YWxNczogNTAwXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coXCJcXHUyNzA1IE9BdXRoIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyaWMgcHJvdmlkZXIgc2lnbi1pbiBtZXRob2QgKGhlYWRsZXNzIG1vZGUpXG4gICAqIFxuICAgKiAqKlVuaXZlcnNhbCBPQXV0aCoqIC0gV29ya3Mgc2VhbWxlc3NseSBvbiBib3RoIFdlYiBhbmQgUmVhY3QgTmF0aXZlIVxuICAgKiBcbiAgICogV2hlbiBgd2ViQnJvd3NlcmAgaXMgY29uZmlndXJlZCBpbiB0aGUgY2xpZW50LCB0aGlzIG1ldGhvZCBhdXRvbWF0aWNhbGx5XG4gICAqIHVzZXMgdGhlIHNlc3Npb24tYmFzZWQgT0F1dGggZmxvdyB0aGF0IHdvcmtzIG9uIEFMTCBwbGF0Zm9ybXMuXG4gICAqIFxuICAgKiAqKlVuaXZlcnNhbCBTZXR1cCAoY29uZmlndXJlIG9uY2UsIHdvcmtzIGV2ZXJ5d2hlcmUpOioqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0ICogYXMgV2ViQnJvd3NlciBmcm9tICdleHBvLXdlYi1icm93c2VyJ1xuICAgKiBpbXBvcnQgQXN5bmNTdG9yYWdlIGZyb20gJ0ByZWFjdC1uYXRpdmUtYXN5bmMtc3RvcmFnZS9hc3luYy1zdG9yYWdlJ1xuICAgKiBcbiAgICogY29uc3QgYmxpbmsgPSBjcmVhdGVDbGllbnQoe1xuICAgKiAgIHByb2plY3RJZDogJ3lvdXItcHJvamVjdCcsXG4gICAqICAgYXV0aDoge1xuICAgKiAgICAgbW9kZTogJ2hlYWRsZXNzJyxcbiAgICogICAgIHdlYkJyb3dzZXI6IFdlYkJyb3dzZXIgIC8vIFBhc3MgdGhlIG1vZHVsZSBoZXJlXG4gICAqICAgfSxcbiAgICogICBzdG9yYWdlOiBuZXcgQXN5bmNTdG9yYWdlQWRhcHRlcihBc3luY1N0b3JhZ2UpXG4gICAqIH0pXG4gICAqIFxuICAgKiAvLyBOb3cgdGhpcyB3b3JrcyBvbiBBTEwgcGxhdGZvcm1zIC0gbm8gcGxhdGZvcm0gY2hlY2tzIG5lZWRlZCFcbiAgICogY29uc3QgdXNlciA9IGF3YWl0IGJsaW5rLmF1dGguc2lnbkluV2l0aEdvb2dsZSgpXG4gICAqIGBgYFxuICAgKiBcbiAgICogQHBhcmFtIHByb3ZpZGVyIC0gT0F1dGggcHJvdmlkZXIgKGdvb2dsZSwgZ2l0aHViLCBhcHBsZSwgZXRjLilcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCByZWRpcmVjdCBVUkwgYW5kIG1ldGFkYXRhXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aFByb3ZpZGVyKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuYXV0aENvbmZpZy5tb2RlICE9PSBcImhlYWRsZXNzXCIpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLCBcInNpZ25JbldpdGhQcm92aWRlciBpcyBvbmx5IGF2YWlsYWJsZSBpbiBoZWFkbGVzcyBtb2RlXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdXRoQ29uZmlnLndlYkJyb3dzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25JbldpdGhQcm92aWRlclVuaXZlcnNhbChwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlMigpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgIFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sXG4gICAgICAgICdSZWFjdCBOYXRpdmUgT0F1dGggcmVxdWlyZXMgd2ViQnJvd3NlciBpbiBjb25maWchXFxuXFxuaW1wb3J0ICogYXMgV2ViQnJvd3NlciBmcm9tIFwiZXhwby13ZWItYnJvd3NlclwiO1xcblxcbmNvbnN0IGJsaW5rID0gY3JlYXRlQ2xpZW50KHtcXG4gIHByb2plY3RJZDogXCJ5b3VyLXByb2plY3RcIixcXG4gIGF1dGg6IHtcXG4gICAgbW9kZTogXCJoZWFkbGVzc1wiLFxcbiAgICB3ZWJCcm93c2VyOiBXZWJCcm93c2VyXFxuICB9XFxufSlcXG5cXG5hd2FpdCBibGluay5hdXRoLnNpZ25JbldpdGhHb29nbGUoKSAvLyBXb3JrcyBvbiBhbGwgcGxhdGZvcm1zISdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaGFzV2luZG93KCkpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLCBcInNpZ25JbldpdGhQcm92aWRlciByZXF1aXJlcyBhIGJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFByZWZlclJlZGlyZWN0ID0gaXNXZWIgJiYgdGhpcy5pc0lmcmFtZSB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jcm9zc09yaWdpbklzb2xhdGVkID09PSB0cnVlO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZW5lcmF0ZVN0YXRlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25TdG9yYWdlID0gZ2V0U2Vzc2lvblN0b3JhZ2UoKTtcbiAgICAgIGlmIChzZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiYmxpbmtfb2F1dGhfc3RhdGVcIiwgc3RhdGUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdFVybCA9IG9wdGlvbnM/LnJlZGlyZWN0VXJsIHx8IGdldExvY2F0aW9uT3JpZ2luKCkgfHwgXCJcIjtcbiAgICBjb25zdCBidWlsZEF1dGhVcmwgPSAobW9kZSkgPT4ge1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChcIi9hdXRoXCIsIHRoaXMuYXV0aFVybCk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicHJvamVjdF9pZFwiLCB0aGlzLmNvbmZpZy5wcm9qZWN0SWQpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJzdGF0ZVwiLCBzdGF0ZSk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIm1vZGVcIiwgbW9kZSk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJlZGlyZWN0X3VybFwiLCByZWRpcmVjdFVybCk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIm9wZW5lcl9vcmlnaW5cIiwgZ2V0TG9jYXRpb25PcmlnaW4oKSB8fCBcIlwiKTtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICBpZiAoc2hvdWxkUHJlZmVyUmVkaXJlY3QpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYnVpbGRBdXRoVXJsKFwicmVkaXJlY3RcIikudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHBvcHVwVXJsID0gYnVpbGRBdXRoVXJsKFwicG9wdXBcIik7XG4gICAgICBjb25zdCBwb3B1cCA9IHdpbmRvdy5vcGVuKFxuICAgICAgICBwb3B1cFVybC50b1N0cmluZygpLFxuICAgICAgICBcImJsaW5rLWF1dGhcIixcbiAgICAgICAgXCJ3aWR0aD01MDAsaGVpZ2h0PTYwMCxzY3JvbGxiYXJzPXllcyxyZXNpemFibGU9eWVzXCJcbiAgICAgICk7XG4gICAgICBpZiAoIXBvcHVwKSB7XG4gICAgICAgIHJlamVjdChuZXcgQmxpbmtBdXRoRXJyb3IoXCJQT1BVUF9DQU5DRUxFRFwiIC8qIFBPUFVQX0NBTkNFTEVEICovLCBcIlBvcHVwIHdhcyBibG9ja2VkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVvdXRJZDtcbiAgICAgIGxldCBjbG9zZWRJbnRlcnZhbElkO1xuICAgICAgbGV0IGNsZWFuZWRVcCA9IGZhbHNlO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNsZWFuZWRVcCkgcmV0dXJuO1xuICAgICAgICBjbGVhbmVkVXAgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgaWYgKGNsb3NlZEludGVydmFsSWQpIGNsZWFySW50ZXJ2YWwoY2xvc2VkSW50ZXJ2YWxJZCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtZXNzYWdlTGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgYWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGF1dGhPcmlnaW4gPSBuZXcgVVJMKHRoaXMuYXV0aFVybCkub3JpZ2luO1xuICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gPT09IGF1dGhPcmlnaW4pIGFsbG93ZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luID09PSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiIHx8IGV2ZW50Lm9yaWdpbiA9PT0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDFcIikgYWxsb3dlZCA9IHRydWU7XG4gICAgICAgIGlmICghYWxsb3dlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJCTElOS19BVVRIX1RPS0VOU1wiKSB7XG4gICAgICAgICAgY29uc3QgeyBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIHRva2VuX3R5cGUsIGV4cGlyZXNfaW4sIHJlZnJlc2hfZXhwaXJlc19pbiwgcHJvamVjdElkLCBzdGF0ZTogcmV0dXJuZWRTdGF0ZSB9ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblN0b3JhZ2UgPSBnZXRTZXNzaW9uU3RvcmFnZSgpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBzZXNzaW9uU3RvcmFnZT8uZ2V0SXRlbShcImJsaW5rX29hdXRoX3N0YXRlXCIpO1xuICAgICAgICAgICAgaWYgKHJldHVybmVkU3RhdGUgJiYgZXhwZWN0ZWQgJiYgcmV0dXJuZWRTdGF0ZSAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua0F1dGhFcnJvcihcIlZFUklGSUNBVElPTl9GQUlMRURcIiAvKiBWRVJJRklDQVRJT05fRkFJTEVEICovLCBcIlN0YXRlIG1pc21hdGNoXCIpKTtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtZXNzYWdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICBwb3B1cC5jbG9zZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHRoaXMuY29uZmlnLnByb2plY3RJZCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua0F1dGhFcnJvcihcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLCBcIlByb2plY3QgSUQgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFRva2Vucyh7XG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgICAgICAgIGV4cGlyZXNfaW4sXG4gICAgICAgICAgICByZWZyZXNoX2V4cGlyZXNfaW5cbiAgICAgICAgICB9LCB0cnVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5hdXRoU3RhdGUudXNlcik7XG4gICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIkJMSU5LX0FVVEhfRVJST1JcIikge1xuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGV2ZW50LmRhdGEuY29kZSk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBCbGlua0F1dGhFcnJvcihlcnJvckNvZGUsIGV2ZW50LmRhdGEubWVzc2FnZSB8fCBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIHBvcHVwLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAocG9wdXAub3BlbmVyID09PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGJ1aWxkQXV0aFVybChcInJlZGlyZWN0XCIpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGlmICghcG9wdXAuY2xvc2VkKSB7XG4gICAgICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QobmV3IEJsaW5rQXV0aEVycm9yKFwiQVVUSF9USU1FT1VUXCIgLyogQVVUSF9USU1FT1VUICovLCBcIkF1dGhlbnRpY2F0aW9uIHRpbWVkIG91dFwiKSk7XG4gICAgICB9LCAzZTUpO1xuICAgICAgY2xvc2VkSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHBvcHVwLmNsb3NlZCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICByZWplY3QobmV3IEJsaW5rQXV0aEVycm9yKFwiUE9QVVBfQ0FOQ0VMRURcIiAvKiBQT1BVUF9DQU5DRUxFRCAqLywgXCJBdXRoZW50aWNhdGlvbiB3YXMgY2FuY2VsZWRcIikpO1xuICAgICAgICB9XG4gICAgICB9LCAxZTMpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHBhc3N3b3JkIHJlc2V0IHRva2VuIChmb3IgY3VzdG9tIGVtYWlsIGRlbGl2ZXJ5KVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVQYXNzd29yZFJlc2V0VG9rZW4oZW1haWwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3Bhc3N3b3JkL3Jlc2V0L2dlbmVyYXRlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcucHJvamVjdElkXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShlcnJvckRhdGEuY29kZSk7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcbiAgICAgICAgICBlcnJvckNvZGUsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIGdlbmVyYXRlIHBhc3N3b3JkIHJlc2V0IHRva2VuXCIsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICBcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLFxuICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSBwYXNzd29yZCByZXNldCB0b2tlblwiLFxuICAgICAgICBcIk5ldHdvcmsgZXJyb3Igb2NjdXJyZWRcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgcGFzc3dvcmQgcmVzZXQgZW1haWwgKHVzaW5nIEJsaW5rIGRlZmF1bHQgZW1haWwgc2VydmljZSlcbiAgICovXG4gIGFzeW5jIHNlbmRQYXNzd29yZFJlc2V0RW1haWwoZW1haWwsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3Bhc3N3b3JkL3Jlc2V0YCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcucHJvamVjdElkLFxuICAgICAgICAgIHJlZGlyZWN0VXJsOiBvcHRpb25zPy5yZWRpcmVjdFVybFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRhdGEuZXJyb3IgfHwgXCJGYWlsZWQgdG8gc2VuZCBwYXNzd29yZCByZXNldCBlbWFpbFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpcm0gcGFzc3dvcmQgcmVzZXQgd2l0aCB0b2tlblxuICAgKi9cbiAgYXN5bmMgY29uZmlybVBhc3N3b3JkUmVzZXQodG9rZW4sIG5ld1Bhc3N3b3JkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9wYXNzd29yZC9yZXNldC9jb25maXJtYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIHBhc3N3b3JkOiBuZXdQYXNzd29yZCxcbiAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuY29uZmlnLnByb2plY3RJZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRhdGEuZXJyb3IgfHwgXCJGYWlsZWQgdG8gcmVzZXQgcGFzc3dvcmRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sIGBOZXR3b3JrIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2UgcGFzc3dvcmQgKHJlcXVpcmVzIGN1cnJlbnQgYXV0aGVudGljYXRpb24pXG4gICAqL1xuICBhc3luYyBjaGFuZ2VQYXNzd29yZChvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQpIHtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuZ2V0VmFsaWRUb2tlbigpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIlRPS0VOX0VYUElSRURcIiAvKiBUT0tFTl9FWFBJUkVEICovLCBcIk5vIGFjY2VzcyB0b2tlbiBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvcGFzc3dvcmQvY2hhbmdlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBvbGRQYXNzd29yZCxcbiAgICAgICAgICBuZXdQYXNzd29yZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRhdGEuZXJyb3IgfHwgXCJGYWlsZWQgdG8gY2hhbmdlIHBhc3N3b3JkXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLCBgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgZW1haWwgdmVyaWZpY2F0aW9uIHRva2VuIChmb3IgY3VzdG9tIGVtYWlsIGRlbGl2ZXJ5KVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVFbWFpbFZlcmlmaWNhdGlvblRva2VuKCkge1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5nZXRWYWxpZFRva2VuKCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiVE9LRU5fRVhQSVJFRFwiIC8qIFRPS0VOX0VYUElSRUQgKi8sIFwiTm8gYWNjZXNzIHRva2VuIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9lbWFpbC92ZXJpZnkvZ2VuZXJhdGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgICAgZXJyb3JDb2RlLFxuICAgICAgICAgIGVycm9yRGF0YS5lcnJvciB8fCBcIkZhaWxlZCB0byBnZW5lcmF0ZSBlbWFpbCB2ZXJpZmljYXRpb24gdG9rZW5cIixcbiAgICAgICAgICBlcnJvckRhdGEuZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgIFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sXG4gICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIGVtYWlsIHZlcmlmaWNhdGlvbiB0b2tlblwiLFxuICAgICAgICBcIk5ldHdvcmsgZXJyb3Igb2NjdXJyZWRcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgZW1haWwgdmVyaWZpY2F0aW9uICh1c2luZyBCbGluayBkZWZhdWx0IGVtYWlsIHNlcnZpY2UpXG4gICAqL1xuICBhc3luYyBzZW5kRW1haWxWZXJpZmljYXRpb24oKSB7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFZhbGlkVG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJUT0tFTl9FWFBJUkVEXCIgLyogVE9LRU5fRVhQSVJFRCAqLywgXCJObyBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL2VtYWlsL3ZlcmlmeS9zZW5kYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIHNlbmQgdmVyaWZpY2F0aW9uIGVtYWlsXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLCBgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmVyaWZ5IGVtYWlsIHdpdGggdG9rZW5cbiAgICovXG4gIGFzeW5jIHZlcmlmeUVtYWlsKHRva2VuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9lbWFpbC92ZXJpZnlgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5wcm9qZWN0SWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIHZlcmlmeSBlbWFpbFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIG1hZ2ljIGxpbmsgdG9rZW4gKGZvciBjdXN0b20gZW1haWwgZGVsaXZlcnkpXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZU1hZ2ljTGlua1Rva2VuKGVtYWlsLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9zaWduaW4vbWFnaWMvZ2VuZXJhdGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgcmVkaXJlY3RVcmw6IG9wdGlvbnM/LnJlZGlyZWN0VXJsLFxuICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcucHJvamVjdElkXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShlcnJvckRhdGEuY29kZSk7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcbiAgICAgICAgICBlcnJvckNvZGUsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIGdlbmVyYXRlIG1hZ2ljIGxpbmsgdG9rZW5cIixcbiAgICAgICAgICBlcnJvckRhdGEuZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgIFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sXG4gICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIG1hZ2ljIGxpbmsgdG9rZW5cIixcbiAgICAgICAgXCJOZXR3b3JrIGVycm9yIG9jY3VycmVkXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kIG1hZ2ljIGxpbmsgKHVzaW5nIEJsaW5rIGRlZmF1bHQgZW1haWwgc2VydmljZSlcbiAgICovXG4gIGFzeW5jIHNlbmRNYWdpY0xpbmsoZW1haWwsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3NpZ25pbi9tYWdpY2AsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICByZWRpcmVjdFVybDogb3B0aW9ucz8ucmVkaXJlY3RVcmwsXG4gICAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5wcm9qZWN0SWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIHNlbmQgbWFnaWMgbGlua1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmeSBtYWdpYyBsaW5rIChhdXRvbWF0aWMgb24gcmVkaXJlY3QpXG4gICAqL1xuICBhc3luYyB2ZXJpZnlNYWdpY0xpbmsodG9rZW4pIHtcbiAgICBjb25zdCBtYWdpY1Rva2VuID0gdG9rZW4gfHwgdGhpcy5leHRyYWN0TWFnaWNUb2tlbkZyb21VcmwoKTtcbiAgICBpZiAoIW1hZ2ljVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIlZFUklGSUNBVElPTl9GQUlMRURcIiAvKiBWRVJJRklDQVRJT05fRkFJTEVEICovLCBcIk5vIG1hZ2ljIGxpbmsgdG9rZW4gZm91bmRcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvc2lnbmluL21hZ2ljL3ZlcmlmeWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0b2tlbjogbWFnaWNUb2tlbixcbiAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuY29uZmlnLnByb2plY3RJZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRhdGEuZXJyb3IgfHwgXCJNYWdpYyBsaW5rIHZlcmlmaWNhdGlvbiBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh7XG4gICAgICAgIGFjY2Vzc190b2tlbjogcmVzdWx0LmFjY2Vzc190b2tlbixcbiAgICAgICAgcmVmcmVzaF90b2tlbjogcmVzdWx0LnJlZnJlc2hfdG9rZW4sXG4gICAgICAgIHRva2VuX3R5cGU6IHJlc3VsdC50b2tlbl90eXBlLFxuICAgICAgICBleHBpcmVzX2luOiByZXN1bHQuZXhwaXJlc19pbixcbiAgICAgICAgcmVmcmVzaF9leHBpcmVzX2luOiByZXN1bHQucmVmcmVzaF9leHBpcmVzX2luXG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHJldHVybiByZXN1bHQudXNlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhdmFpbGFibGUgcHJvdmlkZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAqL1xuICBhc3luYyBnZXRBdmFpbGFibGVQcm92aWRlcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9wcm92aWRlcnM/cHJvamVjdElkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuY29uZmlnLnByb2plY3RJZCl9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHJldHVybiBbXCJlbWFpbFwiLCBcImdvb2dsZVwiXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4gZGF0YS5wcm92aWRlcnMgfHwgW1wiZW1haWxcIiwgXCJnb29nbGVcIl07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBbXCJlbWFpbFwiLCBcImdvb2dsZVwiXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHVzZXIgaGFzIGEgc3BlY2lmaWMgcm9sZVxuICAgKi9cbiAgaGFzUm9sZShyb2xlKSB7XG4gICAgY29uc3QgdXNlciA9IHRoaXMuYXV0aFN0YXRlLnVzZXI7XG4gICAgaWYgKCF1c2VyIHx8ICF1c2VyLnJvbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm9sZSkpIHtcbiAgICAgIHJldHVybiByb2xlLmluY2x1ZGVzKHVzZXIucm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VyLnJvbGUgPT09IHJvbGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHVzZXIgY2FuIHBlcmZvcm0gYSBzcGVjaWZpYyBhY3Rpb25cbiAgICovXG4gIGNhbihwZXJtaXNzaW9uLCByZXNvdXJjZSkge1xuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmF1dGhTdGF0ZS51c2VyO1xuICAgIGlmICghdXNlciB8fCAhdXNlci5yb2xlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJvbGVzID0gdGhpcy5hdXRoQ29uZmlnLnJvbGVzO1xuICAgIGlmICghcm9sZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgcm9sZUNvbmZpZyA9IHJvbGVzW3VzZXIucm9sZV07XG4gICAgaWYgKCFyb2xlQ29uZmlnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyb2xlQ29uZmlnLnBlcm1pc3Npb25zLmluY2x1ZGVzKFwiKlwiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZ1bGxQZXJtaXNzaW9uID0gcmVzb3VyY2UgPyBgJHtwZXJtaXNzaW9ufS4ke3Jlc291cmNlfWAgOiBwZXJtaXNzaW9uO1xuICAgIGlmIChyb2xlQ29uZmlnLnBlcm1pc3Npb25zLmluY2x1ZGVzKGZ1bGxQZXJtaXNzaW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyb2xlQ29uZmlnLnBlcm1pc3Npb25zLmluY2x1ZGVzKHBlcm1pc3Npb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgaGFzUGVybWlzc2lvbkluUm9sZSA9IChyb2xlTmFtZSkgPT4ge1xuICAgICAgaWYgKHZpc2l0ZWQuaGFzKHJvbGVOYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmlzaXRlZC5hZGQocm9sZU5hbWUpO1xuICAgICAgY29uc3QgcmMgPSByb2xlc1tyb2xlTmFtZV07XG4gICAgICBpZiAoIXJjKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAocmMucGVybWlzc2lvbnMuaW5jbHVkZXMoXCIqXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnN0IGZ1bGxQZXJtaXNzaW9uMiA9IHJlc291cmNlID8gYCR7cGVybWlzc2lvbn0uJHtyZXNvdXJjZX1gIDogcGVybWlzc2lvbjtcbiAgICAgIGlmIChyYy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhmdWxsUGVybWlzc2lvbjIpIHx8IHJjLnBlcm1pc3Npb25zLmluY2x1ZGVzKHBlcm1pc3Npb24pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChyYy5pbmhlcml0KSB7XG4gICAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHJjLmluaGVyaXQpIHtcbiAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbkluUm9sZShwYXJlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgaWYgKGhhc1Blcm1pc3Npb25JblJvbGUodXNlci5yb2xlKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIG91dCAoY2xlYXIgbG9jYWwgdG9rZW5zKVxuICAgKiBOb3RlOiBXaXRoIHN0YXRlbGVzcyB0b2tlbnMsIHRoaXMgb25seSBjbGVhcnMgbG9jYWwgc3RvcmFnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk91dCgpIHtcbiAgICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzaWduT3V0KCkgaW5zdGVhZC4gS2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIGFzeW5jIHJldm9rZUFsbFNlc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25PdXQoKTtcbiAgfVxuICAvKipcbiAgICogUmVjb3ZlciBhdXRoIHN0YXRlIChjbGVhciBjb3JydXB0ZWQgdG9rZW5zIGFuZCByZS1pbml0aWFsaXplKVxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlckF1dGhTdGF0ZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUwNH0gUmVjb3ZlcmluZyBhdXRoIHN0YXRlLi4uXCIpO1xuICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJcXHUyNzA1IEF1dGggc3RhdGUgcmVjb3ZlcnkgY29tcGxldGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB1c2VyIHByb2ZpbGVcbiAgICovXG4gIGFzeW5jIHVwZGF0ZU1lKHVwZGF0ZXMpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJUT0tFTl9FWFBJUkVEXCIgLyogVE9LRU5fRVhQSVJFRCAqLywgXCJObyBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL21lYCwge1xuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVzKVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byB1cGRhdGUgdXNlcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICB0aGlzLnVwZGF0ZUF1dGhTdGF0ZSh7XG4gICAgICAgIC4uLnRoaXMuYXV0aFN0YXRlLFxuICAgICAgICB1c2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLCBgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTWFudWFsbHkgc2V0IHRva2VucyAoZm9yIHNlcnZlci1zaWRlIHVzYWdlKVxuICAgKi9cbiAgYXN5bmMgc2V0VG9rZW4oand0LCBwZXJzaXN0ID0gZmFsc2UpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB7XG4gICAgICBhY2Nlc3NfdG9rZW46IGp3dCxcbiAgICAgIHRva2VuX3R5cGU6IFwiQmVhcmVyXCIsXG4gICAgICBleHBpcmVzX2luOiAxNSAqIDYwXG4gICAgICAvLyBEZWZhdWx0IDE1IG1pbnV0ZXNcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMuc2V0VG9rZW5zKHRva2VucywgcGVyc2lzdCk7XG4gIH1cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHNldCBhdXRoIHNlc3Npb24gZnJvbSB0b2tlbnMgKFJlYWN0IE5hdGl2ZSBkZWVwIGxpbmsgT0F1dGgpXG4gICAqIFxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IHRoZSB1c2VyIHNlc3Npb24gYWZ0ZXIgcmVjZWl2aW5nIHRva2VucyBmcm9tIGEgZGVlcCBsaW5rIGNhbGxiYWNrLlxuICAgKiBUaGlzIGlzIHRoZSBSZWFjdCBOYXRpdmUgZXF1aXZhbGVudCBvZiBhdXRvbWF0aWMgVVJMIHRva2VuIGRldGVjdGlvbiBvbiB3ZWIuXG4gICAqIFxuICAgKiBAcGFyYW0gdG9rZW5zIC0gQXV0aCB0b2tlbnMgcmVjZWl2ZWQgZnJvbSBkZWVwIGxpbmsgb3IgT0F1dGggY2FsbGJhY2tcbiAgICogQHBhcmFtIHBlcnNpc3QgLSBXaGV0aGVyIHRvIHBlcnNpc3QgdG9rZW5zIHRvIHN0b3JhZ2UgKGRlZmF1bHQ6IHRydWUpXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZWFjdCBOYXRpdmU6IEhhbmRsZSBkZWVwIGxpbmsgT0F1dGggY2FsbGJhY2tcbiAgICogaW1wb3J0ICogYXMgTGlua2luZyBmcm9tICdleHBvLWxpbmtpbmcnXG4gICAqIFxuICAgKiBMaW5raW5nLmFkZEV2ZW50TGlzdGVuZXIoJ3VybCcsIGFzeW5jICh7IHVybCB9KSA9PiB7XG4gICAqICAgY29uc3QgeyBxdWVyeVBhcmFtcyB9ID0gTGlua2luZy5wYXJzZSh1cmwpXG4gICAqICAgXG4gICAqICAgaWYgKHF1ZXJ5UGFyYW1zLmFjY2Vzc190b2tlbikge1xuICAgKiAgICAgYXdhaXQgYmxpbmsuYXV0aC5zZXRTZXNzaW9uKHtcbiAgICogICAgICAgYWNjZXNzX3Rva2VuOiBxdWVyeVBhcmFtcy5hY2Nlc3NfdG9rZW4sXG4gICAqICAgICAgIHJlZnJlc2hfdG9rZW46IHF1ZXJ5UGFyYW1zLnJlZnJlc2hfdG9rZW4sXG4gICAqICAgICAgIGV4cGlyZXNfaW46IHBhcnNlSW50KHF1ZXJ5UGFyYW1zLmV4cGlyZXNfaW4pIHx8IDM2MDAsXG4gICAqICAgICAgIHJlZnJlc2hfZXhwaXJlc19pbjogcGFyc2VJbnQocXVlcnlQYXJhbXMucmVmcmVzaF9leHBpcmVzX2luKVxuICAgKiAgICAgfSlcbiAgICogICAgIFxuICAgKiAgICAgY29uc29sZS5sb2coJ1VzZXIgYXV0aGVudGljYXRlZDonLCBibGluay5hdXRoLmN1cnJlbnRVc2VyKCkpXG4gICAqICAgfVxuICAgKiB9KVxuICAgKi9cbiAgYXN5bmMgc2V0U2Vzc2lvbih0b2tlbnMsIHBlcnNpc3QgPSB0cnVlKSB7XG4gICAgY29uc3QgYXV0aFRva2VucyA9IHtcbiAgICAgIGFjY2Vzc190b2tlbjogdG9rZW5zLmFjY2Vzc190b2tlbixcbiAgICAgIHJlZnJlc2hfdG9rZW46IHRva2Vucy5yZWZyZXNoX3Rva2VuLFxuICAgICAgdG9rZW5fdHlwZTogXCJCZWFyZXJcIixcbiAgICAgIGV4cGlyZXNfaW46IHRva2Vucy5leHBpcmVzX2luIHx8IDM2MDAsXG4gICAgICAvLyBEZWZhdWx0IDEgaG91clxuICAgICAgcmVmcmVzaF9leHBpcmVzX2luOiB0b2tlbnMucmVmcmVzaF9leHBpcmVzX2luLFxuICAgICAgaXNzdWVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnNldFRva2VucyhhdXRoVG9rZW5zLCBwZXJzaXN0KTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5tZSgpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZnkgYSBCbGluayBBdXRoIHRva2VuIHVzaW5nIHRoZSBpbnRyb3NwZWN0aW9uIGVuZHBvaW50LlxuICAgKiBcbiAgICogKipTZXJ2ZXItc2lkZSAvIEVkZ2UgRnVuY3Rpb24gdXNlIG9ubHkuKipcbiAgICogXG4gICAqIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byB2ZXJpZnkgdXNlciB0b2tlbnMgaW4gRGVubyBFZGdlIEZ1bmN0aW9uc1xuICAgKiBhbmQgb3RoZXIgc2VydmVyLXNpZGUgY29udGV4dHMuIEl0IGNhbGxzIHRoZSBCbGluayBBUEkgaW50cm9zcGVjdGlvbiBcbiAgICogZW5kcG9pbnQgd2hpY2ggdmFsaWRhdGVzIHRoZSB0b2tlbiB3aXRob3V0IGV4cG9zaW5nIHRoZSBKV1Qgc2VjcmV0LlxuICAgKiBcbiAgICogQHBhcmFtIHRva2VuIC0gVGhlIHJhdyBKV1QgdG9rZW4gKHdpdGhvdXQgXCJCZWFyZXIgXCIgcHJlZml4KSBvciBmdWxsIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqIEByZXR1cm5zIFRva2VuIGludHJvc3BlY3Rpb24gcmVzdWx0IHdpdGggdmFsaWRpdHkgYW5kIGNsYWltc1xuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRGVubyBFZGdlIEZ1bmN0aW9uIHVzYWdlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCJucG06QGJsaW5rZG90bmV3L3Nka1wiO1xuICAgKiBcbiAgICogY29uc3QgYmxpbmsgPSBjcmVhdGVDbGllbnQoe1xuICAgKiAgIHByb2plY3RJZDogRGVuby5lbnYuZ2V0KFwiQkxJTktfUFJPSkVDVF9JRFwiKSEsXG4gICAqICAgc2VjcmV0S2V5OiBEZW5vLmVudi5nZXQoXCJCTElOS19TRUNSRVRfS0VZXCIpLFxuICAgKiB9KTtcbiAgICogXG4gICAqIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxOiBSZXF1ZXN0KTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgKiAgIGNvbnN0IGF1dGhIZWFkZXIgPSByZXEuaGVhZGVycy5nZXQoXCJBdXRob3JpemF0aW9uXCIpO1xuICAgKiAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJsaW5rLmF1dGgudmVyaWZ5VG9rZW4oYXV0aEhlYWRlcik7XG4gICAqICAgXG4gICAqICAgaWYgKCFyZXN1bHQudmFsaWQpIHtcbiAgICogICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogcmVzdWx0LmVycm9yIH0pLCB7IHN0YXR1czogNDAxIH0pO1xuICAgKiAgIH1cbiAgICogICBcbiAgICogICAvLyBVc2VyIGlzIGF1dGhlbnRpY2F0ZWRcbiAgICogICBjb25zb2xlLmxvZyhcIlVzZXIgSUQ6XCIsIHJlc3VsdC51c2VySWQpO1xuICAgKiAgIGNvbnNvbGUubG9nKFwiRW1haWw6XCIsIHJlc3VsdC5lbWFpbCk7XG4gICAqICAgY29uc29sZS5sb2coXCJQcm9qZWN0OlwiLCByZXN1bHQucHJvamVjdElkKTtcbiAgICogICBcbiAgICogICAvLyBDb250aW51ZSB3aXRoIHlvdXIgbG9naWMuLi5cbiAgICogfVxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5VG9rZW4odG9rZW4pIHtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiBcIlRva2VuIHJlcXVpcmVkXCIgfTtcbiAgICB9XG4gICAgbGV0IGNsZWFuVG9rZW4gPSB0b2tlbi50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJiZWFyZXIgXCIpID8gdG9rZW4uc2xpY2UoNykgOiB0b2tlbjtcbiAgICBjbGVhblRva2VuID0gY2xlYW5Ub2tlbi50cmltKCk7XG4gICAgaWYgKCFjbGVhblRva2VuKSB7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiBcIlRva2VuIHJlcXVpcmVkXCIgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5jb3JlVXJsfS9hcGkvYXV0aC9pbnRyb3NwZWN0YCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHtjbGVhblRva2VufWAsXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFjb250ZW50VHlwZSB8fCAhY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGlmICghcmVzdWx0IHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJlc3VsdC52YWxpZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IHJlc3VsdCAmJiAocmVzdWx0LmVycm9yIHx8IHJlc3VsdC5tZXNzYWdlKSB8fCBgUmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQmxpbmtBdXRoXSBUb2tlbiB2ZXJpZmljYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVG9rZW4gdmVyaWZpY2F0aW9uIGZhaWxlZFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVmcmVzaCBhY2Nlc3MgdG9rZW4gdXNpbmcgcmVmcmVzaCB0b2tlblxuICAgKi9cbiAgYXN5bmMgcmVmcmVzaFRva2VuKCkge1xuICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHRoaXMuYXV0aFN0YXRlLnRva2Vucz8ucmVmcmVzaF90b2tlbjtcbiAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3JlZnJlc2hgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgdGhpcy5jbGVhclRva2VucygpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoUmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RUb0F1dGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0VG9rZW5zKHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiBkYXRhLmFjY2Vzc190b2tlbixcbiAgICAgICAgcmVmcmVzaF90b2tlbjogZGF0YS5yZWZyZXNoX3Rva2VuLFxuICAgICAgICB0b2tlbl90eXBlOiBkYXRhLnRva2VuX3R5cGUsXG4gICAgICAgIGV4cGlyZXNfaW46IGRhdGEuZXhwaXJlc19pbixcbiAgICAgICAgcmVmcmVzaF9leHBpcmVzX2luOiBkYXRhLnJlZnJlc2hfZXhwaXJlc19pblxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRva2VuIHJlZnJlc2ggZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGQgYXV0aCBzdGF0ZSBjaGFuZ2UgbGlzdGVuZXJcbiAgICovXG4gIG9uQXV0aFN0YXRlQ2hhbmdlZChjYWxsYmFjaykge1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5hdXRoU3RhdGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGF1dGggc3RhdGUgY2hhbmdlIGNhbGxiYWNrOlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUHJpdmF0ZSBoZWxwZXIgbWV0aG9kc1xuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVTdG9yZWRUb2tlbnModG9rZW5zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTBEfSBWYWxpZGF0aW5nIHN0b3JlZCB0b2tlbnMuLi5cIik7XG4gICAgICBpZiAodGhpcy5pc0FjY2Vzc1Rva2VuRXhwaXJlZCgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjNGMCBBY2Nlc3MgdG9rZW4gZXhwaXJlZCBiYXNlZCBvbiB0aW1lc3RhbXAsIGF0dGVtcHRpbmcgcmVmcmVzaC4uLlwiKTtcbiAgICAgICAgaWYgKCF0b2tlbnMucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1Mjc0QyBObyByZWZyZXNoIHRva2VuIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWZyZXNoVG9rZW5FeHBpcmVkKCkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgUmVmcmVzaCB0b2tlbiBhbHNvIGV4cGlyZWRcIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZnJlc2hlZCA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKCk7XG4gICAgICAgIGlmIChyZWZyZXNoZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3MDUgVG9rZW4gcmVmcmVzaGVkIHN1Y2Nlc3NmdWxseSBkdXJpbmcgdmFsaWRhdGlvblwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgVG9rZW4gcmVmcmVzaCBmYWlsZWQgZHVyaW5nIHZhbGlkYXRpb25cIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvbWVgLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2Vucy5hY2Nlc3NfdG9rZW59YFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICB0aGlzLnVwZGF0ZUF1dGhTdGF0ZSh7XG4gICAgICAgICAgdXNlcixcbiAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBTdG9yZWQgdG9rZW5zIGFyZSB2YWxpZCwgdXNlciBhdXRoZW50aWNhdGVkXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgJiYgdG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY1MDR9IEFjY2VzcyB0b2tlbiBleHBpcmVkIChzZXJ2ZXIgdmFsaWRhdGlvbiksIGF0dGVtcHRpbmcgcmVmcmVzaC4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWZyZXNoVG9rZW5FeHBpcmVkKCkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgUmVmcmVzaCB0b2tlbiBleHBpcmVkXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZyZXNoZWQgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgICAgICBpZiAocmVmcmVzaGVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IFRva2VuIHJlZnJlc2hlZCBzdWNjZXNzZnVsbHkgYWZ0ZXIgc2VydmVyIHZhbGlkYXRpb25cIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIFRva2VuIHJlZnJlc2ggZmFpbGVkIGFmdGVyIHNlcnZlciB2YWxpZGF0aW9uXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIFRva2VuIHZhbGlkYXRpb24gZmFpbGVkOlwiLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEE1fSBFcnJvciB2YWxpZGF0aW5nIHRva2VuczpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXRUb2tlbnModG9rZW5zLCBwZXJzaXN0KSB7XG4gICAgY29uc3QgdG9rZW5zV2l0aFRpbWVzdGFtcCA9IHtcbiAgICAgIC4uLnRva2VucyxcbiAgICAgIGlzc3VlZF9hdDogdG9rZW5zLmlzc3VlZF9hdCB8fCBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpXG4gICAgfTtcbiAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUxMH0gU2V0dGluZyB0b2tlbnM6XCIsIHtcbiAgICAgIHBlcnNpc3QsXG4gICAgICBoYXNBY2Nlc3NUb2tlbjogISF0b2tlbnNXaXRoVGltZXN0YW1wLmFjY2Vzc190b2tlbixcbiAgICAgIGhhc1JlZnJlc2hUb2tlbjogISF0b2tlbnNXaXRoVGltZXN0YW1wLnJlZnJlc2hfdG9rZW4sXG4gICAgICBleHBpcmVzSW46IHRva2Vuc1dpdGhUaW1lc3RhbXAuZXhwaXJlc19pbixcbiAgICAgIGlzc3VlZEF0OiB0b2tlbnNXaXRoVGltZXN0YW1wLmlzc3VlZF9hdFxuICAgIH0pO1xuICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICB0aGlzLmdldFN0b3JhZ2VLZXkoXCJ0b2tlbnNcIiksXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodG9rZW5zV2l0aFRpbWVzdGFtcClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0QkV9IFRva2VucyBwZXJzaXN0ZWQgdG8gc3RvcmFnZVwiKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEE1fSBFcnJvciBwZXJzaXN0aW5nIHRva2VuczpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXNlciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNDY0fSBGZXRjaGluZyB1c2VyIGRhdGEuLi5cIik7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvbWVgLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2Vuc1dpdGhUaW1lc3RhbXAuYWNjZXNzX3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjRFMX0gVXNlciBmZXRjaCByZXNwb25zZTpcIiwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgb2s6IHJlc3BvbnNlLm9rXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3MDUgVXNlciBkYXRhIGZldGNoZWQgc3VjY2Vzc2Z1bGx5OlwiLCB7XG4gICAgICAgICAgaWQ6IHVzZXI/LmlkLFxuICAgICAgICAgIGVtYWlsOiB1c2VyPy5lbWFpbCxcbiAgICAgICAgICBkaXNwbGF5TmFtZTogdXNlcj8uZGlzcGxheU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgRmFpbGVkIHRvIGZldGNoIHVzZXIgZGF0YTpcIiwgYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0QTV9IEVycm9yIGZldGNoaW5nIHVzZXIgZGF0YTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF1dGhTdGF0ZSh7XG4gICAgICB1c2VyLFxuICAgICAgdG9rZW5zOiB0b2tlbnNXaXRoVGltZXN0YW1wLFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiAhIXVzZXIsXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coXCJcXHV7MUYzQUZ9IEF1dGggc3RhdGUgdXBkYXRlZDpcIiwge1xuICAgICAgaGFzVXNlcjogISF1c2VyLFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiAhIXVzZXIsXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgY2xlYXJUb2tlbnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuZ2V0U3RvcmFnZUtleShcInRva2Vuc1wiKSk7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXN1bHQuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0QTV9IEVycm9yIGNsZWFyaW5nIHRva2VucyBmcm9tIHN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEE1fSBFcnJvciBjbGVhcmluZyB0b2tlbnM6XCIsIGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdXRoU3RhdGUoe1xuICAgICAgdXNlcjogbnVsbCxcbiAgICAgIHRva2VuczogbnVsbCxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmVkVG9rZW5zKCkge1xuICAgIGlmIChpc1dlYiAmJiB0aGlzLmlzSWZyYW1lICYmIHRoaXMucGFyZW50V2luZG93VG9rZW5zKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnRXaW5kb3dUb2tlbnM7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJ0b2tlbnNcIikpO1xuICAgICAgY29uc3Qgc3RvcmVkID0gcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSA/IGF3YWl0IHJlc3VsdCA6IHJlc3VsdDtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTBEfSBDaGVja2luZyBzdG9yYWdlIGZvciB0b2tlbnM6XCIsIHtcbiAgICAgICAgaGFzU3RvcmVkRGF0YTogISFzdG9yZWQsXG4gICAgICAgIHN0b3JlZExlbmd0aDogc3RvcmVkPy5sZW5ndGggfHwgMCxcbiAgICAgICAgaXNJZnJhbWU6IGlzV2ViICYmIHRoaXMuaXNJZnJhbWVcbiAgICAgIH0pO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEU2fSBQYXJzZWQgc3RvcmVkIHRva2VuczpcIiwge1xuICAgICAgICAgIGhhc0FjY2Vzc1Rva2VuOiAhIXRva2Vucy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgaGFzUmVmcmVzaFRva2VuOiAhIXRva2Vucy5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgIHRva2VuVHlwZTogdG9rZW5zLnRva2VuX3R5cGUsXG4gICAgICAgICAgZXhwaXJlc0luOiB0b2tlbnMuZXhwaXJlc19pblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjRBNX0gRXJyb3IgcmVhZGluZyB0b2tlbnMgZnJvbSBzdG9yYWdlOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgZXh0cmFjdFRva2Vuc0Zyb21VcmwoKSB7XG4gICAgY29uc3Qgc2VhcmNoID0gZ2V0TG9jYXRpb25TZWFyY2goKTtcbiAgICBpZiAoIXNlYXJjaCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gcGFyYW1zLmdldChcImFjY2Vzc190b2tlblwiKTtcbiAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBwYXJhbXMuZ2V0KFwicmVmcmVzaF90b2tlblwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUwRH0gRXh0cmFjdGluZyB0b2tlbnMgZnJvbSBVUkw6XCIsIHtcbiAgICAgIHVybDogZ2V0TG9jYXRpb25IcmVmKCksXG4gICAgICBhY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW4gPyBgJHthY2Nlc3NUb2tlbi5zdWJzdHJpbmcoMCwgMjApfS4uLmAgOiBudWxsLFxuICAgICAgcmVmcmVzaFRva2VuOiByZWZyZXNoVG9rZW4gPyBgJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDIwKX0uLi5gIDogbnVsbCxcbiAgICAgIGFsbFBhcmFtczogT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtcy5lbnRyaWVzKCkpXG4gICAgfSk7XG4gICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSB7XG4gICAgICAgIGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB8fCB2b2lkIDAsXG4gICAgICAgIHRva2VuX3R5cGU6IFwiQmVhcmVyXCIsXG4gICAgICAgIGV4cGlyZXNfaW46IDE1ICogNjAsXG4gICAgICAgIC8vIDE1IG1pbnV0ZXMgZGVmYXVsdFxuICAgICAgICByZWZyZXNoX2V4cGlyZXNfaW46IHJlZnJlc2hUb2tlbiA/IDMwICogMjQgKiA2MCAqIDYwIDogdm9pZCAwLFxuICAgICAgICAvLyAzMCBkYXlzIGRlZmF1bHRcbiAgICAgICAgaXNzdWVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpXG4gICAgICAgIC8vIEN1cnJlbnQgdGltZXN0YW1wXG4gICAgICB9O1xuICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IFRva2VucyBleHRyYWN0ZWQgc3VjY2Vzc2Z1bGx5OlwiLCB7XG4gICAgICAgIGhhc0FjY2Vzc1Rva2VuOiAhIXRva2Vucy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIGhhc1JlZnJlc2hUb2tlbjogISF0b2tlbnMucmVmcmVzaF90b2tlblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgTm8gYWNjZXNzIHRva2VuIGZvdW5kIGluIFVSTFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjbGVhclVybFRva2VucygpIHtcbiAgICBjb25zdCBocmVmID0gZ2V0TG9jYXRpb25IcmVmKCk7XG4gICAgaWYgKCFocmVmIHx8ICFoYXNXaW5kb3dMb2NhdGlvbigpKSByZXR1cm47XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImFjY2Vzc190b2tlblwiKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcInJlZnJlc2hfdG9rZW5cIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJ0b2tlbl90eXBlXCIpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwicHJvamVjdF9pZFwiKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImV4cGlyZXNfaW5cIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJyZWZyZXNoX2V4cGlyZXNfaW5cIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJzdGF0ZVwiKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImNvZGVcIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJlcnJvclwiKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImVycm9yX2Rlc2NyaXB0aW9uXCIpO1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgXCJcIiwgdXJsLnRvU3RyaW5nKCkpO1xuICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGOUY5fSBVUkwgY2xlYW5lZCB1cCwgcmVtb3ZlZCBhdXRoIHBhcmFtZXRlcnNcIik7XG4gIH1cbiAgcmVkaXJlY3RUb0F1dGgoKSB7XG4gICAgaWYgKGhhc1dpbmRvd0xvY2F0aW9uKCkpIHtcbiAgICAgIHRoaXMubG9naW4oKTtcbiAgICB9XG4gIH1cbiAgc2V0TG9hZGluZyhsb2FkaW5nKSB7XG4gICAgdGhpcy51cGRhdGVBdXRoU3RhdGUoe1xuICAgICAgLi4udGhpcy5hdXRoU3RhdGUsXG4gICAgICBpc0xvYWRpbmc6IGxvYWRpbmdcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBdXRoU3RhdGUobmV3U3RhdGUpIHtcbiAgICB0aGlzLmF1dGhTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayhuZXdTdGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gYXV0aCBzdGF0ZSBjaGFuZ2UgY2FsbGJhY2s6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgc2VjdXJlIHJhbmRvbSBzdGF0ZSBmb3IgT0F1dGggZmxvd3NcbiAgICovXG4gIGdlbmVyYXRlU3RhdGUoKSB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGFycmF5LCAoYnl0ZSkgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSB1bmlxdWUgc2Vzc2lvbiBJRCBmb3IgbW9iaWxlIE9BdXRoXG4gICAqL1xuICBnZW5lcmF0ZVNlc3Npb25JZCgpIHtcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIChieXRlKSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgbWFnaWMgbGluayB0b2tlbiBmcm9tIFVSTFxuICAgKi9cbiAgZXh0cmFjdE1hZ2ljVG9rZW5Gcm9tVXJsKCkge1xuICAgIGNvbnN0IHNlYXJjaCA9IGdldExvY2F0aW9uU2VhcmNoKCk7XG4gICAgaWYgKCFzZWFyY2gpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICByZXR1cm4gcGFyYW1zLmdldChcIm1hZ2ljX3Rva2VuXCIpIHx8IHBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcbiAgfVxuICAvKipcbiAgICogTWFwIHNlcnZlciBlcnJvciBjb2RlcyB0byBCbGlua0F1dGhFcnJvckNvZGVcbiAgICovXG4gIG1hcEVycm9yQ29kZUZyb21SZXNwb25zZShzZXJ2ZXJDb2RlKSB7XG4gICAgc3dpdGNoIChzZXJ2ZXJDb2RlKSB7XG4gICAgICBjYXNlIFwiSU5WQUxJRF9DUkVERU5USUFMU1wiOlxuICAgICAgY2FzZSBcImF1dGgvaW52YWxpZC1jcmVkZW50aWFsXCI6XG4gICAgICBjYXNlIFwiYXV0aC93cm9uZy1wYXNzd29yZFwiOlxuICAgICAgY2FzZSBcImF1dGgvdXNlci1ub3QtZm91bmRcIjpcbiAgICAgICAgcmV0dXJuIFwiSU5WQUxJRF9DUkVERU5USUFMU1wiIC8qIElOVkFMSURfQ1JFREVOVElBTFMgKi87XG4gICAgICBjYXNlIFwiRU1BSUxfTk9UX1ZFUklGSUVEXCI6XG4gICAgICBjYXNlIFwiYXV0aC9lbWFpbC1ub3QtdmVyaWZpZWRcIjpcbiAgICAgICAgcmV0dXJuIFwiRU1BSUxfTk9UX1ZFUklGSUVEXCIgLyogRU1BSUxfTk9UX1ZFUklGSUVEICovO1xuICAgICAgY2FzZSBcIkVNQUlMX0FMUkVBRFlfVkVSSUZJRURcIjpcbiAgICAgICAgcmV0dXJuIFwiVkVSSUZJQ0FUSU9OX0ZBSUxFRFwiIC8qIFZFUklGSUNBVElPTl9GQUlMRUQgKi87XG4gICAgICBjYXNlIFwiUE9QVVBfQ0FOQ0VMRURcIjpcbiAgICAgIGNhc2UgXCJhdXRoL3BvcHVwLWNsb3NlZC1ieS11c2VyXCI6XG4gICAgICAgIHJldHVybiBcIlBPUFVQX0NBTkNFTEVEXCIgLyogUE9QVVBfQ0FOQ0VMRUQgKi87XG4gICAgICBjYXNlIFwiTkVUV09SS19FUlJPUlwiOlxuICAgICAgICByZXR1cm4gXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLztcbiAgICAgIGNhc2UgXCJSQVRFX0xJTUlURURcIjpcbiAgICAgIGNhc2UgXCJhdXRoL3Rvby1tYW55LXJlcXVlc3RzXCI6XG4gICAgICAgIHJldHVybiBcIlJBVEVfTElNSVRFRFwiIC8qIFJBVEVfTElNSVRFRCAqLztcbiAgICAgIGNhc2UgXCJBVVRIX1RJTUVPVVRcIjpcbiAgICAgICAgcmV0dXJuIFwiQVVUSF9USU1FT1VUXCIgLyogQVVUSF9USU1FT1VUICovO1xuICAgICAgY2FzZSBcIlJFRElSRUNUX0ZBSUxFRFwiOlxuICAgICAgICByZXR1cm4gXCJSRURJUkVDVF9GQUlMRURcIiAvKiBSRURJUkVDVF9GQUlMRUQgKi87XG4gICAgICBjYXNlIFwiVE9LRU5fRVhQSVJFRFwiOlxuICAgICAgY2FzZSBcImF1dGgvaWQtdG9rZW4tZXhwaXJlZFwiOlxuICAgICAgICByZXR1cm4gXCJUT0tFTl9FWFBJUkVEXCIgLyogVE9LRU5fRVhQSVJFRCAqLztcbiAgICAgIGNhc2UgXCJVU0VSX05PVF9GT1VORFwiOlxuICAgICAgICByZXR1cm4gXCJVU0VSX05PVF9GT1VORFwiIC8qIFVTRVJfTk9UX0ZPVU5EICovO1xuICAgICAgY2FzZSBcIkVNQUlMX0FMUkVBRFlfRVhJU1RTXCI6XG4gICAgICBjYXNlIFwiYXV0aC9lbWFpbC1hbHJlYWR5LWluLXVzZVwiOlxuICAgICAgICByZXR1cm4gXCJFTUFJTF9BTFJFQURZX0VYSVNUU1wiIC8qIEVNQUlMX0FMUkVBRFlfRVhJU1RTICovO1xuICAgICAgY2FzZSBcIldFQUtfUEFTU1dPUkRcIjpcbiAgICAgIGNhc2UgXCJhdXRoL3dlYWstcGFzc3dvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwiV0VBS19QQVNTV09SRFwiIC8qIFdFQUtfUEFTU1dPUkQgKi87XG4gICAgICBjYXNlIFwiSU5WQUxJRF9FTUFJTFwiOlxuICAgICAgY2FzZSBcImF1dGgvaW52YWxpZC1lbWFpbFwiOlxuICAgICAgICByZXR1cm4gXCJJTlZBTElEX0VNQUlMXCIgLyogSU5WQUxJRF9FTUFJTCAqLztcbiAgICAgIGNhc2UgXCJNQUdJQ19MSU5LX0VYUElSRURcIjpcbiAgICAgICAgcmV0dXJuIFwiTUFHSUNfTElOS19FWFBJUkVEXCIgLyogTUFHSUNfTElOS19FWFBJUkVEICovO1xuICAgICAgY2FzZSBcIlZFUklGSUNBVElPTl9GQUlMRURcIjpcbiAgICAgICAgcmV0dXJuIFwiVkVSSUZJQ0FUSU9OX0ZBSUxFRFwiIC8qIFZFUklGSUNBVElPTl9GQUlMRUQgKi87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHVwIGNyb3NzLXRhYiBhdXRoZW50aWNhdGlvbiBzeW5jaHJvbml6YXRpb25cbiAgICovXG4gIHNldHVwQ3Jvc3NUYWJTeW5jKCkge1xuICAgIGlmICghaXNXZWIgfHwgIWhhc1dpbmRvdygpKSByZXR1cm47XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzdG9yYWdlXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IHRoaXMuZ2V0U3RvcmFnZUtleShcInRva2Vuc1wiKSkge1xuICAgICAgICBjb25zdCBuZXdUb2tlbnMgPSBlLm5ld1ZhbHVlID8gSlNPTi5wYXJzZShlLm5ld1ZhbHVlKSA6IG51bGw7XG4gICAgICAgIGlmIChuZXdUb2tlbnMgJiYgbmV3VG9rZW5zICE9PSB0aGlzLmF1dGhTdGF0ZS50b2tlbnMpIHtcbiAgICAgICAgICB0aGlzLnNldFRva2VucyhuZXdUb2tlbnMsIGZhbHNlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc3luYyB0b2tlbnMgZnJvbSBvdGhlciB0YWI6XCIsIGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghbmV3VG9rZW5zICYmIHRoaXMuYXV0aFN0YXRlLnRva2Vucykge1xuICAgICAgICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZGF0YWJhc2UudHNcbmZ1bmN0aW9uIGFzc2VydFNlcnZlck9ubHkobWV0aG9kTmFtZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXRob2ROYW1lfSBpcyBzZXJ2ZXItb25seS4gVXNlIEJsaW5rIENSVUQgbWV0aG9kcyAoYmxpbmsuZGIuPHRhYmxlPi4qKSBpbnN0ZWFkLmApO1xuICB9XG59XG5mdW5jdGlvbiBjYW1lbFRvU25ha2UzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tBLVpdL2csIChsZXR0ZXIpID0+IGBfJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX1gKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VjdXJlSWQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgKGJ5dGUpID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbiAgICBjb25zdCByYW5kb21QYXJ0ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KTtcbiAgICBjb25zdCBleHRyYVJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgcmV0dXJuIGAke3RpbWVzdGFtcH1fJHtyYW5kb21QYXJ0fV8ke2V4dHJhUmFuZG9tfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVJlY29yZElkKHJlY29yZCkge1xuICBpZiAoIXJlY29yZC5pZCkge1xuICAgIHJldHVybiB7IC4uLnJlY29yZCwgaWQ6IGdlbmVyYXRlU2VjdXJlSWQoKSB9O1xuICB9XG4gIHJldHVybiByZWNvcmQ7XG59XG52YXIgQmxpbmtUYWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodGFibGVOYW1lLCBodHRwQ2xpZW50KSB7XG4gICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB0aGlzLmFjdHVhbFRhYmxlTmFtZSA9IGNhbWVsVG9TbmFrZTModGFibGVOYW1lKTtcbiAgfVxuICBhY3R1YWxUYWJsZU5hbWU7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW5nbGUgcmVjb3JkXG4gICAqL1xuICBhc3luYyBjcmVhdGUoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVjb3JkID0gZW5zdXJlUmVjb3JkSWQoZGF0YSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJQb3N0KFxuICAgICAgdGhpcy5hY3R1YWxUYWJsZU5hbWUsXG4gICAgICByZWNvcmQsXG4gICAgICB7IHJldHVybmluZzogb3B0aW9ucy5yZXR1cm5pbmcgIT09IGZhbHNlIH1cbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkgPyByZXNwb25zZS5kYXRhWzBdIDogcmVzcG9uc2UuZGF0YTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSByZWNvcmRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBtdWx0aXBsZSByZWNvcmRzXG4gICAqL1xuICBhc3luYyBjcmVhdGVNYW55KGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlY29yZHMgPSBkYXRhLm1hcChlbnN1cmVSZWNvcmRJZCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJQb3N0KFxuICAgICAgdGhpcy5hY3R1YWxUYWJsZU5hbWUsXG4gICAgICByZWNvcmRzLFxuICAgICAgeyByZXR1cm5pbmc6IG9wdGlvbnMucmV0dXJuaW5nICE9PSBmYWxzZSB9XG4gICAgKTtcbiAgICBjb25zdCByZXN1bHRzID0gQXJyYXkuaXNBcnJheShyZXNwb25zZS5kYXRhKSA/IHJlc3BvbnNlLmRhdGEgOiBbcmVzcG9uc2UuZGF0YV07XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXG4gICAqIFVwc2VydCBhIHNpbmdsZSByZWNvcmQgKGluc2VydCBvciB1cGRhdGUgb24gY29uZmxpY3QpXG4gICAqL1xuICBhc3luYyB1cHNlcnQoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmIChvcHRpb25zLnJldHVybmluZyAhPT0gZmFsc2UpIHtcbiAgICAgIGhlYWRlcnMuUHJlZmVyID0gXCJyZXR1cm49cmVwcmVzZW50YXRpb25cIjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub25Db25mbGljdCkge1xuICAgICAgaGVhZGVyc1tcIlByZWZlclwiXSA9IGAke2hlYWRlcnNbXCJQcmVmZXJcIl0gfHwgXCJcIn0gcmVzb2x1dGlvbj1tZXJnZS1kdXBsaWNhdGVzYC50cmltKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlY29yZCA9IGVuc3VyZVJlY29yZElkKGRhdGEpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJlcXVlc3QoXG4gICAgICBgL2FwaS9kYi8ke3RoaXMuaHR0cENsaWVudC5wcm9qZWN0SWR9L3Jlc3QvdjEvJHt0aGlzLmFjdHVhbFRhYmxlTmFtZX0/b25fY29uZmxpY3Q9JHtvcHRpb25zLm9uQ29uZmxpY3QgfHwgXCJpZFwifWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IHJlY29yZCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheShyZXNwb25zZS5kYXRhKSA/IHJlc3BvbnNlLmRhdGFbMF0gOiByZXNwb25zZS5kYXRhO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdXBzZXJ0IHJlY29yZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogVXBzZXJ0IG11bHRpcGxlIHJlY29yZHNcbiAgICovXG4gIGFzeW5jIHVwc2VydE1hbnkoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVjb3JkcyA9IGRhdGEubWFwKGVuc3VyZVJlY29yZElkKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nICE9PSBmYWxzZSkge1xuICAgICAgaGVhZGVycy5QcmVmZXIgPSBcInJldHVybj1yZXByZXNlbnRhdGlvblwiO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vbkNvbmZsaWN0KSB7XG4gICAgICBoZWFkZXJzW1wiUHJlZmVyXCJdID0gYCR7aGVhZGVyc1tcIlByZWZlclwiXSB8fCBcIlwifSByZXNvbHV0aW9uPW1lcmdlLWR1cGxpY2F0ZXNgLnRyaW0oKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucmVxdWVzdChcbiAgICAgIGAvYXBpL2RiLyR7dGhpcy5odHRwQ2xpZW50LnByb2plY3RJZH0vcmVzdC92MS8ke3RoaXMuYWN0dWFsVGFibGVOYW1lfT9vbl9jb25mbGljdD0ke29wdGlvbnMub25Db25mbGljdCB8fCBcImlkXCJ9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogcmVjb3JkcyxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0cyA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkgPyByZXNwb25zZS5kYXRhIDogW3Jlc3BvbnNlLmRhdGFdO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGUgcmVjb3JkIGJ5IElEXG4gICAqL1xuICBhc3luYyBnZXQoaWQpIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSB7XG4gICAgICBpZDogYGVxLiR7aWR9YCxcbiAgICAgIGxpbWl0OiBcIjFcIlxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJHZXQodGhpcy5hY3R1YWxUYWJsZU5hbWUsIHNlYXJjaFBhcmFtcyk7XG4gICAgY29uc3QgcmVjb3JkcyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlY29yZHNbMF0gfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogTGlzdCByZWNvcmRzIHdpdGggZmlsdGVyaW5nLCBzb3J0aW5nLCBhbmQgcGFnaW5hdGlvblxuICAgKi9cbiAgYXN5bmMgbGlzdChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IGJ1aWxkUXVlcnkob3B0aW9ucyk7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gcXVlcnlQYXJhbXM7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJHZXQodGhpcy5hY3R1YWxUYWJsZU5hbWUsIHNlYXJjaFBhcmFtcyk7XG4gICAgY29uc3QgcmVjb3JkcyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgcmV0dXJuIHJlY29yZHM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHNpbmdsZSByZWNvcmQgYnkgSURcbiAgICovXG4gIGFzeW5jIHVwZGF0ZShpZCwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0ge1xuICAgICAgaWQ6IGBlcS4ke2lkfWBcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRiUGF0Y2goXG4gICAgICB0aGlzLmFjdHVhbFRhYmxlTmFtZSxcbiAgICAgIGRhdGEsXG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICB7IHJldHVybmluZzogb3B0aW9ucy5yZXR1cm5pbmcgIT09IGZhbHNlIH1cbiAgICApO1xuICAgIGNvbnN0IHJlY29yZHMgPSByZXNwb25zZS5kYXRhO1xuICAgIGlmICghcmVjb3JkcyB8fCByZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNvcmQgd2l0aCBpZCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY29yZHNbMF07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBtdWx0aXBsZSByZWNvcmRzXG4gICAqL1xuICBhc3luYyB1cGRhdGVNYW55KHVwZGF0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCB7IGlkLCAuLi5kYXRhIH0gPSB1cGRhdGU7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnVwZGF0ZShpZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHNpbmdsZSByZWNvcmQgYnkgSURcbiAgICovXG4gIGFzeW5jIGRlbGV0ZShpZCkge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHtcbiAgICAgIGlkOiBgZXEuJHtpZH1gXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJEZWxldGUodGhpcy5hY3R1YWxUYWJsZU5hbWUsIHNlYXJjaFBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBtdWx0aXBsZSByZWNvcmRzIGJhc2VkIG9uIGZpbHRlclxuICAgKi9cbiAgYXN5bmMgZGVsZXRlTWFueShvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBidWlsZFF1ZXJ5KHsgd2hlcmU6IG9wdGlvbnMud2hlcmUgfSk7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gcXVlcnlQYXJhbXM7XG4gICAgYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRiRGVsZXRlKHRoaXMuYWN0dWFsVGFibGVOYW1lLCBzZWFyY2hQYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb3VudCByZWNvcmRzIG1hdGNoaW5nIGZpbHRlclxuICAgKi9cbiAgYXN5bmMgY291bnQob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBidWlsZFF1ZXJ5KHtcbiAgICAgIHdoZXJlOiBvcHRpb25zLndoZXJlLFxuICAgICAgc2VsZWN0OiBbXCJpZFwiXVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJlcXVlc3QoXG4gICAgICBgL2FwaS9kYi8ke3RoaXMuaHR0cENsaWVudC5wcm9qZWN0SWR9L3Jlc3QvdjEvJHt0aGlzLmFjdHVhbFRhYmxlTmFtZX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIHNlYXJjaFBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIlByZWZlclwiOiBcImNvdW50PWV4YWN0XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgY29udGVudFJhbmdlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXJhbmdlXCIpO1xuICAgIGlmIChjb250ZW50UmFuZ2UpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY29udGVudFJhbmdlLm1hdGNoKC9cXC8oXFxkKykkLyk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlY29yZHMgPSByZXNwb25zZS5kYXRhO1xuICAgIHJldHVybiByZWNvcmRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYW55IHJlY29yZHMgZXhpc3QgbWF0Y2hpbmcgZmlsdGVyXG4gICAqL1xuICBhc3luYyBleGlzdHMob3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgdGhpcy5jb3VudChvcHRpb25zKTtcbiAgICByZXR1cm4gY291bnQgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBSYXcgU1FMIHF1ZXJ5IG9uIHRoaXMgdGFibGUgKGZvciBhZHZhbmNlZCB1c2UgY2FzZXMpXG4gICAqL1xuICBhc3luYyBzcWwocXVlcnksIHBhcmFtcykge1xuICAgIGFzc2VydFNlcnZlck9ubHkoXCJibGluay5kYi48dGFibGU+LnNxbFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYlNxbChxdWVyeSwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICAvKipcbiAgICogUHJpdmF0ZSBoZWxwZXIgbWV0aG9kc1xuICAgKi9cbiAgZXh0cmFjdEN1cnNvcihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkLmlkIHx8IHJlY29yZC5faWQgfHwgU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuICB9XG59O1xudmFyIEJsaW5rRGF0YWJhc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09IFwidGFibGVcIikge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQudGFibGUuYmluZCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlLmJpbmQodGFyZ2V0KSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQudGFibGUocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbiAgdGFibGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIEdldCBhIHRhYmxlIGluc3RhbmNlIGZvciBhbnkgdGFibGUgbmFtZVxuICAgKi9cbiAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgaWYgKCF0aGlzLnRhYmxlcy5oYXModGFibGVOYW1lKSkge1xuICAgICAgdGhpcy50YWJsZXMuc2V0KHRhYmxlTmFtZSwgbmV3IEJsaW5rVGFibGUodGFibGVOYW1lLCB0aGlzLmh0dHBDbGllbnQpKTtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnRhYmxlcy5nZXQodGFibGVOYW1lKTtcbiAgICBpZiAoIXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhYmxlICR7dGFibGVOYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIHJhdyBTUUwgcXVlcnlcbiAgICovXG4gIGFzeW5jIHNxbChxdWVyeSwgcGFyYW1zKSB7XG4gICAgYXNzZXJ0U2VydmVyT25seShcImJsaW5rLmRiLnNxbFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYlNxbChxdWVyeSwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBiYXRjaCBTUUwgb3BlcmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgYmF0Y2goc3RhdGVtZW50cywgbW9kZSA9IFwid3JpdGVcIikge1xuICAgIGFzc2VydFNlcnZlck9ubHkoXCJibGluay5kYi5iYXRjaFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYkJhdGNoKHN0YXRlbWVudHMsIG1vZGUpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG59O1xuXG4vLyBzcmMvc3RvcmFnZS50c1xudmFyIEJsaW5rU3RvcmFnZUltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgYSBmaWxlIHRvIHByb2plY3Qgc3RvcmFnZVxuICAgKiBcbiAgICogQHBhcmFtIGZpbGUgLSBGaWxlLCBCbG9iLCBvciBCdWZmZXIgdG8gdXBsb2FkXG4gICAqIEBwYXJhbSBwYXRoIC0gRGVzdGluYXRpb24gcGF0aCB3aXRoaW4gcHJvamVjdCBzdG9yYWdlIChleHRlbnNpb24gd2lsbCBiZSBhdXRvLWNvcnJlY3RlZCB0byBtYXRjaCBmaWxlIHR5cGUpXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVXBsb2FkIG9wdGlvbnMgaW5jbHVkaW5nIHVwc2VydCBhbmQgcHJvZ3Jlc3MgY2FsbGJhY2tcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdXBsb2FkIHJlc3BvbnNlIHdpdGggcHVibGljIFVSTFxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gRXh0ZW5zaW9uIGF1dG9tYXRpY2FsbHkgY29ycmVjdGVkIHRvIG1hdGNoIGFjdHVhbCBmaWxlIHR5cGVcbiAgICogY29uc3QgeyBwdWJsaWNVcmwgfSA9IGF3YWl0IGJsaW5rLnN0b3JhZ2UudXBsb2FkKFxuICAgKiAgIHBuZ0ZpbGUsXG4gICAqICAgYGF2YXRhcnMvJHt1c2VyLmlkfWAsIC8vIE5vIGV4dGVuc2lvbiBuZWVkZWQhXG4gICAqICAgeyB1cHNlcnQ6IHRydWUgfVxuICAgKiApO1xuICAgKiAvLyBJZiBmaWxlIGlzIFBORywgZmluYWwgcGF0aCB3aWxsIGJlOiBhdmF0YXJzL3VzZXIxMjMucG5nXG4gICAqIFxuICAgKiAvLyBPciB3aXRoIGV4dGVuc2lvbiAod2lsbCBiZSBjb3JyZWN0ZWQgaWYgd3JvbmcpXG4gICAqIGNvbnN0IHsgcHVibGljVXJsIH0gPSBhd2FpdCBibGluay5zdG9yYWdlLnVwbG9hZChcbiAgICogICBwbmdGaWxlLFxuICAgKiAgIGBhdmF0YXJzLyR7dXNlci5pZH0uanBnYCwgLy8gV3JvbmcgZXh0ZW5zaW9uXG4gICAqICAgeyB1cHNlcnQ6IHRydWUgfVxuICAgKiApO1xuICAgKiAvLyBGaW5hbCBwYXRoIHdpbGwgYmU6IGF2YXRhcnMvdXNlcjEyMy5wbmcgKGF1dG8tY29ycmVjdGVkISlcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyB1cGxvYWQoZmlsZSwgcGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJGaWxlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXRoIHx8IHR5cGVvZiBwYXRoICE9PSBcInN0cmluZ1wiIHx8ICFwYXRoLnRyaW0oKSkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJQYXRoIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4U2l6ZSA9IDUwICogMTAyNCAqIDEwMjQ7XG4gICAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlIHx8IGZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGZpbGVTaXplID0gZmlsZS5zaXplO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgZmlsZVNpemUgPSBmaWxlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxlU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKGBGaWxlIHNpemUgKCR7TWF0aC5yb3VuZChmaWxlU2l6ZSAvIDEwMjQgLyAxMDI0KX1NQikgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSAoNTBNQilgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29ycmVjdGVkUGF0aCwgZGV0ZWN0ZWRDb250ZW50VHlwZSB9ID0gYXdhaXQgdGhpcy5kZXRlY3RGaWxlVHlwZUFuZENvcnJlY3RQYXRoKGZpbGUsIHBhdGgpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQudXBsb2FkRmlsZShcbiAgICAgICAgYC9hcGkvc3RvcmFnZS8ke3RoaXMuaHR0cENsaWVudC5wcm9qZWN0SWR9L3VwbG9hZGAsXG4gICAgICAgIGZpbGUsXG4gICAgICAgIGNvcnJlY3RlZFBhdGgsXG4gICAgICAgIC8vIFVzZSBjb3JyZWN0ZWQgcGF0aCB3aXRoIHByb3BlciBleHRlbnNpb25cbiAgICAgICAge1xuICAgICAgICAgIG9uUHJvZ3Jlc3M6IG9wdGlvbnMub25Qcm9ncmVzcyxcbiAgICAgICAgICBjb250ZW50VHlwZTogZGV0ZWN0ZWRDb250ZW50VHlwZVxuICAgICAgICAgIC8vIFBhc3MgZGV0ZWN0ZWQgY29udGVudCB0eXBlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2UuZGF0YT8uZGF0YT8ucHVibGljVXJsKSB7XG4gICAgICAgIHJldHVybiB7IHB1YmxpY1VybDogcmVzcG9uc2UuZGF0YS5kYXRhLnB1YmxpY1VybCB9O1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5kYXRhPy5wdWJsaWNVcmwpIHtcbiAgICAgICAgcmV0dXJuIHsgcHVibGljVXJsOiByZXNwb25zZS5kYXRhLnB1YmxpY1VybCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6IG1pc3NpbmcgcHVibGljVXJsXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua1N0b3JhZ2VFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIFwic3RhdHVzXCIgaW4gZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3Iuc3RhdHVzO1xuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJGaWxlIGFscmVhZHkgZXhpc3RzLlwiLCA0MDkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua1N0b3JhZ2VFcnJvcihcIkludmFsaWQgcmVxdWVzdCBwYXJhbWV0ZXJzXCIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua1N0b3JhZ2VFcnJvcihcbiAgICAgICAgYFVwbG9hZCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERldGVjdCBmaWxlIHR5cGUgZnJvbSBhY3R1YWwgZmlsZSBjb250ZW50IGFuZCBjb3JyZWN0IHBhdGggZXh0ZW5zaW9uXG4gICAqIFRoaXMgZW5zdXJlcyB0aGUgcGF0aCBleHRlbnNpb24gYWx3YXlzIG1hdGNoZXMgdGhlIGFjdHVhbCBmaWxlIHR5cGVcbiAgICovXG4gIGFzeW5jIGRldGVjdEZpbGVUeXBlQW5kQ29ycmVjdFBhdGgoZmlsZSwgb3JpZ2luYWxQYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGVTaWduYXR1cmUgPSBhd2FpdCB0aGlzLmdldEZpbGVTaWduYXR1cmUoZmlsZSk7XG4gICAgICBjb25zdCBkZXRlY3RlZFR5cGUgPSB0aGlzLmRldGVjdEZpbGVUeXBlRnJvbVNpZ25hdHVyZShmaWxlU2lnbmF0dXJlKTtcbiAgICAgIGxldCBkZXRlY3RlZENvbnRlbnRUeXBlID0gZGV0ZWN0ZWRUeXBlLm1pbWVUeXBlO1xuICAgICAgbGV0IGRldGVjdGVkRXh0ZW5zaW9uID0gZGV0ZWN0ZWRUeXBlLmV4dGVuc2lvbjtcbiAgICAgIGlmICghZGV0ZWN0ZWRDb250ZW50VHlwZSAmJiBmaWxlIGluc3RhbmNlb2YgRmlsZSAmJiBmaWxlLnR5cGUpIHtcbiAgICAgICAgZGV0ZWN0ZWRDb250ZW50VHlwZSA9IGZpbGUudHlwZTtcbiAgICAgICAgZGV0ZWN0ZWRFeHRlbnNpb24gPSB0aGlzLmdldEV4dGVuc2lvbkZyb21NaW1lVHlwZShmaWxlLnR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkZXRlY3RlZENvbnRlbnRUeXBlKSB7XG4gICAgICAgIGRldGVjdGVkQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICBkZXRlY3RlZEV4dGVuc2lvbiA9IFwiYmluXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRoUGFydHMgPSBvcmlnaW5hbFBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZGlyZWN0b3J5ID0gcGF0aFBhcnRzLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKTtcbiAgICAgIGlmICghZmlsZU5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRoOiBmaWxlbmFtZSBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBuYW1lV2l0aG91dEV4dCA9IGZpbGVOYW1lLmluY2x1ZGVzKFwiLlwiKSA/IGZpbGVOYW1lLnN1YnN0cmluZygwLCBmaWxlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikpIDogZmlsZU5hbWU7XG4gICAgICBjb25zdCBjb3JyZWN0ZWRGaWxlTmFtZSA9IGAke25hbWVXaXRob3V0RXh0fS4ke2RldGVjdGVkRXh0ZW5zaW9ufWA7XG4gICAgICBjb25zdCBjb3JyZWN0ZWRQYXRoID0gZGlyZWN0b3J5ID8gYCR7ZGlyZWN0b3J5fS8ke2NvcnJlY3RlZEZpbGVOYW1lfWAgOiBjb3JyZWN0ZWRGaWxlTmFtZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvcnJlY3RlZFBhdGgsXG4gICAgICAgIGRldGVjdGVkQ29udGVudFR5cGVcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvcnJlY3RlZFBhdGg6IG9yaWdpbmFsUGF0aCxcbiAgICAgICAgZGV0ZWN0ZWRDb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgZmV3IGJ5dGVzIG9mIGEgZmlsZSB0byBhbmFseXplIGl0cyBzaWduYXR1cmVcbiAgICovXG4gIGFzeW5jIGdldEZpbGVTaWduYXR1cmUoZmlsZSkge1xuICAgIGNvbnN0IGJ5dGVzVG9SZWFkID0gMTI7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGZpbGUuc2xpY2UoMCwgYnl0ZXNUb1JlYWQpKTtcbiAgICB9XG4gICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBGaWxlIHx8IGZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICBjb25zdCBzbGljZSA9IGZpbGUuc2xpY2UoMCwgYnl0ZXNUb1JlYWQpO1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBzbGljZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZmlsZSB0eXBlIGZvciBzaWduYXR1cmUgZGV0ZWN0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3QgZmlsZSB0eXBlIGZyb20gZmlsZSBzaWduYXR1cmUgKG1hZ2ljIG51bWJlcnMpXG4gICAqIFRoaXMgaXMgdGhlIG1vc3QgcmVsaWFibGUgd2F5IHRvIGRldGVjdCBhY3R1YWwgZmlsZSB0eXBlXG4gICAqL1xuICBkZXRlY3RGaWxlVHlwZUZyb21TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgaGV4ID0gQXJyYXkuZnJvbShzaWduYXR1cmUpLm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSB7XG4gICAgICAvLyBJbWFnZXNcbiAgICAgIFwiZmZkOGZmXCI6IHsgbWltZVR5cGU6IFwiaW1hZ2UvanBlZ1wiLCBleHRlbnNpb246IFwianBnXCIgfSxcbiAgICAgIFwiODk1MDRlNDdcIjogeyBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIiwgZXh0ZW5zaW9uOiBcInBuZ1wiIH0sXG4gICAgICBcIjQ3NDk0NjM4XCI6IHsgbWltZVR5cGU6IFwiaW1hZ2UvZ2lmXCIsIGV4dGVuc2lvbjogXCJnaWZcIiB9LFxuICAgICAgXCI1MjQ5NDY0NlwiOiB7IG1pbWVUeXBlOiBcImltYWdlL3dlYnBcIiwgZXh0ZW5zaW9uOiBcIndlYnBcIiB9LFxuICAgICAgLy8gUklGRiAoV2ViUCBjb250YWluZXIpXG4gICAgICBcIjQyNGRcIjogeyBtaW1lVHlwZTogXCJpbWFnZS9ibXBcIiwgZXh0ZW5zaW9uOiBcImJtcFwiIH0sXG4gICAgICBcIjQ5NDkyYTAwXCI6IHsgbWltZVR5cGU6IFwiaW1hZ2UvdGlmZlwiLCBleHRlbnNpb246IFwidGlmZlwiIH0sXG4gICAgICBcIjRkNGQwMDJhXCI6IHsgbWltZVR5cGU6IFwiaW1hZ2UvdGlmZlwiLCBleHRlbnNpb246IFwidGlmZlwiIH0sXG4gICAgICAvLyBEb2N1bWVudHNcbiAgICAgIFwiMjU1MDQ0NDZcIjogeyBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIiwgZXh0ZW5zaW9uOiBcInBkZlwiIH0sXG4gICAgICBcIjUwNGIwMzA0XCI6IHsgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vemlwXCIsIGV4dGVuc2lvbjogXCJ6aXBcIiB9LFxuICAgICAgLy8gQWxzbyB1c2VkIGJ5IGRvY3gsIHhsc3hcbiAgICAgIFwiZDBjZjExZTBcIjogeyBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9tc3dvcmRcIiwgZXh0ZW5zaW9uOiBcImRvY1wiIH0sXG4gICAgICAvLyBBdWRpb1xuICAgICAgXCI0OTQ0MzNcIjogeyBtaW1lVHlwZTogXCJhdWRpby9tcGVnXCIsIGV4dGVuc2lvbjogXCJtcDNcIiB9LFxuICAgICAgXCI2NjRjNjE0M1wiOiB7IG1pbWVUeXBlOiBcImF1ZGlvL2ZsYWNcIiwgZXh0ZW5zaW9uOiBcImZsYWNcIiB9LFxuICAgICAgXCI0ZjY3Njc1M1wiOiB7IG1pbWVUeXBlOiBcImF1ZGlvL29nZ1wiLCBleHRlbnNpb246IFwib2dnXCIgfSxcbiAgICAgIC8vIFZpZGVvXG4gICAgICBcIjAwMDAwMFwiOiB7IG1pbWVUeXBlOiBcInZpZGVvL21wNFwiLCBleHRlbnNpb246IFwibXA0XCIgfSxcbiAgICAgIC8vIGZ0eXAgYm94XG4gICAgICBcIjFhNDVkZmEzXCI6IHsgbWltZVR5cGU6IFwidmlkZW8vd2VibVwiLCBleHRlbnNpb246IFwid2VibVwiIH0sXG4gICAgICAvLyBUZXh0XG4gICAgICBcImVmYmJiZlwiOiB7IG1pbWVUeXBlOiBcInRleHQvcGxhaW5cIiwgZXh0ZW5zaW9uOiBcInR4dFwiIH1cbiAgICAgIC8vIFVURi04IEJPTVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbc2lnLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhzaWduYXR1cmVzKSkge1xuICAgICAgaWYgKGhleC5zdGFydHNXaXRoKHNpZykpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoZXguc3RhcnRzV2l0aChcIjUyNDk0NjQ2XCIpICYmIGhleC5zdWJzdHJpbmcoMTYsIDI0KSA9PT0gXCI1NzQ1NDI1MFwiKSB7XG4gICAgICByZXR1cm4geyBtaW1lVHlwZTogXCJpbWFnZS93ZWJwXCIsIGV4dGVuc2lvbjogXCJ3ZWJwXCIgfTtcbiAgICB9XG4gICAgaWYgKGhleC5zdWJzdHJpbmcoOCwgMTYpID09PSBcIjY2NzQ3OTcwXCIpIHtcbiAgICAgIHJldHVybiB7IG1pbWVUeXBlOiBcInZpZGVvL21wNFwiLCBleHRlbnNpb246IFwibXA0XCIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWltZVR5cGU6IFwiXCIsIGV4dGVuc2lvbjogXCJcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZmlsZSBleHRlbnNpb24gZnJvbSBNSU1FIHR5cGUgYXMgZmFsbGJhY2tcbiAgICovXG4gIGdldEV4dGVuc2lvbkZyb21NaW1lVHlwZShtaW1lVHlwZSkge1xuICAgIGNvbnN0IG1pbWVUb0V4dCA9IHtcbiAgICAgIFwiaW1hZ2UvanBlZ1wiOiBcImpwZ1wiLFxuICAgICAgXCJpbWFnZS9wbmdcIjogXCJwbmdcIixcbiAgICAgIFwiaW1hZ2UvZ2lmXCI6IFwiZ2lmXCIsXG4gICAgICBcImltYWdlL3dlYnBcIjogXCJ3ZWJwXCIsXG4gICAgICBcImltYWdlL2JtcFwiOiBcImJtcFwiLFxuICAgICAgXCJpbWFnZS9zdmcreG1sXCI6IFwic3ZnXCIsXG4gICAgICBcImFwcGxpY2F0aW9uL3BkZlwiOiBcInBkZlwiLFxuICAgICAgXCJ0ZXh0L3BsYWluXCI6IFwidHh0XCIsXG4gICAgICBcInRleHQvaHRtbFwiOiBcImh0bWxcIixcbiAgICAgIFwidGV4dC9jc3NcIjogXCJjc3NcIixcbiAgICAgIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOiBcImpzXCIsXG4gICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjogXCJqc29uXCIsXG4gICAgICBcImF1ZGlvL21wZWdcIjogXCJtcDNcIixcbiAgICAgIFwiYXVkaW8vd2F2XCI6IFwid2F2XCIsXG4gICAgICBcImF1ZGlvL29nZ1wiOiBcIm9nZ1wiLFxuICAgICAgXCJ2aWRlby9tcDRcIjogXCJtcDRcIixcbiAgICAgIFwidmlkZW8vd2VibVwiOiBcIndlYm1cIixcbiAgICAgIFwiYXBwbGljYXRpb24vemlwXCI6IFwiemlwXCJcbiAgICB9O1xuICAgIHJldHVybiBtaW1lVG9FeHRbbWltZVR5cGVdIHx8IFwiYmluXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGRvd25sb2FkIFVSTCBmb3IgYSBmaWxlIHRoYXQgdHJpZ2dlcnMgYnJvd3NlciBkb3dubG9hZFxuICAgKiBcbiAgICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIHRoZSBmaWxlIGluIHByb2plY3Qgc3RvcmFnZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIERvd25sb2FkIG9wdGlvbnMgaW5jbHVkaW5nIGN1c3RvbSBmaWxlbmFtZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBkb3dubG9hZCByZXNwb25zZSB3aXRoIGRvd25sb2FkIFVSTFxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gRG93bmxvYWQgd2l0aCBvcmlnaW5hbCBmaWxlbmFtZVxuICAgKiBjb25zdCB7IGRvd25sb2FkVXJsLCBmaWxlbmFtZSB9ID0gYXdhaXQgYmxpbmsuc3RvcmFnZS5kb3dubG9hZCgnaW1hZ2VzL3Bob3RvLmpwZycpO1xuICAgKiB3aW5kb3cub3Blbihkb3dubG9hZFVybCwgJ19ibGFuaycpO1xuICAgKiBcbiAgICogLy8gRG93bmxvYWQgd2l0aCBjdXN0b20gZmlsZW5hbWVcbiAgICogY29uc3QgeyBkb3dubG9hZFVybCB9ID0gYXdhaXQgYmxpbmsuc3RvcmFnZS5kb3dubG9hZChcbiAgICogICAnaW1hZ2VzL3Bob3RvLmpwZycsXG4gICAqICAgeyBmaWxlbmFtZTogJ215LXBob3RvLmpwZycgfVxuICAgKiApO1xuICAgKiBcbiAgICogLy8gQ3JlYXRlIGRvd25sb2FkIGxpbmsgaW4gUmVhY3RcbiAgICogPGEgaHJlZj17ZG93bmxvYWRVcmx9IGRvd25sb2FkPXtmaWxlbmFtZX0+RG93bmxvYWQgSW1hZ2U8L2E+XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZG93bmxvYWQocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcGF0aCB8fCB0eXBlb2YgcGF0aCAhPT0gXCJzdHJpbmdcIiB8fCAhcGF0aC50cmltKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJlcXVlc3QoXG4gICAgICAgIGAvYXBpL3N0b3JhZ2UvJHt0aGlzLmh0dHBDbGllbnQucHJvamVjdElkfS9kb3dubG9hZGAsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgc2VhcmNoUGFyYW1zOiB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLnRyaW0oKSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuZmlsZW5hbWUgJiYgeyBmaWxlbmFtZTogb3B0aW9ucy5maWxlbmFtZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/LmRvd25sb2FkVXJsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG93bmxvYWRVcmw6IHJlc3BvbnNlLmRhdGEuZG93bmxvYWRVcmwsXG4gICAgICAgICAgZmlsZW5hbWU6IHJlc3BvbnNlLmRhdGEuZmlsZW5hbWUgfHwgb3B0aW9ucy5maWxlbmFtZSB8fCBwYXRoLnNwbGl0KFwiL1wiKS5wb3AoKSB8fCBcImRvd25sb2FkXCIsXG4gICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmRhdGEuY29udGVudFR5cGUsXG4gICAgICAgICAgc2l6ZTogcmVzcG9uc2UuZGF0YS5zaXplXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDogbWlzc2luZyBkb3dubG9hZFVybFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtTdG9yYWdlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBcInN0YXR1c1wiIGluIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycm9yLnN0YXR1cztcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiRmlsZSBub3QgZm91bmRcIiwgNDA0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVyc1wiLCA0MDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXG4gICAgICAgIGBEb3dubG9hZCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBvbmUgb3IgbW9yZSBmaWxlcyBmcm9tIHByb2plY3Qgc3RvcmFnZVxuICAgKiBcbiAgICogQHBhcmFtIHBhdGhzIC0gRmlsZSBwYXRocyB0byByZW1vdmVcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gZmlsZXMgYXJlIHJlbW92ZWRcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGF3YWl0IGJsaW5rLnN0b3JhZ2UucmVtb3ZlKCdhdmF0YXJzL3VzZXIxLnBuZycpO1xuICAgKiBhd2FpdCBibGluay5zdG9yYWdlLnJlbW92ZSgnZmlsZTEucGRmJywgJ2ZpbGUyLnBkZicsICdmaWxlMy5wZGYnKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyByZW1vdmUoLi4ucGF0aHMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJBdCBsZWFzdCBvbmUgcGF0aCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGlmICghcGF0aCB8fCB0eXBlb2YgcGF0aCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua1N0b3JhZ2VFcnJvcihcIkFsbCBwYXRocyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmh0dHBDbGllbnQucmVxdWVzdChcbiAgICAgICAgYC9hcGkvc3RvcmFnZS8ke3RoaXMuaHR0cENsaWVudC5wcm9qZWN0SWR9L3JlbW92ZWAsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgYm9keTogeyBwYXRocyB9LFxuICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua1N0b3JhZ2VFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIFwic3RhdHVzXCIgaW4gZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3Iuc3RhdHVzO1xuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVyc1wiLCA0MDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcmVtb3ZlIGZpbGVzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdG9vbHMvY29yZS50c1xudmFyIHdlYlNlYXJjaCA9IFwid2ViX3NlYXJjaFwiO1xudmFyIGZldGNoVXJsID0gXCJmZXRjaF91cmxcIjtcbnZhciBydW5Db2RlID0gXCJydW5fY29kZVwiO1xudmFyIGNvcmVUb29scyA9IFt3ZWJTZWFyY2gsIGZldGNoVXJsLCBydW5Db2RlXTtcblxuLy8gc3JjL3Rvb2xzL3NhbmRib3gudHNcbnZhciByZWFkRmlsZSA9IFwicmVhZF9maWxlXCI7XG52YXIgbGlzdERpciA9IFwibGlzdF9kaXJcIjtcbnZhciB3cml0ZUZpbGUgPSBcIndyaXRlX2ZpbGVcIjtcbnZhciBzZWFyY2hSZXBsYWNlID0gXCJzZWFyY2hfcmVwbGFjZVwiO1xudmFyIGdyZXAgPSBcImdyZXBcIjtcbnZhciBnbG9iRmlsZVNlYXJjaCA9IFwiZ2xvYl9maWxlX3NlYXJjaFwiO1xudmFyIHJ1blRlcm1pbmFsQ21kID0gXCJydW5fdGVybWluYWxfY21kXCI7XG52YXIgZ2V0SG9zdCA9IFwiZ2V0X2hvc3RcIjtcbnZhciBzYW5kYm94VG9vbHMgPSBbXG4gIHJlYWRGaWxlLFxuICBsaXN0RGlyLFxuICB3cml0ZUZpbGUsXG4gIHNlYXJjaFJlcGxhY2UsXG4gIGdyZXAsXG4gIGdsb2JGaWxlU2VhcmNoLFxuICBydW5UZXJtaW5hbENtZCxcbiAgZ2V0SG9zdFxuXTtcblxuLy8gc3JjL3Rvb2xzL2RiLnRzXG52YXIgZGJJbnNlcnQgPSBcImRiX2luc2VydFwiO1xudmFyIGRiTGlzdCA9IFwiZGJfbGlzdFwiO1xudmFyIGRiR2V0ID0gXCJkYl9nZXRcIjtcbnZhciBkYlVwZGF0ZSA9IFwiZGJfdXBkYXRlXCI7XG52YXIgZGJEZWxldGUgPSBcImRiX2RlbGV0ZVwiO1xudmFyIGRiVG9vbHMgPSBbZGJJbnNlcnQsIGRiTGlzdCwgZGJHZXQsIGRiVXBkYXRlLCBkYkRlbGV0ZV07XG5cbi8vIHNyYy90b29scy9zdG9yYWdlLnRzXG52YXIgc3RvcmFnZVVwbG9hZCA9IFwic3RvcmFnZV91cGxvYWRcIjtcbnZhciBzdG9yYWdlRG93bmxvYWQgPSBcInN0b3JhZ2VfZG93bmxvYWRcIjtcbnZhciBzdG9yYWdlTGlzdCA9IFwic3RvcmFnZV9saXN0XCI7XG52YXIgc3RvcmFnZURlbGV0ZSA9IFwic3RvcmFnZV9kZWxldGVcIjtcbnZhciBzdG9yYWdlUHVibGljVXJsID0gXCJzdG9yYWdlX3B1YmxpY191cmxcIjtcbnZhciBzdG9yYWdlTW92ZSA9IFwic3RvcmFnZV9tb3ZlXCI7XG52YXIgc3RvcmFnZUNvcHkgPSBcInN0b3JhZ2VfY29weVwiO1xudmFyIHN0b3JhZ2VUb29scyA9IFtcbiAgc3RvcmFnZVVwbG9hZCxcbiAgc3RvcmFnZURvd25sb2FkLFxuICBzdG9yYWdlTGlzdCxcbiAgc3RvcmFnZURlbGV0ZSxcbiAgc3RvcmFnZVB1YmxpY1VybCxcbiAgc3RvcmFnZU1vdmUsXG4gIHN0b3JhZ2VDb3B5XG5dO1xuXG4vLyBzcmMvdG9vbHMvcmFnLnRzXG52YXIgcmFnU2VhcmNoID0gXCJyYWdfc2VhcmNoXCI7XG52YXIgcmFnVG9vbHMgPSBbcmFnU2VhcmNoXTtcblxuLy8gc3JjL3Rvb2xzL21lZGlhLnRzXG52YXIgZ2VuZXJhdGVJbWFnZSA9IFwiZ2VuZXJhdGVfaW1hZ2VcIjtcbnZhciBlZGl0SW1hZ2UgPSBcImVkaXRfaW1hZ2VcIjtcbnZhciBnZW5lcmF0ZVZpZGVvID0gXCJnZW5lcmF0ZV92aWRlb1wiO1xudmFyIGltYWdlVG9WaWRlbyA9IFwiaW1hZ2VfdG9fdmlkZW9cIjtcbnZhciBtZWRpYVRvb2xzID0gW2dlbmVyYXRlSW1hZ2UsIGVkaXRJbWFnZSwgZ2VuZXJhdGVWaWRlbywgaW1hZ2VUb1ZpZGVvXTtcblxuLy8gc3JjL3Rvb2xzL2luZGV4LnRzXG5mdW5jdGlvbiBzZXJpYWxpemVUb29scyh0b29scykge1xuICByZXR1cm4gdG9vbHM7XG59XG5cbi8vIHNyYy9hZ2VudC50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcENvbmRpdGlvbnMobWF4U3RlcHMsIHN0b3BXaGVuKSB7XG4gIGlmIChzdG9wV2hlbiAmJiBzdG9wV2hlbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHN0b3BXaGVuO1xuICB9XG4gIGlmIChtYXhTdGVwcyAmJiBtYXhTdGVwcyA+IDApIHtcbiAgICByZXR1cm4gW3sgdHlwZTogXCJzdGVwX2NvdW50X2lzXCIsIGNvdW50OiBtYXhTdGVwcyB9XTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxudmFyIEFnZW50ID0gY2xhc3Mge1xuICBodHRwQ2xpZW50ID0gbnVsbDtcbiAgY29uZmlnO1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFnZW50IGluc3RhbmNlLlxuICAgKiBBdXRvLWJpbmRzIHRvIGRlZmF1bHQgY2xpZW50IGlmIGNyZWF0ZUNsaWVudCgpIHdhcyBjYWxsZWQuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFnZW50IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5tb2RlbCkge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkFnZW50IG1vZGVsIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZyA9IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaHR0cENsaWVudCA9IF9nZXREZWZhdWx0SHR0cENsaWVudCgpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWw6IFNldCB0aGUgSFRUUCBjbGllbnQgKGNhbGxlZCBieSBCbGlua0NsaWVudClcbiAgICovXG4gIF9zZXRIdHRwQ2xpZW50KGNsaWVudCkge1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWw6IEdldCB0aGUgYWdlbnQgY29uZmlnIGZvciBBUEkgcmVxdWVzdHNcbiAgICovXG4gIGdldEFnZW50Q29uZmlnKCkge1xuICAgIGNvbnN0IHsgbW9kZWwsIHN5c3RlbSwgaW5zdHJ1Y3Rpb25zLCB0b29scywgd2ViaG9va1Rvb2xzLCBjbGllbnRUb29scywgdG9vbENob2ljZSwgc3RvcFdoZW4sIG1heFN0ZXBzIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBzZXJpYWxpemVkVG9vbHMgPSB0b29scyA/IHNlcmlhbGl6ZVRvb2xzKHRvb2xzKSA6IHZvaWQgMDtcbiAgICBjb25zdCBzdG9wQ29uZGl0aW9ucyA9IGNyZWF0ZVN0b3BDb25kaXRpb25zKG1heFN0ZXBzLCBzdG9wV2hlbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGVsLFxuICAgICAgc3lzdGVtOiBzeXN0ZW0gfHwgaW5zdHJ1Y3Rpb25zLFxuICAgICAgdG9vbHM6IHNlcmlhbGl6ZWRUb29scyxcbiAgICAgIHdlYmhvb2tfdG9vbHM6IHdlYmhvb2tUb29scyxcbiAgICAgIGNsaWVudF90b29sczogY2xpZW50VG9vbHMsXG4gICAgICB0b29sX2Nob2ljZTogdG9vbENob2ljZSxcbiAgICAgIHN0b3Bfd2hlbjogc3RvcENvbmRpdGlvbnNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJlc3BvbnNlIChub24tc3RyZWFtaW5nKVxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBHZW5lcmF0aW9uIG9wdGlvbnMgKHByb21wdCBvciBtZXNzYWdlcylcbiAgICogQHJldHVybnMgUHJvbWlzZTxBZ2VudFJlc3BvbnNlPiB3aXRoIHRleHQsIHN0ZXBzLCB1c2FnZSwgYW5kIGJpbGxpbmdcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZW50LmdlbmVyYXRlKHtcbiAgICogICBwcm9tcHQ6ICdXaGF0IGlzIHRoZSB3ZWF0aGVyIGluIFNhbiBGcmFuY2lzY28/JyxcbiAgICogfSlcbiAgICogY29uc29sZS5sb2cocmVzdWx0LnRleHQpXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5zdGVwcylcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZShvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmh0dHBDbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIFwiQWdlbnQgbm90IGluaXRpYWxpemVkLiBDYWxsIGNyZWF0ZUNsaWVudCgpIGZpcnN0LCBvciB1c2UgdXNlQWdlbnQoKSBpbiBSZWFjdC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnByb21wdCAmJiAhb3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkVpdGhlciBwcm9tcHQgb3IgbWVzc2FnZXMgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByb21wdCAmJiBvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwicHJvbXB0IGFuZCBtZXNzYWdlcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgIGFnZW50OiB0aGlzLmdldEFnZW50Q29uZmlnKClcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkucHJvbXB0ID0gb3B0aW9ucy5wcm9tcHQ7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkubWVzc2FnZXMgPSBvcHRpb25zLm1lc3NhZ2VzO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2FuZGJveCkge1xuICAgICAgICByZXF1ZXN0Qm9keS5zYW5kYm94X2lkID0gdHlwZW9mIG9wdGlvbnMuc2FuZGJveCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuc2FuZGJveCA6IG9wdGlvbnMuc2FuZGJveC5pZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpQWdlbnQocmVxdWVzdEJvZHksIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0FnZW50XSBnZW5lcmF0ZSBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBBZ2VudCBnZW5lcmF0ZSBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0cmVhbSBhIHJlc3BvbnNlIChyZWFsLXRpbWUpXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFN0cmVhbSBvcHRpb25zIChwcm9tcHQgb3IgbWVzc2FnZXMpXG4gICAqIEByZXR1cm5zIFByb21pc2U8UmVzcG9uc2U+IC0gQUkgU0RLIFVJIE1lc3NhZ2UgU3RyZWFtIGZvciB1c2VDaGF0IGNvbXBhdGliaWxpdHlcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGFnZW50LnN0cmVhbSh7XG4gICAqICAgcHJvbXB0OiAnVGVsbCBtZSBhIHN0b3J5JyxcbiAgICogfSlcbiAgICogXG4gICAqIC8vIFByb2Nlc3Mgc3RyZWFtXG4gICAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtLmJvZHkpIHtcbiAgICogICAvLyBIYW5kbGUgY2h1bmtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHN0cmVhbShvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmh0dHBDbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIFwiQWdlbnQgbm90IGluaXRpYWxpemVkLiBDYWxsIGNyZWF0ZUNsaWVudCgpIGZpcnN0LCBvciB1c2UgdXNlQWdlbnQoKSBpbiBSZWFjdC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnByb21wdCAmJiAhb3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkVpdGhlciBwcm9tcHQgb3IgbWVzc2FnZXMgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByb21wdCAmJiBvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwicHJvbXB0IGFuZCBtZXNzYWdlcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgYWdlbnQ6IHRoaXMuZ2V0QWdlbnRDb25maWcoKVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLnByb21wdCkge1xuICAgICAgICByZXF1ZXN0Qm9keS5wcm9tcHQgPSBvcHRpb25zLnByb21wdDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICByZXF1ZXN0Qm9keS5tZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXM7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zYW5kYm94KSB7XG4gICAgICAgIHJlcXVlc3RCb2R5LnNhbmRib3hfaWQgPSB0eXBlb2Ygb3B0aW9ucy5zYW5kYm94ID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5zYW5kYm94IDogb3B0aW9ucy5zYW5kYm94LmlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaHR0cENsaWVudC5haUFnZW50U3RyZWFtKHJlcXVlc3RCb2R5LCBvcHRpb25zLnNpZ25hbCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQWdlbnRdIHN0cmVhbSBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBBZ2VudCBzdHJlYW0gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFnZW50J3MgbW9kZWxcbiAgICovXG4gIGdldCBtb2RlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubW9kZWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYWdlbnQncyBzeXN0ZW0gcHJvbXB0XG4gICAqL1xuICBnZXQgc3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5zeXN0ZW0gfHwgdGhpcy5jb25maWcuaW5zdHJ1Y3Rpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFnZW50J3MgdG9vbHNcbiAgICovXG4gIGdldCB0b29scygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcudG9vbHM7XG4gIH1cbn07XG5mdW5jdGlvbiBzdGVwQ291bnRJcyhjb3VudCkge1xuICByZXR1cm4geyB0eXBlOiBcInN0ZXBfY291bnRfaXNcIiwgY291bnQgfTtcbn1cblxuLy8gc3JjL2FpLnRzXG52YXIgQmxpbmtBSUltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICB9XG4gIC8vIFN1cHBvcnRlZCBpbWFnZSBmb3JtYXRzIGZvciB2YWxpZGF0aW9uXG4gIFNVUFBPUlRFRF9JTUFHRV9GT1JNQVRTID0gW1wianBnXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcImdpZlwiLCBcIndlYnBcIl07XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgYSBVUkwgaXMgYSB2YWxpZCBIVFRQUyBpbWFnZSBVUkxcbiAgICovXG4gIHZhbGlkYXRlSW1hZ2VVcmwodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIkltYWdlIFVSTHMgbXVzdCB1c2UgSFRUUFMgcHJvdG9jb2xcIiB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGhhc1ZhbGlkRXh0ZW5zaW9uID0gdGhpcy5TVVBQT1JURURfSU1BR0VfRk9STUFUUy5zb21lKFxuICAgICAgICAoZm9ybWF0KSA9PiBwYXRobmFtZS5lbmRzV2l0aChgLiR7Zm9ybWF0fWApXG4gICAgICApO1xuICAgICAgaWYgKCFoYXNWYWxpZEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgSW1hZ2UgVVJMIG11c3QgZW5kIHdpdGggYSBzdXBwb3J0ZWQgZm9ybWF0OiAke3RoaXMuU1VQUE9SVEVEX0lNQUdFX0ZPUk1BVFMuam9pbihcIiwgXCIpfWBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBcIkludmFsaWQgVVJMIGZvcm1hdFwiIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgbWVzc2FnZXMgZm9yIGltYWdlIGNvbnRlbnRcbiAgICovXG4gIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlLCBtZXNzYWdlSW5kZXgpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UuY29udGVudCkpIHtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50LmZvckVhY2goKGl0ZW0sIGNvbnRlbnRJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICAgICAgaWYgKCFpdGVtLmltYWdlIHx8IHR5cGVvZiBpdGVtLmltYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKGBNZXNzYWdlICR7bWVzc2FnZUluZGV4fSwgY29udGVudCAke2NvbnRlbnRJbmRleH06IEltYWdlIGNvbnRlbnQgbXVzdCBoYXZlIGEgdmFsaWQgaW1hZ2UgVVJMYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZUltYWdlVXJsKGl0ZW0uaW1hZ2UpO1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGBNZXNzYWdlICR7bWVzc2FnZUluZGV4fSwgY29udGVudCAke2NvbnRlbnRJbmRleH06ICR7dmFsaWRhdGlvbi5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCwgZXJyb3JzIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBNSU1FIHR5cGUgZm9yIGF1ZGlvIGZvcm1hdFxuICAgKi9cbiAgZ2V0TWltZVR5cGVGb3JGb3JtYXQoZm9ybWF0KSB7XG4gICAgY29uc3QgbWltZVR5cGVzID0ge1xuICAgICAgbXAzOiBcImF1ZGlvL21wZWdcIixcbiAgICAgIG9wdXM6IFwiYXVkaW8vb3B1c1wiLFxuICAgICAgYWFjOiBcImF1ZGlvL2FhY1wiLFxuICAgICAgZmxhYzogXCJhdWRpby9mbGFjXCIsXG4gICAgICB3YXY6IFwiYXVkaW8vd2F2XCIsXG4gICAgICBwY206IFwiYXVkaW8vcGNtXCJcbiAgICB9O1xuICAgIHJldHVybiBtaW1lVHlwZXNbZm9ybWF0XSB8fCBcImF1ZGlvL21wZWdcIjtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgdGV4dCByZXNwb25zZSB1c2luZyB0aGUgQmxpbmsgQUkgZW5naW5lLlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBlaXRoZXI6XG4gICAqICAgLSBgcHJvbXB0YDogYSBzaW1wbGUgc3RyaW5nIHByb21wdFxuICAgKiAgIC0gT1IgYG1lc3NhZ2VzYDogYW4gYXJyYXkgb2YgY2hhdCBtZXNzYWdlcyBmb3IgY29udmVyc2F0aW9uXG4gICAqICAgLSBQbHVzIG9wdGlvbmFsIG1vZGVsLCBzZWFyY2gsIG1heFN0ZXBzLCBleHBlcmltZW50YWxfY29udGludWVTdGVwcywgbWF4VG9rZW5zLCB0ZW1wZXJhdHVyZSwgc2lnbmFsIHBhcmFtZXRlcnNcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIFNpbXBsZSBwcm9tcHRcbiAgICogY29uc3QgeyB0ZXh0IH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVRleHQoeyBcbiAgICogICBwcm9tcHQ6IFwiV3JpdGUgYSBwb2VtIGFib3V0IGNvZGluZ1wiIFxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIENoYXQgbWVzc2FnZXMgKHRleHQgb25seSlcbiAgICogY29uc3QgeyB0ZXh0IH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVRleHQoe1xuICAgKiAgIG1lc3NhZ2VzOiBbXG4gICAqICAgICB7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IFwiWW91IGFyZSBhIGhlbHBmdWwgYXNzaXN0YW50XCIgfSxcbiAgICogICAgIHsgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IFwiRXhwbGFpbiBxdWFudHVtIGNvbXB1dGluZ1wiIH1cbiAgICogICBdXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gV2l0aCBpbWFnZSBjb250ZW50XG4gICAqIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVUZXh0KHtcbiAgICogICBtZXNzYWdlczogW1xuICAgKiAgICAgeyBcbiAgICogICAgICAgcm9sZTogXCJ1c2VyXCIsIFxuICAgKiAgICAgICBjb250ZW50OiBbXG4gICAqICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogXCJXaGF0IGRvIHlvdSBzZWUgaW4gdGhpcyBpbWFnZT9cIiB9LFxuICAgKiAgICAgICAgIHsgdHlwZTogXCJpbWFnZVwiLCBpbWFnZTogXCJodHRwczovL2V4YW1wbGUuY29tL3Bob3RvLmpwZ1wiIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfVxuICAgKiAgIF1cbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBNaXhlZCBjb250ZW50IHdpdGggbXVsdGlwbGUgaW1hZ2VzXG4gICAqIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVUZXh0KHtcbiAgICogICBtZXNzYWdlczogW1xuICAgKiAgICAgeyBcbiAgICogICAgICAgcm9sZTogXCJ1c2VyXCIsIFxuICAgKiAgICAgICBjb250ZW50OiBbXG4gICAqICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogXCJDb21wYXJlIHRoZXNlIHR3byBpbWFnZXM6XCIgfSxcbiAgICogICAgICAgICB7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9pbWFnZTEuanBnXCIgfSxcbiAgICogICAgICAgICB7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9pbWFnZTIuanBnXCIgfVxuICAgKiAgICAgICBdXG4gICAqICAgICB9XG4gICAqICAgXVxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIFdpdGggb3B0aW9uc1xuICAgKiBjb25zdCB7IHRleHQsIHVzYWdlIH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVRleHQoe1xuICAgKiAgIHByb21wdDogXCJTdW1tYXJpemUgdGhpcyBhcnRpY2xlXCIsXG4gICAqICAgbW9kZWw6IFwiZ3B0LTQuMS1taW5pXCIsXG4gICAqICAgbWF4VG9rZW5zOiAxNTAsXG4gICAqICAgdGVtcGVyYXR1cmU6IDAuN1xuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIFdpdGggd2ViIHNlYXJjaCAoT3BlbkFJIG1vZGVscyBvbmx5KVxuICAgKiBjb25zdCB7IHRleHQsIHNvdXJjZXMgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlVGV4dCh7XG4gICAqICAgcHJvbXB0OiBcIldoYXQgYXJlIHRoZSBsYXRlc3QgZGV2ZWxvcG1lbnRzIGluIEFJP1wiLFxuICAgKiAgIG1vZGVsOiBcImdwdC00LjEtbWluaVwiLFxuICAgKiAgIHNlYXJjaDogdHJ1ZSAvLyBFbmFibGVzIHdlYiBzZWFyY2hcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBXaXRoIGFkdmFuY2VkIG11bHRpLXN0ZXAgY29uZmlndXJhdGlvblxuICAgKiBjb25zdCB7IHRleHQgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlVGV4dCh7XG4gICAqICAgcHJvbXB0OiBcIlJlc2VhcmNoIGFuZCBhbmFseXplIHJlY2VudCB0ZWNoIHRyZW5kc1wiLFxuICAgKiAgIG1vZGVsOiBcImdwdC00b1wiLFxuICAgKiAgIHNlYXJjaDogdHJ1ZSxcbiAgICogICBtYXhTdGVwczogMTAsIC8vIEFsbG93IHVwIHRvIDEwIHJlYXNvbmluZyBzdGVwc1xuICAgKiAgIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiB0cnVlIC8vIEVuYWJsZSBjb250aW51ZWQgcmVhc29uaW5nXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogXG4gICAqIEByZXR1cm5zIFByb21pc2U8VGV4dEdlbmVyYXRpb25SZXNwb25zZT4gLSBPYmplY3QgY29udGFpbmluZzpcbiAgICogICAtIGB0ZXh0YDogR2VuZXJhdGVkIHRleHQgc3RyaW5nXG4gICAqICAgLSBgdXNhZ2VgOiBUb2tlbiB1c2FnZSBpbmZvcm1hdGlvblxuICAgKiAgIC0gYGZpbmlzaFJlYXNvbmA6IFdoeSBnZW5lcmF0aW9uIHN0b3BwZWQgKFwic3RvcFwiLCBcImxlbmd0aFwiLCBldGMuKVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUZXh0KG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb21wdCAmJiAhb3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiRWl0aGVyIHByb21wdCBvciBtZXNzYWdlcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlTWVzc2FnZXMob3B0aW9ucy5tZXNzYWdlcyk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihgTWVzc2FnZSB2YWxpZGF0aW9uIGZhaWxlZDogJHt2YWxpZGF0aW9uLmVycm9ycy5qb2luKFwiOyBcIil9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgc3RyZWFtOiBmYWxzZSxcbiAgICAgICAgc2VhcmNoOiBvcHRpb25zLnNlYXJjaCxcbiAgICAgICAgbWF4U3RlcHM6IG9wdGlvbnMubWF4U3RlcHMsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBvcHRpb25zLmV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzLFxuICAgICAgICBtYXhUb2tlbnM6IG9wdGlvbnMubWF4VG9rZW5zLFxuICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy50ZW1wZXJhdHVyZSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLnByb21wdCkge1xuICAgICAgICByZXF1ZXN0Qm9keS5wcm9tcHQgPSBvcHRpb25zLnByb21wdDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICAgIHJlcXVlc3RCb2R5Lm1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpVGV4dChcbiAgICAgICAgb3B0aW9ucy5wcm9tcHQgfHwgXCJcIixcbiAgICAgICAgcmVxdWVzdEJvZHlcbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBSUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcbiAgICAgICAgYFRleHQgZ2VuZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0cmVhbXMgdGV4dCBnZW5lcmF0aW9uIHdpdGggcmVhbC10aW1lIHVwZGF0ZXMgYXMgdGhlIEFJIGdlbmVyYXRlcyBjb250ZW50LlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTYW1lIGFzIGdlbmVyYXRlVGV4dDogZWl0aGVyIGBwcm9tcHRgIG9yIGBtZXNzYWdlc2Agd2l0aCBvcHRpb25hbCBwYXJhbWV0ZXJzIGluY2x1ZGluZyBzZWFyY2gsIG1heFN0ZXBzLCBleHBlcmltZW50YWxfY29udGludWVTdGVwc1xuICAgKiBAcGFyYW0gb25DaHVuayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgZWFjaCB0ZXh0IGNodW5rIGFzIGl0J3MgZ2VuZXJhdGVkXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBTdHJlYW0gd2l0aCBwcm9tcHRcbiAgICogYXdhaXQgYmxpbmsuYWkuc3RyZWFtVGV4dChcbiAgICogICB7IHByb21wdDogXCJXcml0ZSBhIHNob3J0IHN0b3J5IGFib3V0IHNwYWNlIGV4cGxvcmF0aW9uXCIgfSxcbiAgICogICAoY2h1bmspID0+IHtcbiAgICogICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNodW5rKTsgLy8gUmVhbC10aW1lIG91dHB1dFxuICAgKiAgIH1cbiAgICogKTtcbiAgICogXG4gICAqIC8vIFN0cmVhbSB3aXRoIG1lc3NhZ2VzXG4gICAqIGF3YWl0IGJsaW5rLmFpLnN0cmVhbVRleHQoXG4gICAqICAgeyBcbiAgICogICAgIG1lc3NhZ2VzOiBbXG4gICAqICAgICAgIHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogXCJZb3UgYXJlIGEgY3JlYXRpdmUgd3JpdGVyXCIgfSxcbiAgICogICAgICAgeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogXCJXcml0ZSBhIGhhaWt1IGFib3V0IHByb2dyYW1taW5nXCIgfVxuICAgKiAgICAgXVxuICAgKiAgIH0sXG4gICAqICAgKGNodW5rKSA9PiB1cGRhdGVVSShjaHVuaylcbiAgICogKTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPFRleHRHZW5lcmF0aW9uUmVzcG9uc2U+IC0gRmluYWwgY29tcGxldGUgcmVzcG9uc2Ugd2l0aCBmdWxsIHRleHQgYW5kIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBzdHJlYW1UZXh0KG9wdGlvbnMsIG9uQ2h1bmspIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb21wdCAmJiAhb3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiRWl0aGVyIHByb21wdCBvciBtZXNzYWdlcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlTWVzc2FnZXMob3B0aW9ucy5tZXNzYWdlcyk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihgTWVzc2FnZSB2YWxpZGF0aW9uIGZhaWxlZDogJHt2YWxpZGF0aW9uLmVycm9ycy5qb2luKFwiOyBcIil9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5zdHJlYW1BaVRleHQoXG4gICAgICAgIG9wdGlvbnMucHJvbXB0IHx8IFwiXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgICAgICBzZWFyY2g6IG9wdGlvbnMuc2VhcmNoLFxuICAgICAgICAgIG1heFN0ZXBzOiBvcHRpb25zLm1heFN0ZXBzLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBvcHRpb25zLmV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzLFxuICAgICAgICAgIG1heFRva2Vuczogb3B0aW9ucy5tYXhUb2tlbnMsXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMudGVtcGVyYXR1cmUsXG4gICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICB9LFxuICAgICAgICBvbkNodW5rXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogcmVzdWx0LnRleHQgfHwgXCJcIixcbiAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQuZmluaXNoUmVhc29uIHx8IFwic3RvcFwiLFxuICAgICAgICB1c2FnZTogcmVzdWx0LnVzYWdlLFxuICAgICAgICB0b29sQ2FsbHM6IHJlc3VsdC50b29sQ2FsbHMsXG4gICAgICAgIHRvb2xSZXN1bHRzOiByZXN1bHQudG9vbFJlc3VsdHMsXG4gICAgICAgIHNvdXJjZXM6IHJlc3VsdC5zb3VyY2VzLFxuICAgICAgICBmaWxlczogcmVzdWx0LmZpbGVzLFxuICAgICAgICByZWFzb25pbmdEZXRhaWxzOiByZXN1bHQucmVhc29uaW5nLFxuICAgICAgICByZXNwb25zZTogcmVzdWx0LnJlc3BvbnNlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgVGV4dCBzdHJlYW1pbmcgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgc3RydWN0dXJlZCBKU09OIG9iamVjdHMgdXNpbmcgQUkgd2l0aCBzY2hlbWEgdmFsaWRhdGlvbi5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgcHJvbXB0YDogRGVzY3JpcHRpb24gb2Ygd2hhdCBvYmplY3QgdG8gZ2VuZXJhdGUgKHJlcXVpcmVkKVxuICAgKiAgIC0gYHNjaGVtYWA6IEpTT04gU2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBnZW5lcmF0ZWQgb2JqZWN0XG4gICAqICAgLSBgb3V0cHV0YDogVHlwZSBvZiBvdXRwdXQgKFwib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJlbnVtXCIpXG4gICAqICAgLSBgZW51bWA6IEFycmF5IG9mIGFsbG93ZWQgdmFsdWVzIGZvciBlbnVtIG91dHB1dFxuICAgKiAgIC0gUGx1cyBvcHRpb25hbCBtb2RlbCwgc2lnbmFsIHBhcmFtZXRlcnNcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIEdlbmVyYXRlIHVzZXIgcHJvZmlsZVxuICAgKiBjb25zdCB7IG9iamVjdCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVPYmplY3Qoe1xuICAgKiAgIHByb21wdDogXCJHZW5lcmF0ZSBhIHVzZXIgcHJvZmlsZSBmb3IgYSBzb2Z0d2FyZSBkZXZlbG9wZXJcIixcbiAgICogICBzY2hlbWE6IHtcbiAgICogICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAqICAgICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICAgIG5hbWU6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgKiAgICAgICBhZ2U6IHsgdHlwZTogXCJudW1iZXJcIiB9LFxuICAgKiAgICAgICBza2lsbHM6IHsgdHlwZTogXCJhcnJheVwiLCBpdGVtczogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSxcbiAgICogICAgICAgZXhwZXJpZW5jZTogeyB0eXBlOiBcIm51bWJlclwiIH1cbiAgICogICAgIH0sXG4gICAqICAgICByZXF1aXJlZDogW1wibmFtZVwiLCBcInNraWxsc1wiXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBHZW5lcmF0ZSBhcnJheSBvZiBpdGVtc1xuICAgKiBjb25zdCB7IG9iamVjdCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVPYmplY3Qoe1xuICAgKiAgIHByb21wdDogXCJMaXN0IDUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzXCIsXG4gICAqICAgb3V0cHV0OiBcImFycmF5XCIsXG4gICAqICAgc2NoZW1hOiB7XG4gICAqICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAqICAgICBpdGVtczogeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gR2VuZXJhdGUgZW51bSB2YWx1ZVxuICAgKiBjb25zdCB7IG9iamVjdCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVPYmplY3Qoe1xuICAgKiAgIHByb21wdDogXCJDaG9vc2UgdGhlIGJlc3QgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgZm9yIHdlYiBkZXZlbG9wbWVudFwiLFxuICAgKiAgIG91dHB1dDogXCJlbnVtXCIsXG4gICAqICAgZW51bTogW1wiSmF2YVNjcmlwdFwiLCBcIlB5dGhvblwiLCBcIlR5cGVTY3JpcHRcIiwgXCJHb1wiXVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPE9iamVjdEdlbmVyYXRpb25SZXNwb25zZT4gLSBPYmplY3QgY29udGFpbmluZzpcbiAgICogICAtIGBvYmplY3RgOiBUaGUgZ2VuZXJhdGVkIGFuZCB2YWxpZGF0ZWQgSlNPTiBvYmplY3QvYXJyYXkvZW51bVxuICAgKiAgIC0gYHVzYWdlYDogVG9rZW4gdXNhZ2UgaW5mb3JtYXRpb25cbiAgICogICAtIGBmaW5pc2hSZWFzb25gOiBXaHkgZ2VuZXJhdGlvbiBzdG9wcGVkXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZU9iamVjdChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIlByb21wdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpT2JqZWN0KFxuICAgICAgICBvcHRpb25zLnByb21wdCxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIG91dHB1dDogb3B0aW9ucy5vdXRwdXQsXG4gICAgICAgICAgc2NoZW1hOiBvcHRpb25zLnNjaGVtYSxcbiAgICAgICAgICBlbnVtOiBvcHRpb25zLmVudW0sXG4gICAgICAgICAgc3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBSUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcbiAgICAgICAgYE9iamVjdCBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RyZWFtcyBzdHJ1Y3R1cmVkIG9iamVjdCBnZW5lcmF0aW9uIHdpdGggcmVhbC10aW1lIHBhcnRpYWwgdXBkYXRlcyBhcyB0aGUgQUkgYnVpbGRzIHRoZSBvYmplY3QuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFNhbWUgYXMgZ2VuZXJhdGVPYmplY3Q6IHByb21wdCwgc2NoZW1hLCBvdXRwdXQgdHlwZSwgZXRjLlxuICAgKiBAcGFyYW0gb25QYXJ0aWFsIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBwYXJ0aWFsIG9iamVjdCB1cGRhdGVzIGFzIHRoZXkncmUgZ2VuZXJhdGVkXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBTdHJlYW0gb2JqZWN0IGdlbmVyYXRpb24gd2l0aCBzY2hlbWFcbiAgICogYXdhaXQgYmxpbmsuYWkuc3RyZWFtT2JqZWN0KFxuICAgKiAgIHtcbiAgICogICAgIHByb21wdDogXCJHZW5lcmF0ZSBhIGRldGFpbGVkIHByb2R1Y3QgY2F0YWxvZyBlbnRyeVwiLFxuICAgKiAgICAgc2NoZW1hOiB7XG4gICAqICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAqICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgICAgICBuYW1lOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICogICAgICAgICBwcmljZTogeyB0eXBlOiBcIm51bWJlclwiIH0sXG4gICAqICAgICAgICAgZGVzY3JpcHRpb246IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgKiAgICAgICAgIGZlYXR1cmVzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH1cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIH0sXG4gICAqICAgKHBhcnRpYWwpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiUGFydGlhbCB1cGRhdGU6XCIsIHBhcnRpYWwpO1xuICAgKiAgICAgdXBkYXRlUHJvZHVjdEZvcm0ocGFydGlhbCk7IC8vIFVwZGF0ZSBVSSBpbiByZWFsLXRpbWVcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKiBcbiAgICogQHJldHVybnMgUHJvbWlzZTxPYmplY3RHZW5lcmF0aW9uUmVzcG9uc2U+IC0gRmluYWwgY29tcGxldGUgb2JqZWN0IHdpdGggbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIHN0cmVhbU9iamVjdChvcHRpb25zLCBvblBhcnRpYWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb21wdCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiUHJvbXB0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnN0cmVhbUFpT2JqZWN0KFxuICAgICAgICBvcHRpb25zLnByb21wdCxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIG91dHB1dDogb3B0aW9ucy5vdXRwdXQsXG4gICAgICAgICAgc2NoZW1hOiBvcHRpb25zLnNjaGVtYSxcbiAgICAgICAgICBlbnVtOiBvcHRpb25zLmVudW0sXG4gICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICB9LFxuICAgICAgICBvblBhcnRpYWxcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvYmplY3Q6IHJlc3VsdC5vYmplY3QgfHwge30sXG4gICAgICAgIGZpbmlzaFJlYXNvbjogXCJzdG9wXCIsXG4gICAgICAgIHVzYWdlOiByZXN1bHQudXNhZ2VcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBPYmplY3Qgc3RyZWFtaW5nIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGltYWdlcyBmcm9tIHRleHQgZGVzY3JpcHRpb25zIHVzaW5nIEFJIGltYWdlIG1vZGVscy5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgcHJvbXB0YDogVGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgZGVzaXJlZCBpbWFnZSAocmVxdWlyZWQsIHVwIHRvIDEwMGsgY2hhcmFjdGVycylcbiAgICogICAtIGBtb2RlbGA6IEFJIG1vZGVsIHRvIHVzZSAob3B0aW9uYWwpLiBBdmFpbGFibGUgbW9kZWxzOlxuICAgKiAgICAgICAqKkZhbC5haSBNb2RlbHMgKFJlY29tbWVuZGVkKToqKlxuICAgKiAgICAgICAtIGBcImZhbC1haS9uYW5vLWJhbmFuYVwiYCAoZGVmYXVsdCkgLSBHZW1pbmkgMi41IEZsYXNoIEltYWdlIChGYXN0KVxuICAgKiAgICAgICAtIGBcImZhbC1haS9uYW5vLWJhbmFuYS1wcm9cImAgLSBHZW1pbmkgMyBQcm8gSW1hZ2UgKEhpZ2ggcXVhbGl0eSlcbiAgICogICAgICAgLSBgXCJmYWwtYWkvZ2VtaW5pLTI1LWZsYXNoLWltYWdlXCJgIC0gQWxpYXMgZm9yIG5hbm8tYmFuYW5hXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL2dlbWluaS0zLXByby1pbWFnZS1wcmV2aWV3XCJgIC0gQWxpYXMgZm9yIG5hbm8tYmFuYW5hLXByb1xuICAgKiAgICAgICAqKkxlZ2FjeSBHZW1pbmkgTW9kZWxzOioqXG4gICAqICAgICAgIC0gYFwiZ2VtaW5pLTIuNS1mbGFzaC1pbWFnZS1wcmV2aWV3XCJgIC0gRGlyZWN0IEdlbWluaSBBUElcbiAgICogICAgICAgLSBgXCJnZW1pbmktMy1wcm8taW1hZ2UtcHJldmlld1wiYCAtIERpcmVjdCBHZW1pbmkgQVBJXG4gICAqICAgLSBgbmA6IE51bWJlciBvZiBpbWFnZXMgdG8gZ2VuZXJhdGUgKGRlZmF1bHQ6IDEpXG4gICAqICAgLSBgc2l6ZWA6IEltYWdlIGRpbWVuc2lvbnMgKGUuZy4sIFwiMTAyNHgxMDI0XCIsIFwiNTEyeDUxMlwiKVxuICAgKiAgIC0gUGx1cyBvcHRpb25hbCBzaWduYWwgcGFyYW1ldGVyXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyBpbWFnZSBnZW5lcmF0aW9uICh1c2VzIGRlZmF1bHQgZmFzdCBtb2RlbClcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZUltYWdlKHtcbiAgICogICBwcm9tcHQ6IFwiQSBzZXJlbmUgbGFuZHNjYXBlIHdpdGggbW91bnRhaW5zIGFuZCBhIGxha2UgYXQgc3Vuc2V0XCJcbiAgICogfSk7XG4gICAqIGNvbnNvbGUubG9nKFwiSW1hZ2UgVVJMOlwiLCBkYXRhWzBdLnVybCk7XG4gICAqIFxuICAgKiAvLyBIaWdoIHF1YWxpdHkgZ2VuZXJhdGlvbiB3aXRoIFBybyBtb2RlbFxuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlSW1hZ2Uoe1xuICAgKiAgIHByb21wdDogXCJBIGRldGFpbGVkIGluZm9ncmFwaGljIGFib3V0IEFJIHdpdGggY2hhcnRzIGFuZCBkaWFncmFtc1wiLFxuICAgKiAgIG1vZGVsOiBcImZhbC1haS9uYW5vLWJhbmFuYS1wcm9cIixcbiAgICogICBuOiAyXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gRmFzdCBnZW5lcmF0aW9uIHdpdGggc3BlY2lmaWMgc2l6ZVxuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlSW1hZ2Uoe1xuICAgKiAgIHByb21wdDogXCJBIGZ1dHVyaXN0aWMgY2l0eSBza3lsaW5lIHdpdGggZmx5aW5nIGNhcnNcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvbmFuby1iYW5hbmFcIixcbiAgICogICBzaXplOiBcIjEwMjR4MTAyNFwiLFxuICAgKiAgIG46IDNcbiAgICogfSk7XG4gICAqIGRhdGEuZm9yRWFjaCgoaW1nLCBpKSA9PiBjb25zb2xlLmxvZyhgSW1hZ2UgJHtpKzF9OmAsIGltZy51cmwpKTtcbiAgICogXG4gICAqIC8vIFVzaW5nIGxlZ2FjeSBHZW1pbmkgbW9kZWxcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZUltYWdlKHtcbiAgICogICBwcm9tcHQ6IFwiQSBjdXRlIHJvYm90IG1hc2NvdCBmb3IgYSB0ZWNoIGNvbXBhbnlcIixcbiAgICogICBtb2RlbDogXCJnZW1pbmktMi41LWZsYXNoLWltYWdlLXByZXZpZXdcIlxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPEltYWdlR2VuZXJhdGlvblJlc3BvbnNlPiAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYGRhdGFgOiBBcnJheSBvZiBnZW5lcmF0ZWQgaW1hZ2VzIHdpdGggVVJMc1xuICAgKiAgIC0gYGNyZWF0ZWRgOiBUaW1lc3RhbXAgb2YgZ2VuZXJhdGlvblxuICAgKiAgIC0gYG1vZGVsYDogVGhlIG1vZGVsIHVzZWQgZm9yIGdlbmVyYXRpb25cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlSW1hZ2Uob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvbXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJQcm9tcHQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5haUltYWdlKFxuICAgICAgICBvcHRpb25zLnByb21wdCxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIG46IG9wdGlvbnMubixcbiAgICAgICAgICBzaXplOiBvcHRpb25zLnNpemUsXG4gICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbGV0IGltYWdlUmVzcG9uc2U7XG4gICAgICBpZiAocmVzcG9uc2UuZGF0YT8ucmVzdWx0Py5kYXRhKSB7XG4gICAgICAgIGltYWdlUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuZGF0YT8uZGF0YSkge1xuICAgICAgICBpbWFnZVJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDogbWlzc2luZyBpbWFnZSBkYXRhXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGltYWdlUmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBkYXRhIHNob3VsZCBiZSBhbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIGltYWdlUmVzcG9uc2UuZGF0YSA9IGltYWdlUmVzcG9uc2UuZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdXJsOiBpdGVtIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS51cmwpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiSW52YWxpZCBpbWFnZSByZXNwb25zZSBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGltYWdlUmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBJbWFnZSBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW9kaWZpZXMgZXhpc3RpbmcgaW1hZ2VzIHVzaW5nIEFJIGltYWdlIGVkaXRpbmcgbW9kZWxzIHdpdGggdGV4dCBwcm9tcHRzIGZvciBpbWFnZS10by1pbWFnZSBlZGl0aW5nLlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgY29udGFpbmluZzpcbiAgICogICAtIGBpbWFnZXNgOiBBcnJheSBvZiBwdWJsaWMgaW1hZ2UgVVJMcyB0byBtb2RpZnkgKHJlcXVpcmVkLCB1cCB0byA1MCBpbWFnZXMpXG4gICAqICAgLSBgcHJvbXB0YDogVGV4dCBkZXNjcmlwdGlvbiBvZiBkZXNpcmVkIG1vZGlmaWNhdGlvbnMgKHJlcXVpcmVkLCB1cCB0byAxMDBrIGNoYXJhY3RlcnMpXG4gICAqICAgLSBgbW9kZWxgOiBBSSBtb2RlbCB0byB1c2UgKG9wdGlvbmFsKS4gQXZhaWxhYmxlIGVkaXRpbmcgbW9kZWxzOlxuICAgKiAgICAgICAqKkZhbC5haSBFZGl0aW5nIE1vZGVscyAoUmVjb21tZW5kZWQpOioqXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL25hbm8tYmFuYW5hL2VkaXRcImAgKGRlZmF1bHQpIC0gRmxhc2ggZWRpdGluZyAoRmFzdClcbiAgICogICAgICAgLSBgXCJmYWwtYWkvbmFuby1iYW5hbmEtcHJvL2VkaXRcImAgLSBQcm8gZWRpdGluZyAoSGlnaCBxdWFsaXR5KVxuICAgKiAgICAgICAtIGBcImZhbC1haS9nZW1pbmktMjUtZmxhc2gtaW1hZ2UvZWRpdFwiYCAtIEFsaWFzIGZvciBuYW5vLWJhbmFuYS9lZGl0XG4gICAqICAgICAgIC0gYFwiZmFsLWFpL2dlbWluaS0zLXByby1pbWFnZS1wcmV2aWV3L2VkaXRcImAgLSBBbGlhcyBmb3IgbmFuby1iYW5hbmEtcHJvL2VkaXRcbiAgICogICAgICAgKipMZWdhY3kgR2VtaW5pIE1vZGVsczoqKlxuICAgKiAgICAgICAtIGBcImdlbWluaS0yLjUtZmxhc2gtaW1hZ2UtcHJldmlld1wiYCAtIERpcmVjdCBHZW1pbmkgQVBJXG4gICAqICAgICAgIC0gYFwiZ2VtaW5pLTMtcHJvLWltYWdlLXByZXZpZXdcImAgLSBEaXJlY3QgR2VtaW5pIEFQSVxuICAgKiAgIC0gYG5gOiBOdW1iZXIgb2Ygb3V0cHV0IGltYWdlcyB0byBnZW5lcmF0ZSAoZGVmYXVsdDogMSlcbiAgICogICAtIFBsdXMgb3B0aW9uYWwgc2lnbmFsIHBhcmFtZXRlclxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gRmFzdCBlZGl0aW5nIHdpdGggZGVmYXVsdCBtb2RlbFxuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJsaW5rLmFpLm1vZGlmeUltYWdlKHtcbiAgICogICBpbWFnZXM6IFtcImh0dHBzOi8vc3RvcmFnZS5leGFtcGxlLmNvbS9waG90by5qcGdcIl0sXG4gICAqICAgcHJvbXB0OiBcIm1ha2UgaXQgZ3JlZW5cIlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIEhpZ2ggcXVhbGl0eSBlZGl0aW5nIHdpdGggUHJvIG1vZGVsXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYmxpbmsuYWkubW9kaWZ5SW1hZ2Uoe1xuICAgKiAgIGltYWdlczogW1wiaHR0cHM6Ly9zdG9yYWdlLmV4YW1wbGUuY29tL2xhbmRzY2FwZS5qcGdcIl0sXG4gICAqICAgcHJvbXB0OiBcImFkZCBhIHRyZWUgaW4gdGhlIGJhY2tncm91bmRcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvbmFuby1iYW5hbmEtcHJvL2VkaXRcIlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIFByb2Zlc3Npb25hbCBoZWFkc2hvdHMgZnJvbSBjYXN1YWwgcGhvdG9zXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYmxpbmsuYWkubW9kaWZ5SW1hZ2Uoe1xuICAgKiAgIGltYWdlczogW1xuICAgKiAgICAgXCJodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vdXNlci1waG90by0xLmpwZ1wiLFxuICAgKiAgICAgXCJodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vdXNlci1waG90by0yLmpwZ1wiXG4gICAqICAgXSxcbiAgICogICBwcm9tcHQ6IFwiVHJhbnNmb3JtIGludG8gcHJvZmVzc2lvbmFsIGJ1c2luZXNzIGhlYWRzaG90cyB3aXRoIHN0dWRpbyBsaWdodGluZ1wiLFxuICAgKiAgIG1vZGVsOiBcImZhbC1haS9uYW5vLWJhbmFuYS9lZGl0XCIsXG4gICAqICAgbjogNFxuICAgKiB9KTtcbiAgICogZGF0YS5mb3JFYWNoKChpbWcsIGkpID0+IGNvbnNvbGUubG9nKGBIZWFkc2hvdCAke2krMX06YCwgaW1nLnVybCkpO1xuICAgKiBcbiAgICogLy8gQXJ0aXN0aWMgc3R5bGUgdHJhbnNmb3JtYXRpb25cbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5tb2RpZnlJbWFnZSh7XG4gICAqICAgaW1hZ2VzOiBbXCJodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vcG9ydHJhaXQuanBnXCJdLFxuICAgKiAgIHByb21wdDogXCJUcmFuc2Zvcm0gaW50byBvaWwgcGFpbnRpbmcgc3R5bGUgd2l0aCBkcmFtYXRpYyBsaWdodGluZ1wiLFxuICAgKiAgIG1vZGVsOiBcImZhbC1haS9uYW5vLWJhbmFuYS1wcm8vZWRpdFwiXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gQmFja2dyb3VuZCByZXBsYWNlbWVudFxuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJsaW5rLmFpLm1vZGlmeUltYWdlKHtcbiAgICogICBpbWFnZXM6IFtcImh0dHBzOi8vc3RvcmFnZS5leGFtcGxlLmNvbS9wcm9kdWN0LmpwZ1wiXSxcbiAgICogICBwcm9tcHQ6IFwiUmVtb3ZlIGJhY2tncm91bmQgYW5kIHBsYWNlIG9uIGNsZWFuIHdoaXRlIHN0dWRpbyBiYWNrZ3JvdW5kXCIsXG4gICAqICAgbjogMlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIEJhdGNoIHByb2Nlc3NpbmcgbXVsdGlwbGUgcGhvdG9zXG4gICAqIGNvbnN0IHVzZXJQaG90b3MgPSBbXG4gICAqICAgXCJodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vcGhvdG8xLmpwZ1wiLFxuICAgKiAgIFwiaHR0cHM6Ly9zdG9yYWdlLmV4YW1wbGUuY29tL3Bob3RvMi5qcGdcIixcbiAgICogICBcImh0dHBzOi8vc3RvcmFnZS5leGFtcGxlLmNvbS9waG90bzMuanBnXCJcbiAgICogXTtcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5tb2RpZnlJbWFnZSh7XG4gICAqICAgaW1hZ2VzOiB1c2VyUGhvdG9zLFxuICAgKiAgIHByb21wdDogXCJDb252ZXJ0IHRvIGJsYWNrIGFuZCB3aGl0ZSB2aW50YWdlIHN0eWxlIHBob3RvZ3JhcGhzXCJcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyDwn46oIFN0eWxlIFRyYW5zZmVyIC0gSU1QT1JUQU5UOiBQcm92aWRlIGFsbCBpbWFnZXMgaW4gYXJyYXlcbiAgICogLy8g4p2MIFdST05HIC0gRG9uJ3QgcmVmZXJlbmNlIG90aGVyIGltYWdlcyBpbiBwcm9tcHRcbiAgICogY29uc3Qgd3JvbmcgPSBhd2FpdCBibGluay5haS5tb2RpZnlJbWFnZSh7XG4gICAqICAgaW1hZ2VzOiBbdXNlclBob3RvVXJsXSxcbiAgICogICBwcm9tcHQ6IGBBcHBseSBoYWlyc3R5bGUgZnJvbSAke3JlZmVyZW5jZVVybH1gXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8g4pyFIENPUlJFQ1QgLSBQcm92aWRlIGFsbCBpbWFnZXMgaW4gYXJyYXlcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5tb2RpZnlJbWFnZSh7XG4gICAqICAgaW1hZ2VzOiBbdXNlclBob3RvVXJsLCBoYWlyc3R5bGVSZWZlcmVuY2VVcmxdLFxuICAgKiAgIHByb21wdDogXCJBcHBseSB0aGUgaGFpcnN0eWxlIGZyb20gdGhlIHNlY29uZCBpbWFnZSB0byB0aGUgcGVyc29uIGluIHRoZSBmaXJzdCBpbWFnZVwiXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogXG4gICAqIEByZXR1cm5zIFByb21pc2U8SW1hZ2VHZW5lcmF0aW9uUmVzcG9uc2U+IC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgZGF0YWA6IEFycmF5IG9mIG1vZGlmaWVkIGltYWdlcyB3aXRoIFVSTHNcbiAgICogICAtIGBjcmVhdGVkYDogVGltZXN0YW1wIG9mIGdlbmVyYXRpb25cbiAgICogICAtIGBtb2RlbGA6IFRoZSBtb2RlbCB1c2VkIGZvciBlZGl0aW5nXG4gICAqL1xuICBhc3luYyBtb2RpZnlJbWFnZShvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIlByb21wdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5pbWFnZXMgfHwgIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbWFnZXMpIHx8IG9wdGlvbnMuaW1hZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiSW1hZ2VzIGFycmF5IGlzIHJlcXVpcmVkIGFuZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGltYWdlIFVSTFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmltYWdlcy5sZW5ndGggPiA1MCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiTWF4aW11bSA1MCBpbWFnZXMgYWxsb3dlZFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5pbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVJbWFnZVVybChvcHRpb25zLmltYWdlc1tpXSk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihgSW1hZ2UgJHtpICsgMX06ICR7dmFsaWRhdGlvbi5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuYWlJbWFnZShcbiAgICAgICAgb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIC8vIE5vbi1udWxsIGFzc2VydGlvbiBzaW5jZSB3ZSB2YWxpZGF0ZWQgYWJvdmVcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIGltYWdlczogb3B0aW9ucy5pbWFnZXMsXG4gICAgICAgICAgbjogb3B0aW9ucy5uLFxuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGxldCBpbWFnZVJlc3BvbnNlO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/LnJlc3VsdD8uZGF0YSkge1xuICAgICAgICBpbWFnZVJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmRhdGE/LmRhdGEpIHtcbiAgICAgICAgaW1hZ2VSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6IG1pc3NpbmcgaW1hZ2UgZGF0YVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbWFnZVJlc3BvbnNlLmRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDogZGF0YSBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gICAgICB9XG4gICAgICBpbWFnZVJlc3BvbnNlLmRhdGEgPSBpbWFnZVJlc3BvbnNlLmRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB7IHVybDogaXRlbSB9O1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udXJsKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgaW1hZ2UgcmVzcG9uc2UgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbWFnZVJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgSW1hZ2UgbW9kaWZpY2F0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHZpZGVvcyBmcm9tIHRleHQgcHJvbXB0cyBvciBpbWFnZXMgdXNpbmcgQUkgdmlkZW8gZ2VuZXJhdGlvbiBtb2RlbHMuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYHByb21wdGA6IFRleHQgZGVzY3JpcHRpb24gb2YgdGhlIHZpZGVvIHRvIGdlbmVyYXRlIChyZXF1aXJlZClcbiAgICogICAtIGBtb2RlbGA6IFZpZGVvIG1vZGVsIHRvIHVzZSAob3B0aW9uYWwpLiBBdmFpbGFibGUgbW9kZWxzOlxuICAgKiAgICAgICAqKlRleHQtdG8tVmlkZW8gTW9kZWxzOioqXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL3ZlbzMuMVwiYCAtIEdvb2dsZSBWZW8gMy4xIChiZXN0IHF1YWxpdHkpXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL3ZlbzMuMS9mYXN0XCJgIChkZWZhdWx0KSAtIFZlbyAzLjEgZmFzdCBtb2RlIChmYXN0ZXIsIGNoZWFwZXIpXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL3NvcmEtMi90ZXh0LXRvLXZpZGVvL3Byb1wiYCAtIE9wZW5BSSBTb3JhIDJcbiAgICogICAgICAgLSBgXCJmYWwtYWkva2xpbmctdmlkZW8vdjIuNi9wcm8vdGV4dC10by12aWRlb1wiYCAtIEtsaW5nIDIuNlxuICAgKiAgICAgICAqKkltYWdlLXRvLVZpZGVvIE1vZGVsczoqKlxuICAgKiAgICAgICAtIGBcImZhbC1haS92ZW8zLjEvaW1hZ2UtdG8tdmlkZW9cImAgLSBWZW8gMy4xIEkyVlxuICAgKiAgICAgICAtIGBcImZhbC1haS92ZW8zLjEvZmFzdC9pbWFnZS10by12aWRlb1wiYCAtIFZlbyAzLjEgZmFzdCBJMlZcbiAgICogICAgICAgLSBgXCJmYWwtYWkvc29yYS0yL2ltYWdlLXRvLXZpZGVvL3Byb1wiYCAtIFNvcmEgMiBJMlZcbiAgICogICAgICAgLSBgXCJmYWwtYWkva2xpbmctdmlkZW8vdjIuNi9wcm8vaW1hZ2UtdG8tdmlkZW9cImAgLSBLbGluZyAyLjYgSTJWXG4gICAqICAgLSBgaW1hZ2VfdXJsYDogU291cmNlIGltYWdlIFVSTCBmb3IgaW1hZ2UtdG8tdmlkZW8gKHJlcXVpcmVkIGZvciBJMlYgbW9kZWxzKVxuICAgKiAgIC0gYGR1cmF0aW9uYDogVmlkZW8gZHVyYXRpb24gKFwiNHNcIiwgXCI1c1wiLCBcIjZzXCIsIFwiOHNcIiwgXCIxMHNcIiwgXCIxMnNcIilcbiAgICogICAtIGBhc3BlY3RfcmF0aW9gOiBBc3BlY3QgcmF0aW8gKFwiMTY6OVwiLCBcIjk6MTZcIiwgXCIxOjFcIilcbiAgICogICAtIGByZXNvbHV0aW9uYDogUmVzb2x1dGlvbiAoXCI3MjBwXCIsIFwiMTA4MHBcIikgLSBWZW8vU29yYSBvbmx5XG4gICAqICAgLSBgbmVnYXRpdmVfcHJvbXB0YDogV2hhdCB0byBhdm9pZCBpbiBnZW5lcmF0aW9uIC0gVmVvL0tsaW5nIG9ubHlcbiAgICogICAtIGBnZW5lcmF0ZV9hdWRpb2A6IEdlbmVyYXRlIGF1ZGlvIHdpdGggdmlkZW8gKGRlZmF1bHQ6IHRydWUpXG4gICAqICAgLSBgc2VlZGA6IEZvciByZXByb2R1Y2liaWxpdHkgLSBWZW8gb25seVxuICAgKiAgIC0gYGNmZ19zY2FsZWA6IEd1aWRhbmNlIHNjYWxlICgwLTEpIC0gS2xpbmcgb25seVxuICAgKiAgIC0gUGx1cyBvcHRpb25hbCBzaWduYWwgcGFyYW1ldGVyXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyB0ZXh0LXRvLXZpZGVvIGdlbmVyYXRpb24gKHVzZXMgZGVmYXVsdCBmYXN0IG1vZGVsKVxuICAgKiBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVWaWRlbyh7XG4gICAqICAgcHJvbXB0OiBcIkEgc2VyZW5lIHN1bnNldCBvdmVyIHRoZSBvY2VhbiB3aXRoIGdlbnRsZSB3YXZlc1wiXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhcIlZpZGVvIFVSTDpcIiwgcmVzdWx0LnZpZGVvLnVybCk7XG4gICAqIFxuICAgKiAvLyBIaWdoIHF1YWxpdHkgd2l0aCBWZW8gMy4xXG4gICAqIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVZpZGVvKHtcbiAgICogICBwcm9tcHQ6IFwiQSBjaW5lbWF0aWMgc2hvdCBvZiBhIGZ1dHVyaXN0aWMgY2l0eSBhdCBuaWdodFwiLFxuICAgKiAgIG1vZGVsOiBcImZhbC1haS92ZW8zLjFcIixcbiAgICogICByZXNvbHV0aW9uOiBcIjEwODBwXCIsXG4gICAqICAgYXNwZWN0X3JhdGlvOiBcIjE2OjlcIlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIEltYWdlLXRvLXZpZGVvIGFuaW1hdGlvblxuICAgKiBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVWaWRlbyh7XG4gICAqICAgcHJvbXB0OiBcIkFuaW1hdGUgdGhpcyBpbWFnZSB3aXRoIGdlbnRsZSBjYW1lcmEgbW92ZW1lbnRcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvdmVvMy4xL2Zhc3QvaW1hZ2UtdG8tdmlkZW9cIixcbiAgICogICBpbWFnZV91cmw6IFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9teS1pbWFnZS5qcGdcIixcbiAgICogICBkdXJhdGlvbjogXCI1c1wiXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gVXNpbmcgU29yYSAyIGZvciBjcmVhdGl2ZSB2aWRlb3NcbiAgICogY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlVmlkZW8oe1xuICAgKiAgIHByb21wdDogXCJBIG1hZ2ljYWwgZm9yZXN0IHdpdGggZ2xvd2luZyBmaXJlZmxpZXNcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvc29yYS0yL3RleHQtdG8tdmlkZW8vcHJvXCIsXG4gICAqICAgZHVyYXRpb246IFwiOHNcIlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIFVzaW5nIEtsaW5nIGZvciBkZXRhaWxlZCB2aWRlb3NcbiAgICogY29uc3QgeyByZXN1bHQsIHVzYWdlIH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVZpZGVvKHtcbiAgICogICBwcm9tcHQ6IFwiQSBwcm9mZXNzaW9uYWwgY29va2luZyB0dXRvcmlhbCBzY2VuZVwiLFxuICAgKiAgIG1vZGVsOiBcImZhbC1haS9rbGluZy12aWRlby92Mi42L3Byby90ZXh0LXRvLXZpZGVvXCIsXG4gICAqICAgbmVnYXRpdmVfcHJvbXB0OiBcImJsdXIsIGRpc3RvcnQsIGxvdyBxdWFsaXR5XCIsXG4gICAqICAgY2ZnX3NjYWxlOiAwLjdcbiAgICogfSk7XG4gICAqIGNvbnNvbGUubG9nKFwiQ3JlZGl0cyBjaGFyZ2VkOlwiLCB1c2FnZT8uY3JlZGl0c0NoYXJnZWQpO1xuICAgKiBgYGBcbiAgICogXG4gICAqIEByZXR1cm5zIFByb21pc2U8VmlkZW9HZW5lcmF0aW9uUmVzcG9uc2U+IC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgcmVzdWx0LnZpZGVvLnVybGA6IFVSTCB0byB0aGUgZ2VuZXJhdGVkIHZpZGVvXG4gICAqICAgLSBgcmVzdWx0LnZpZGVvLmNvbnRlbnRfdHlwZWA6IE1JTUUgdHlwZSAodmlkZW8vbXA0KVxuICAgKiAgIC0gYHJlc3VsdC52aWRlby5maWxlX25hbWVgOiBHZW5lcmF0ZWQgZmlsZW5hbWVcbiAgICogICAtIGByZXN1bHQudmlkZW8uZmlsZV9zaXplYDogRmlsZSBzaXplIGluIGJ5dGVzXG4gICAqICAgLSBgbWV0YWRhdGFgOiBHZW5lcmF0aW9uIG1ldGFkYXRhIChwcm9qZWN0SWQsIHRpbWVzdGFtcCwgbW9kZWwpXG4gICAqICAgLSBgdXNhZ2VgOiBDcmVkaXRzIGNoYXJnZWQgYW5kIGNvc3QgaW5mb3JtYXRpb25cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVmlkZW8ob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvbXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJQcm9tcHQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBpMnZNb2RlbHMgPSBbXG4gICAgICAgIFwiZmFsLWFpL3ZlbzMuMS9pbWFnZS10by12aWRlb1wiLFxuICAgICAgICBcImZhbC1haS92ZW8zLjEvZmFzdC9pbWFnZS10by12aWRlb1wiLFxuICAgICAgICBcImZhbC1haS9zb3JhLTIvaW1hZ2UtdG8tdmlkZW8vcHJvXCIsXG4gICAgICAgIFwiZmFsLWFpL2tsaW5nLXZpZGVvL3YyLjYvcHJvL2ltYWdlLXRvLXZpZGVvXCJcbiAgICAgIF07XG4gICAgICBpZiAob3B0aW9ucy5tb2RlbCAmJiBpMnZNb2RlbHMuaW5jbHVkZXMob3B0aW9ucy5tb2RlbCkgJiYgIW9wdGlvbnMuaW1hZ2VfdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJpbWFnZV91cmwgaXMgcmVxdWlyZWQgZm9yIGltYWdlLXRvLXZpZGVvIG1vZGVsc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmltYWdlX3VybCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZUltYWdlVXJsKG9wdGlvbnMuaW1hZ2VfdXJsKTtcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKGBJbnZhbGlkIGltYWdlX3VybDogJHt2YWxpZGF0aW9uLmVycm9yfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5haVZpZGVvKFxuICAgICAgICBvcHRpb25zLnByb21wdCxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIGltYWdlX3VybDogb3B0aW9ucy5pbWFnZV91cmwsXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgYXNwZWN0X3JhdGlvOiBvcHRpb25zLmFzcGVjdF9yYXRpbyxcbiAgICAgICAgICByZXNvbHV0aW9uOiBvcHRpb25zLnJlc29sdXRpb24sXG4gICAgICAgICAgbmVnYXRpdmVfcHJvbXB0OiBvcHRpb25zLm5lZ2F0aXZlX3Byb21wdCxcbiAgICAgICAgICBnZW5lcmF0ZV9hdWRpbzogb3B0aW9ucy5nZW5lcmF0ZV9hdWRpbyxcbiAgICAgICAgICBzZWVkOiBvcHRpb25zLnNlZWQsXG4gICAgICAgICAgY2ZnX3NjYWxlOiBvcHRpb25zLmNmZ19zY2FsZSxcbiAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3BvbnNlLmRhdGE/LnJlc3VsdD8udmlkZW8/LnVybCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6IG1pc3NpbmcgdmlkZW8gVVJMXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBWaWRlbyBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGV4dCB0byBzcGVlY2ggdXNpbmcgQUkgdm9pY2Ugc3ludGhlc2lzIG1vZGVscy5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgdGV4dGA6IFRleHQgY29udGVudCB0byBjb252ZXJ0IHRvIHNwZWVjaCAocmVxdWlyZWQpXG4gICAqICAgLSBgdm9pY2VgOiBWb2ljZSB0byB1c2UgKFwiYWxsb3lcIiwgXCJlY2hvXCIsIFwiZmFibGVcIiwgXCJvbnl4XCIsIFwibm92YVwiLCBcInNoaW1tZXJcIilcbiAgICogICAtIGByZXNwb25zZV9mb3JtYXRgOiBBdWRpbyBmb3JtYXQgKFwibXAzXCIsIFwib3B1c1wiLCBcImFhY1wiLCBcImZsYWNcIiwgXCJ3YXZcIiwgXCJwY21cIilcbiAgICogICAtIGBzcGVlZGA6IFNwZWVjaCBzcGVlZCAoMC4yNSB0byA0LjAsIGRlZmF1bHQ6IDEuMClcbiAgICogICAtIFBsdXMgb3B0aW9uYWwgbW9kZWwsIHNpZ25hbCBwYXJhbWV0ZXJzXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBCYXNpYyB0ZXh0LXRvLXNwZWVjaFxuICAgKiBjb25zdCB7IHVybCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVTcGVlY2goe1xuICAgKiAgIHRleHQ6IFwiSGVsbG8sIHdlbGNvbWUgdG8gb3VyIEFJLXBvd2VyZWQgYXBwbGljYXRpb24hXCJcbiAgICogfSk7XG4gICAqIGNvbnNvbGUubG9nKFwiQXVkaW8gVVJMOlwiLCB1cmwpO1xuICAgKiBcbiAgICogLy8gQ3VzdG9tIHZvaWNlIGFuZCBmb3JtYXRcbiAgICogY29uc3QgeyB1cmwsIHZvaWNlLCBmb3JtYXQgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlU3BlZWNoKHtcbiAgICogICB0ZXh0OiBcIlRoaXMgaXMgYSBkZW1vbnN0cmF0aW9uIG9mIG91ciBzcGVlY2ggc3ludGhlc2lzIGNhcGFiaWxpdGllcy5cIixcbiAgICogICB2b2ljZTogXCJub3ZhXCIsXG4gICAqICAgcmVzcG9uc2VfZm9ybWF0OiBcIndhdlwiLFxuICAgKiAgIHNwZWVkOiAxLjJcbiAgICogfSk7XG4gICAqIGNvbnNvbGUubG9nKGBHZW5lcmF0ZWQgJHtmb3JtYXR9IGF1ZGlvIHdpdGggJHt2b2ljZX0gdm9pY2U6YCwgdXJsKTtcbiAgICogXG4gICAqIC8vIFNsb3csIGNsZWFyIHNwZWVjaCBmb3IgYWNjZXNzaWJpbGl0eVxuICAgKiBjb25zdCB7IHVybCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVTcGVlY2goe1xuICAgKiAgIHRleHQ6IFwiUGxlYXNlIGxpc3RlbiBjYXJlZnVsbHkgdG8gdGhlc2UgaW1wb3J0YW50IGluc3RydWN0aW9ucy5cIixcbiAgICogICB2b2ljZTogXCJlY2hvXCIsXG4gICAqICAgc3BlZWQ6IDAuOFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPFNwZWVjaEdlbmVyYXRpb25SZXNwb25zZT4gLSBPYmplY3QgY29udGFpbmluZzpcbiAgICogICAtIGB1cmxgOiBVUkwgdG8gdGhlIGdlbmVyYXRlZCBhdWRpbyBmaWxlXG4gICAqICAgLSBgdm9pY2VgOiBWb2ljZSB1c2VkIGZvciBnZW5lcmF0aW9uXG4gICAqICAgLSBgZm9ybWF0YDogQXVkaW8gZm9ybWF0XG4gICAqICAgLSBgbWltZVR5cGVgOiBNSU1FIHR5cGUgb2YgdGhlIGF1ZGlvXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVNwZWVjaChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy50ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJUZXh0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuYWlTcGVlY2goXG4gICAgICAgIG9wdGlvbnMudGV4dCxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIHZvaWNlOiBvcHRpb25zLnZvaWNlLFxuICAgICAgICAgIHJlc3BvbnNlX2Zvcm1hdDogb3B0aW9ucy5yZXNwb25zZV9mb3JtYXQsXG4gICAgICAgICAgc3BlZWQ6IG9wdGlvbnMuc3BlZWQsXG4gICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbGV0IHNwZWVjaFJlc3BvbnNlO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/LnJlc3VsdCkge1xuICAgICAgICBzcGVlY2hSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGEucmVzdWx0O1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5kYXRhPy51cmwpIHtcbiAgICAgICAgc3BlZWNoUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBtaXNzaW5nIHNwZWVjaCBkYXRhXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFzcGVlY2hSZXNwb25zZS51cmwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgc3BlZWNoUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmw6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICB2b2ljZTogb3B0aW9ucy52b2ljZSB8fCBcImFsbG95XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IG9wdGlvbnMucmVzcG9uc2VfZm9ybWF0IHx8IFwibXAzXCIsXG4gICAgICAgICAgICBtaW1lVHlwZTogdGhpcy5nZXRNaW1lVHlwZUZvckZvcm1hdChvcHRpb25zLnJlc3BvbnNlX2Zvcm1hdCB8fCBcIm1wM1wiKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuZGF0YT8uZGF0YSkge1xuICAgICAgICAgIHNwZWVjaFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdXJsOiByZXNwb25zZS5kYXRhLmRhdGEsXG4gICAgICAgICAgICB2b2ljZTogb3B0aW9ucy52b2ljZSB8fCBcImFsbG95XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IG9wdGlvbnMucmVzcG9uc2VfZm9ybWF0IHx8IFwibXAzXCIsXG4gICAgICAgICAgICBtaW1lVHlwZTogdGhpcy5nZXRNaW1lVHlwZUZvckZvcm1hdChvcHRpb25zLnJlc3BvbnNlX2Zvcm1hdCB8fCBcIm1wM1wiKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBubyBhdWRpbyBVUkwgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc3BlZWNoUmVzcG9uc2Uudm9pY2UpIHtcbiAgICAgICAgc3BlZWNoUmVzcG9uc2Uudm9pY2UgPSBvcHRpb25zLnZvaWNlIHx8IFwiYWxsb3lcIjtcbiAgICAgIH1cbiAgICAgIGlmICghc3BlZWNoUmVzcG9uc2UuZm9ybWF0KSB7XG4gICAgICAgIHNwZWVjaFJlc3BvbnNlLmZvcm1hdCA9IG9wdGlvbnMucmVzcG9uc2VfZm9ybWF0IHx8IFwibXAzXCI7XG4gICAgICB9XG4gICAgICBpZiAoIXNwZWVjaFJlc3BvbnNlLm1pbWVUeXBlKSB7XG4gICAgICAgIHNwZWVjaFJlc3BvbnNlLm1pbWVUeXBlID0gdGhpcy5nZXRNaW1lVHlwZUZvckZvcm1hdChzcGVlY2hSZXNwb25zZS5mb3JtYXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwZWVjaFJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgU3BlZWNoIGdlbmVyYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUcmFuc2NyaWJlcyBhdWRpbyBjb250ZW50IHRvIHRleHQgdXNpbmcgQUkgc3BlZWNoIHJlY29nbml0aW9uIG1vZGVscy5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgYXVkaW9gOiBBdWRpbyBpbnB1dCBhcyBVUkwgc3RyaW5nLCBiYXNlNjQgc3RyaW5nLCBvciBudW1iZXIgYXJyYXkgYnVmZmVyIChyZXF1aXJlZClcbiAgICogICAtIGBsYW5ndWFnZWA6IExhbmd1YWdlIGNvZGUgZm9yIHRyYW5zY3JpcHRpb24gKGUuZy4sIFwiZW5cIiwgXCJlc1wiLCBcImZyXCIpXG4gICAqICAgLSBgcmVzcG9uc2VfZm9ybWF0YDogT3V0cHV0IGZvcm1hdCAoXCJqc29uXCIsIFwidGV4dFwiLCBcInNydFwiLCBcInZlcmJvc2VfanNvblwiLCBcInZ0dFwiKVxuICAgKiAgIC0gUGx1cyBvcHRpb25hbCBtb2RlbCwgc2lnbmFsIHBhcmFtZXRlcnNcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIFRyYW5zY3JpYmUgZnJvbSBVUkxcbiAgICogY29uc3QgeyB0ZXh0IH0gPSBhd2FpdCBibGluay5haS50cmFuc2NyaWJlQXVkaW8oe1xuICAgKiAgIGF1ZGlvOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vbWVldGluZy1yZWNvcmRpbmcubXAzXCJcbiAgICogfSk7XG4gICAqIGNvbnNvbGUubG9nKFwiVHJhbnNjcmlwdGlvbjpcIiwgdGV4dCk7XG4gICAqIFxuICAgKiAvLyBUcmFuc2NyaWJlIHdpdGggbGFuZ3VhZ2UgaGludFxuICAgKiBjb25zdCB7IHRleHQsIGxhbmd1YWdlIH0gPSBhd2FpdCBibGluay5haS50cmFuc2NyaWJlQXVkaW8oe1xuICAgKiAgIGF1ZGlvOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vc3BhbmlzaC1hdWRpby53YXZcIixcbiAgICogICBsYW5ndWFnZTogXCJlc1wiXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhgVHJhbnNjcmliZWQgJHtsYW5ndWFnZX06YCwgdGV4dCk7XG4gICAqIFxuICAgKiAvLyBUcmFuc2NyaWJlIHdpdGggdGltZXN0YW1wcyAodmVyYm9zZSBmb3JtYXQpXG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJsaW5rLmFpLnRyYW5zY3JpYmVBdWRpbyh7XG4gICAqICAgYXVkaW86IGF1ZGlvRmlsZVVybCxcbiAgICogICByZXNwb25zZV9mb3JtYXQ6IFwidmVyYm9zZV9qc29uXCJcbiAgICogfSk7XG4gICAqIHJlc3VsdC5zZWdtZW50cz8uZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhgJHtzZWdtZW50LnN0YXJ0fXMgLSAke3NlZ21lbnQuZW5kfXM6ICR7c2VnbWVudC50ZXh0fWApO1xuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIFRyYW5zY3JpYmUgZnJvbSBhdWRpbyBidWZmZXJcbiAgICogY29uc3QgYXVkaW9CdWZmZXIgPSBuZXcgQXJyYXkoMTAyNCkuZmlsbCgwKTsgLy8gWW91ciBhdWRpbyBkYXRhXG4gICAqIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgYmxpbmsuYWkudHJhbnNjcmliZUF1ZGlvKHtcbiAgICogICBhdWRpbzogYXVkaW9CdWZmZXIsXG4gICAqICAgbGFuZ3VhZ2U6IFwiZW5cIlxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPFRyYW5zY3JpcHRpb25SZXNwb25zZT4gLSBPYmplY3QgY29udGFpbmluZzpcbiAgICogICAtIGB0ZXh0YDogVHJhbnNjcmliZWQgdGV4dCBjb250ZW50XG4gICAqICAgLSBgdHJhbnNjcmlwdGA6IEFsaWFzIGZvciB0ZXh0XG4gICAqICAgLSBgc2VnbWVudHNgOiBBcnJheSBvZiB0aW1lc3RhbXBlZCBzZWdtZW50cyAoaWYgdmVyYm9zZSBmb3JtYXQpXG4gICAqICAgLSBgbGFuZ3VhZ2VgOiBEZXRlY3RlZCBsYW5ndWFnZVxuICAgKiAgIC0gYGR1cmF0aW9uYDogQXVkaW8gZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgYXN5bmMgdHJhbnNjcmliZUF1ZGlvKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJBdWRpbyBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpVHJhbnNjcmliZShcbiAgICAgICAgb3B0aW9ucy5hdWRpbyxcbiAgICAgICAge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlLFxuICAgICAgICAgIHJlc3BvbnNlX2Zvcm1hdDogb3B0aW9ucy5yZXNwb25zZV9mb3JtYXQsXG4gICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/LnJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmRhdGE/LnRleHQgfHwgcmVzcG9uc2UuZGF0YT8udHJhbnNjcmlwdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRleHQ6IHJlc3BvbnNlLmRhdGEudGV4dCB8fCByZXNwb25zZS5kYXRhLnRyYW5zY3JpcHQsXG4gICAgICAgICAgdHJhbnNjcmlwdDogcmVzcG9uc2UuZGF0YS50cmFuc2NyaXB0IHx8IHJlc3BvbnNlLmRhdGEudGV4dCxcbiAgICAgICAgICAuLi5yZXNwb25zZS5kYXRhXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6IG1pc3NpbmcgdHJhbnNjcmlwdGlvbiB0ZXh0XCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgQXVkaW8gdHJhbnNjcmlwdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWdlbnQob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMuYWdlbnQ/Lm1vZGVsKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJhZ2VudC5tb2RlbCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5wcm9tcHQgJiYgIW9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkVpdGhlciBwcm9tcHQgb3IgbWVzc2FnZXMgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5wcm9tcHQgJiYgb3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwicHJvbXB0IGFuZCBtZXNzYWdlcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VyaWFsaXplZFRvb2xzID0gb3B0aW9ucy5hZ2VudC50b29scyA/IHNlcmlhbGl6ZVRvb2xzKG9wdGlvbnMuYWdlbnQudG9vbHMpIDogdm9pZCAwO1xuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW0sXG4gICAgICAgIGFnZW50OiB7XG4gICAgICAgICAgbW9kZWw6IG9wdGlvbnMuYWdlbnQubW9kZWwsXG4gICAgICAgICAgc3lzdGVtOiBvcHRpb25zLmFnZW50LnN5c3RlbSxcbiAgICAgICAgICB0b29sczogc2VyaWFsaXplZFRvb2xzLFxuICAgICAgICAgIHdlYmhvb2tfdG9vbHM6IG9wdGlvbnMuYWdlbnQud2ViaG9va190b29scyxcbiAgICAgICAgICBjbGllbnRfdG9vbHM6IG9wdGlvbnMuYWdlbnQuY2xpZW50X3Rvb2xzLFxuICAgICAgICAgIHRvb2xfY2hvaWNlOiBvcHRpb25zLmFnZW50LnRvb2xfY2hvaWNlLFxuICAgICAgICAgIHN0b3Bfd2hlbjogb3B0aW9ucy5hZ2VudC5zdG9wX3doZW4sXG4gICAgICAgICAgcHJlcGFyZV9zdGVwOiBvcHRpb25zLmFnZW50LnByZXBhcmVfc3RlcFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMucHJvbXB0KSB7XG4gICAgICAgIHJlcXVlc3RCb2R5LnByb21wdCA9IG9wdGlvbnMucHJvbXB0O1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICAgIHJlcXVlc3RCb2R5Lm1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpQWdlbnRTdHJlYW0ocmVxdWVzdEJvZHksIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpQWdlbnQocmVxdWVzdEJvZHksIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBBZ2VudCByZXF1ZXN0IGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEFnZW50IEZhY3RvcnlcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJldXNhYmxlIEFnZW50IGluc3RhbmNlIHdpdGggdGhlIFZlcmNlbCBBSSBTREsgcGF0dGVybi5cbiAgICogXG4gICAqIFRoZSBBZ2VudCBjYW4gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBwcm9tcHRzOlxuICAgKiAtIGBhZ2VudC5nZW5lcmF0ZSh7IHByb21wdCB9KWAgZm9yIG5vbi1zdHJlYW1pbmdcbiAgICogLSBgYWdlbnQuc3RyZWFtKHsgcHJvbXB0IH0pYCBmb3Igc3RyZWFtaW5nXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFnZW50IGNvbmZpZ3VyYXRpb24gKG1vZGVsLCB0b29scywgc3lzdGVtLCBldGMuKVxuICAgKiBAcmV0dXJucyBBZ2VudCBpbnN0YW5jZVxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgd2VhdGhlckFnZW50ID0gYmxpbmsuYWkuY3JlYXRlQWdlbnQoe1xuICAgKiAgIG1vZGVsOiAnYW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNCcsXG4gICAqICAgc3lzdGVtOiAnWW91IGFyZSBhIGhlbHBmdWwgd2VhdGhlciBhc3Npc3RhbnQuJyxcbiAgICogICB0b29sczogW3dlYlNlYXJjaCwgZmV0Y2hVcmxdLFxuICAgKiAgIG1heFN0ZXBzOiAxMCxcbiAgICogfSlcbiAgICogXG4gICAqIC8vIE5vbi1zdHJlYW1pbmdcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgd2VhdGhlckFnZW50LmdlbmVyYXRlKHtcbiAgICogICBwcm9tcHQ6ICdXaGF0IGlzIHRoZSB3ZWF0aGVyIGluIFNhbiBGcmFuY2lzY28/JyxcbiAgICogfSlcbiAgICogXG4gICAqIC8vIFN0cmVhbWluZ1xuICAgKiBjb25zdCBzdHJlYW0gPSBhd2FpdCB3ZWF0aGVyQWdlbnQuc3RyZWFtKHtcbiAgICogICBwcm9tcHQ6ICdUZWxsIG1lIGFib3V0IHdlYXRoZXIgcGF0dGVybnMnLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGNyZWF0ZUFnZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBhZ2VudCA9IG5ldyBBZ2VudChvcHRpb25zKTtcbiAgICBhZ2VudC5fc2V0SHR0cENsaWVudCh0aGlzLmh0dHBDbGllbnQpO1xuICAgIHJldHVybiBhZ2VudDtcbiAgfVxuICAvKipcbiAgICogQmluZHMgYW4gZXhpc3RpbmcgQWdlbnQgaW5zdGFuY2UgdG8gdGhpcyBjbGllbnQncyBIVFRQIGNsaWVudC5cbiAgICogXG4gICAqIFVzZWQgaW50ZXJuYWxseSBieSB1c2VBZ2VudCgpIHdoZW4gYW4gQWdlbnQgaW5zdGFuY2UgaXMgcGFzc2VkLlxuICAgKiBUaGlzIGFsbG93cyBhZ2VudHMgY3JlYXRlZCB3aXRoIGBuZXcgQWdlbnQoKWAgdG8gYmUgdXNlZCB3aXRoIHRoZSBob29rLlxuICAgKiBcbiAgICogQHBhcmFtIGFnZW50IC0gRXhpc3RpbmcgQWdlbnQgaW5zdGFuY2VcbiAgICogQHJldHVybnMgVGhlIHNhbWUgQWdlbnQgaW5zdGFuY2UgKHdpdGggaHR0cENsaWVudCBzZXQpXG4gICAqL1xuICBiaW5kQWdlbnQoYWdlbnQpIHtcbiAgICBhZ2VudC5fc2V0SHR0cENsaWVudCh0aGlzLmh0dHBDbGllbnQpO1xuICAgIHJldHVybiBhZ2VudDtcbiAgfVxufTtcblxuLy8gc3JjL2RhdGEudHNcbnZhciBCbGlua0RhdGFJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCBwcm9qZWN0SWQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkO1xuICB9XG4gIGFzeW5jIGV4dHJhY3RGcm9tVXJsKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaHVua2luZyA9IGZhbHNlLCBjaHVua1NpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHsgdXJsLCBjaHVua2luZywgY2h1bmtTaXplIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGF0YUV4dHJhY3RGcm9tVXJsKHRoaXMucHJvamVjdElkLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gY2h1bmtpbmcgPyByZXNwb25zZS5kYXRhLmNodW5rcyA6IHJlc3BvbnNlLmRhdGEudGV4dDtcbiAgfVxuICBhc3luYyBleHRyYWN0RnJvbUJsb2IoZmlsZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaHVua2luZyA9IGZhbHNlLCBjaHVua1NpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGF0YUV4dHJhY3RGcm9tQmxvYih0aGlzLnByb2plY3RJZCwgZmlsZSwgY2h1bmtpbmcsIGNodW5rU2l6ZSk7XG4gICAgcmV0dXJuIGNodW5raW5nID8gcmVzcG9uc2UuZGF0YS5jaHVua3MgOiByZXNwb25zZS5kYXRhLnRleHQ7XG4gIH1cbiAgYXN5bmMgc2NyYXBlKHVybCkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICB1cmwsXG4gICAgICBmb3JtYXRzOiBbXCJtYXJrZG93blwiLCBcImh0bWxcIiwgXCJsaW5rc1wiLCBcImV4dHJhY3RcIiwgXCJtZXRhZGF0YVwiXVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGF0YVNjcmFwZSh0aGlzLnByb2plY3RJZCwgcmVxdWVzdCk7XG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtkb3duOiBkYXRhLm1hcmtkb3duIHx8IFwiXCIsXG4gICAgICBodG1sOiBkYXRhLmh0bWwgfHwgXCJcIixcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHRpdGxlOiBkYXRhLm1ldGFkYXRhPy50aXRsZSB8fCBcIlwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5tZXRhZGF0YT8uZGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICAgICAgdXJsOiBkYXRhLm1ldGFkYXRhPy51cmwgfHwgdXJsLFxuICAgICAgICBkb21haW46IGRhdGEubWV0YWRhdGE/LmRvbWFpbiB8fCBuZXcgVVJMKHVybCkuaG9zdG5hbWUsXG4gICAgICAgIGZhdmljb246IGRhdGEubWV0YWRhdGE/LmZhdmljb24sXG4gICAgICAgIGltYWdlOiBkYXRhLm1ldGFkYXRhPy5pbWFnZSxcbiAgICAgICAgYXV0aG9yOiBkYXRhLm1ldGFkYXRhPy5hdXRob3IsXG4gICAgICAgIHB1Ymxpc2hlZFRpbWU6IGRhdGEubWV0YWRhdGE/LnB1Ymxpc2hlZFRpbWUsXG4gICAgICAgIG1vZGlmaWVkVGltZTogZGF0YS5tZXRhZGF0YT8ubW9kaWZpZWRUaW1lLFxuICAgICAgICB0eXBlOiBkYXRhLm1ldGFkYXRhPy50eXBlLFxuICAgICAgICBzaXRlTmFtZTogZGF0YS5tZXRhZGF0YT8uc2l0ZU5hbWUsXG4gICAgICAgIGxvY2FsZTogZGF0YS5tZXRhZGF0YT8ubG9jYWxlLFxuICAgICAgICBrZXl3b3JkczogZGF0YS5tZXRhZGF0YT8ua2V5d29yZHMgfHwgW11cbiAgICAgIH0sXG4gICAgICBsaW5rczogZGF0YS5saW5rcyB8fCBbXSxcbiAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgdGl0bGU6IGRhdGEuZXh0cmFjdD8udGl0bGUgfHwgZGF0YS5tZXRhZGF0YT8udGl0bGUgfHwgXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuZXh0cmFjdD8uZGVzY3JpcHRpb24gfHwgZGF0YS5tZXRhZGF0YT8uZGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICAgICAgaGVhZGluZ3M6IGRhdGEuZXh0cmFjdD8uaGVhZGluZ3MgfHwgW10sXG4gICAgICAgIHRleHQ6IGRhdGEuZXh0cmFjdD8udGV4dCB8fCBkYXRhLm1hcmtkb3duIHx8IFwiXCJcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIHNjcmVlbnNob3QodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0geyB1cmwsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYXRhU2NyZWVuc2hvdCh0aGlzLnByb2plY3RJZCwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYXRhRmV0Y2godGhpcy5wcm9qZWN0SWQsIHJlcXVlc3QpO1xuICAgIGlmIChcInN0YXR1c1wiIGluIHJlc3BvbnNlLmRhdGEgJiYgXCJoZWFkZXJzXCIgaW4gcmVzcG9uc2UuZGF0YSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIHRocm93IG5ldyBCbGlua0RhdGFFcnJvcihcIlVuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gZmV0Y2ggZW5kcG9pbnRcIik7XG4gIH1cbiAgYXN5bmMgZmV0Y2hBc3luYyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgYXN5bmNSZXF1ZXN0ID0geyAuLi5yZXF1ZXN0LCBhc3luYzogdHJ1ZSB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRhdGFGZXRjaCh0aGlzLnByb2plY3RJZCwgYXN5bmNSZXF1ZXN0KTtcbiAgICBpZiAoXCJzdGF0dXNcIiBpbiByZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSBcInRyaWdnZXJlZFwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEJsaW5rRGF0YUVycm9yKFwiVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQgZnJvbSBhc3luYyBmZXRjaCBlbmRwb2ludFwiKTtcbiAgfVxuICBhc3luYyBzZWFyY2gocXVlcnksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub3JtYWxpemVUeXBlID0gKHR5cGUpID0+IHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibmV3c1wiOlxuICAgICAgICAgIHJldHVybiBcIm53c1wiO1xuICAgICAgICBjYXNlIFwiaW1hZ2VzXCI6XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgIHJldHVybiBcImlzY2hcIjtcbiAgICAgICAgY2FzZSBcInZpZGVvc1wiOlxuICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICByZXR1cm4gXCJ2aWRcIjtcbiAgICAgICAgY2FzZSBcInNob3BwaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzaG9wXCI6XG4gICAgICAgICAgcmV0dXJuIFwic2hvcFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgcTogcXVlcnksXG4gICAgICBsb2NhdGlvbjogb3B0aW9ucz8ubG9jYXRpb24sXG4gICAgICBobDogb3B0aW9ucz8ubGFuZ3VhZ2UgfHwgXCJlblwiLFxuICAgICAgdGJtOiBub3JtYWxpemVUeXBlKG9wdGlvbnM/LnR5cGUpLFxuICAgICAgbnVtOiBvcHRpb25zPy5saW1pdFxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGF0YVNlYXJjaCh0aGlzLnByb2plY3RJZCwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWFsdGltZS1jb25uZWN0aW9uLnRzXG52YXIgZ2V0V2ViU29ja2V0Q2xhc3MgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFdlYlNvY2tldDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IFdTID0gX19yZXF1aXJlKFwid3NcIik7XG4gICAgcmV0dXJuIFdTO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgYXZhaWxhYmxlLiBJbnN0YWxsIFwid3NcIiBwYWNrYWdlIGZvciBOb2RlLmpzIGVudmlyb25tZW50cy4nKTtcbiAgfVxufTtcbnZhciBSZWFsdGltZUNvbm5lY3Rpb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQsIHByb2plY3RJZCkge1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gIH1cbiAgd2Vic29ja2V0ID0gbnVsbDtcbiAgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gIHJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgaGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICByZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gIGNvbm5lY3Rpb25Qcm9taXNlID0gbnVsbDtcbiAgLy8gQ2hhbm5lbCBtYW5hZ2VtZW50XG4gIGNoYW5uZWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcGVuZGluZ1N1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvLyBNZXNzYWdlIHF1ZXVlIGZvciB3aGVuIHNvY2tldCBub3QgcmVhZHlcbiAgbWVzc2FnZVF1ZXVlID0gW107XG4gIC8qKlxuICAgKiBDaGVjayBpZiBjb25uZWN0aW9uIGlzIHJlYWR5XG4gICAqL1xuICBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkICYmIHRoaXMud2Vic29ja2V0Py5yZWFkeVN0YXRlID09PSAxO1xuICB9XG4gIC8qKlxuICAgKiBFbnN1cmUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQgJiYgdGhpcy53ZWJzb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5jb25uZWN0V2ViU29ja2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSm9pbiBhIGNoYW5uZWwgKHN1YnNjcmliZSlcbiAgICovXG4gIGFzeW5jIGpvaW5DaGFubmVsKGNoYW5uZWxOYW1lLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgICBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcbiAgICB0aGlzLmNoYW5uZWxzLnNldChjaGFubmVsTmFtZSwgeyBoYW5kbGVyLCBvcHRpb25zIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgdGhpcy5jaGFubmVscy5kZWxldGUoY2hhbm5lbE5hbWUpO1xuICAgICAgICByZWplY3QobmV3IEJsaW5rUmVhbHRpbWVFcnJvcihcIlN1YnNjcmlwdGlvbiB0aW1lb3V0IC0gbm8gYWNrbm93bGVkZ21lbnQgZnJvbSBzZXJ2ZXJcIikpO1xuICAgICAgfSwgMWU0KTtcbiAgICAgIHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuc2V0KGNoYW5uZWxOYW1lLCB7IHJlc29sdmUsIHJlamVjdCwgdGltZW91dCB9KTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZU1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6IFwic3Vic2NyaWJlXCIsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBjaGFubmVsOiBjaGFubmVsTmFtZSxcbiAgICAgICAgICB1c2VySWQ6IG9wdGlvbnMudXNlcklkLFxuICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNlbmRSYXcoSlNPTi5zdHJpbmdpZnkoc3Vic2NyaWJlTWVzc2FnZSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShjaGFubmVsTmFtZSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMuZGVsZXRlKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGVhdmUgYSBjaGFubmVsICh1bnN1YnNjcmliZSlcbiAgICovXG4gIGFzeW5jIGxlYXZlQ2hhbm5lbChjaGFubmVsTmFtZSkge1xuICAgIHRoaXMuY2hhbm5lbHMuZGVsZXRlKGNoYW5uZWxOYW1lKTtcbiAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICBjbGVhclRpbWVvdXQocGVuZGluZy50aW1lb3V0KTtcbiAgICAgIHBlbmRpbmcucmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJTdWJzY3JpcHRpb24gY2FuY2VsbGVkXCIpKTtcbiAgICAgIHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGNoYW5uZWxOYW1lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud2Vic29ja2V0ICYmIHRoaXMud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogXCJ1bnN1YnNjcmliZVwiLFxuICAgICAgICBwYXlsb2FkOiB7IGNoYW5uZWw6IGNoYW5uZWxOYW1lIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHVuc3Vic2NyaWJlTWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVscy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIGEgY2hhbm5lbFxuICAgKi9cbiAgYXN5bmMgc2VuZChjaGFubmVsTmFtZSwgdHlwZSwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgY29uc3QgcHVibGlzaE1lc3NhZ2UgPSB7XG4gICAgICB0eXBlOiBcInB1Ymxpc2hcIixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgY2hhbm5lbDogY2hhbm5lbE5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHVzZXJJZDogb3B0aW9ucy51c2VySWQsXG4gICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5zZW5kV2l0aFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHB1Ymxpc2hNZXNzYWdlKSwgY2hhbm5lbE5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IGFuZCBjbGVhbnVwXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlUXVldWUuZm9yRWFjaCgocSkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHEudGltZW91dCk7XG4gICAgICBxLnJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiQ29ubmVjdGlvbiBjbG9zZWRcIikpO1xuICAgIH0pO1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5mb3JFYWNoKChwZW5kaW5nLCBjaGFubmVsKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQocGVuZGluZy50aW1lb3V0KTtcbiAgICAgIHBlbmRpbmcucmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJDb25uZWN0aW9uIGNsb3NlZFwiKSk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5jbGVhcigpO1xuICAgIGlmICh0aGlzLndlYnNvY2tldCkge1xuICAgICAgdGhpcy53ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHRoaXMud2Vic29ja2V0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjb3VudCBvZiBhY3RpdmUgY2hhbm5lbHNcbiAgICovXG4gIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVscy5zaXplO1xuICB9XG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuICBhc3luYyBjb25uZWN0V2ViU29ja2V0KCkge1xuICAgIGlmICh0aGlzLndlYnNvY2tldCAmJiB0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja0Nvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJDb25uZWN0aW9uIGZhaWxlZFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tDb25uZWN0aW9uLCAxMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDb25uZWN0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaHR0cENsaWVudCA9IHRoaXMuaHR0cENsaWVudDtcbiAgICAgICAgY29uc3QgY29yZVVybCA9IGh0dHBDbGllbnQuY29yZVVybCB8fCBcImh0dHBzOi8vY29yZS5ibGluay5uZXdcIjtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGNvcmVVcmwucmVwbGFjZShcImh0dHBzOi8vXCIsIFwid3NzOi8vXCIpLnJlcGxhY2UoXCJodHRwOi8vXCIsIFwid3M6Ly9cIik7XG4gICAgICAgIGNvbnN0IHdzVXJsID0gYCR7YmFzZVVybH0/cHJvamVjdF9pZD0ke3RoaXMucHJvamVjdElkfWA7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXHV7MUY1MTd9IENvbm5lY3RpbmcgdG8gcmVhbHRpbWU6ICR7d3NVcmx9YCk7XG4gICAgICAgIGNvbnN0IFdTQ2xhc3MgPSBnZXRXZWJTb2NrZXRDbGFzcygpO1xuICAgICAgICB0aGlzLndlYnNvY2tldCA9IG5ldyBXU0NsYXNzKHdzVXJsKTtcbiAgICAgICAgaWYgKCF0aGlzLndlYnNvY2tldCkge1xuICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgcmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBpbnN0YW5jZVwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgXFx1ezFGNTE3fSBDb25uZWN0ZWQgdG8gcmVhbHRpbWUgZm9yIHByb2plY3QgJHt0aGlzLnByb2plY3RJZH1gKTtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgV2ViU29ja2V0IG1lc3NhZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFxcdXsxRjUwQ30gRGlzY29ubmVjdGVkIGZyb20gcmVhbHRpbWUgZm9yIHByb2plY3QgJHt0aGlzLnByb2plY3RJZH1gKTtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnJlamVjdFF1ZXVlZE1lc3NhZ2VzKG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWRcIikpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXZWJTb2NrZXQgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICByZWplY3QobmV3IEJsaW5rUmVhbHRpbWVFcnJvcihgV2ViU29ja2V0IGNvbm5lY3Rpb24gZmFpbGVkIHRvICR7d3NVcmx9YCkpO1xuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy53ZWJzb2NrZXQ/LnJlYWR5U3RhdGUgIT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZWplY3QobmV3IEJsaW5rUmVhbHRpbWVFcnJvcihcIldlYlNvY2tldCBjb25uZWN0aW9uIHRpbWVvdXRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMWU0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBjb25uZWN0aW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gbWVzc2FnZS5wYXlsb2FkPy5jaGFubmVsO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdGVkXCI6XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXHUyNzA1IFdlYlNvY2tldCBjb25uZWN0ZWQ6ICR7bWVzc2FnZS5wYXlsb2FkPy5zb2NrZXRJZH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3Vic2NyaWJlZFwiOlxuICAgICAgICBjb25zb2xlLmxvZyhgXFx1MjcwNSBTdWJzY3JpYmVkIHRvIGNoYW5uZWw6ICR7Y2hhbm5lbE5hbWV9YCk7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdTdWIgPSB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25zLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIGlmIChwZW5kaW5nU3ViKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmdTdWIudGltZW91dCk7XG4gICAgICAgICAgcGVuZGluZ1N1Yi5yZXNvbHZlKCk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5kZWxldGUoY2hhbm5lbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YkhhbmRsZXIgPSB0aGlzLmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIGlmIChzdWJIYW5kbGVyKSB7XG4gICAgICAgICAgc3ViSGFuZGxlci5oYW5kbGVyLm9uU3Vic2NyaWJlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgY29uc3QgbXNnQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZ2V0KG1lc3NhZ2UucGF5bG9hZD8uY2hhbm5lbCk7XG4gICAgICAgIGlmIChtc2dDaGFubmVsKSB7XG4gICAgICAgICAgbXNnQ2hhbm5lbC5oYW5kbGVyLm9uTWVzc2FnZShtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByZXNlbmNlXCI6XG4gICAgICAgIGNvbnN0IHByZXNDaGFubmVsID0gdGhpcy5jaGFubmVscy5nZXQobWVzc2FnZS5wYXlsb2FkPy5jaGFubmVsKTtcbiAgICAgICAgaWYgKHByZXNDaGFubmVsKSB7XG4gICAgICAgICAgY29uc3QgdXNlcnMgPSBtZXNzYWdlLnBheWxvYWQ/LmRhdGE/LnVzZXJzIHx8IFtdO1xuICAgICAgICAgIHByZXNDaGFubmVsLmhhbmRsZXIub25QcmVzZW5jZSh1c2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHVibGlzaGVkXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvbmdcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlYWx0aW1lIGVycm9yOlwiLCBtZXNzYWdlLnBheWxvYWQ/LmVycm9yKTtcbiAgICAgICAgY29uc3QgZXJyQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZ2V0KGNoYW5uZWxOYW1lKTtcbiAgICAgICAgaWYgKGVyckNoYW5uZWwpIHtcbiAgICAgICAgICBlcnJDaGFubmVsLmhhbmRsZXIub25FcnJvcihtZXNzYWdlLnBheWxvYWQ/LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZW5kaW5nRXJyID0gdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgICAgICBpZiAocGVuZGluZ0Vycikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nRXJyLnRpbWVvdXQpO1xuICAgICAgICAgIHBlbmRpbmdFcnIucmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoYFN1YnNjcmlwdGlvbiBlcnJvcjogJHttZXNzYWdlLnBheWxvYWQ/LmVycm9yfWApKTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShjaGFubmVsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidW5zdWJzY3JpYmVkXCI6XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXHUyNzRDIFVuc3Vic2NyaWJlZCBmcm9tIGNoYW5uZWw6ICR7Y2hhbm5lbE5hbWV9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIG1lc3NhZ2UgdHlwZTpcIiwgbWVzc2FnZS50eXBlKTtcbiAgICB9XG4gIH1cbiAgc2VuZFJhdyhtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMud2Vic29ja2V0ICYmIHRoaXMud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJDYW5ub3Qgc2VuZCBtZXNzYWdlOiBXZWJTb2NrZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gIH1cbiAgc2VuZFdpdGhSZXNwb25zZShtZXNzYWdlLCBjaGFubmVsTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZXNzYWdlUXVldWUuZmluZEluZGV4KChxKSA9PiBxLnJlc29sdmUgPT09IHJlc29sdmUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJNZXNzYWdlIHNlbmQgdGltZW91dCAtIG5vIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpKTtcbiAgICAgIH0sIDFlNCk7XG4gICAgICBpZiAodGhpcy53ZWJzb2NrZXQgJiYgdGhpcy53ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gXCJwdWJsaXNoZWRcIiAmJiByZXNwb25zZS5wYXlsb2FkLmNoYW5uZWwgPT09IGNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnBheWxvYWQubWVzc2FnZUlkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICByZWplY3QobmV3IEJsaW5rUmVhbHRpbWVFcnJvcihgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnBheWxvYWQuZXJyb3J9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlUmVzcG9uc2UpO1xuICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUucHVzaCh7IG1lc3NhZ2UsIHJlc29sdmUsIHJlamVjdCwgdGltZW91dCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmbHVzaE1lc3NhZ2VRdWV1ZSgpIHtcbiAgICBpZiAoIXRoaXMud2Vic29ja2V0IHx8IHRoaXMud2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHJldHVybjtcbiAgICBjb25zdCBxdWV1ZSA9IFsuLi50aGlzLm1lc3NhZ2VRdWV1ZV07XG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICBxdWV1ZS5mb3JFYWNoKChxKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKHEubWVzc2FnZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjbGVhclRpbWVvdXQocS50aW1lb3V0KTtcbiAgICAgICAgcS5yZWplY3QobmV3IEJsaW5rUmVhbHRpbWVFcnJvcihcIkZhaWxlZCB0byBzZW5kIHF1ZXVlZCBtZXNzYWdlXCIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZWplY3RRdWV1ZWRNZXNzYWdlcyhlcnJvcikge1xuICAgIGNvbnN0IHF1ZXVlID0gWy4uLnRoaXMubWVzc2FnZVF1ZXVlXTtcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgIHF1ZXVlLmZvckVhY2goKHEpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChxLnRpbWVvdXQpO1xuICAgICAgcS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIHN0YXJ0SGVhcnRiZWF0KCkge1xuICAgIGlmICh0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgIH1cbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gZ2xvYmFsVGhpcy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy53ZWJzb2NrZXQgJiYgdGhpcy53ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHsgdHlwZTogXCJwaW5nXCIsIHBheWxvYWQ6IHt9IH0pKTtcbiAgICAgIH1cbiAgICB9LCAyNWUzKTtcbiAgfVxuICBzY2hlZHVsZVJlY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVscy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICBjb25zdCBiYXNlRGVsYXkgPSBNYXRoLm1pbigzZTQsIE1hdGgucG93KDIsIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpICogMWUzKTtcbiAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogMWUzO1xuICAgIGNvbnN0IGRlbGF5ID0gYmFzZURlbGF5ICsgaml0dGVyO1xuICAgIGNvbnNvbGUubG9nKGBcXHV7MUY1MDR9IFNjaGVkdWxpbmcgcmVjb25uZWN0IGF0dGVtcHQgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBpbiAke01hdGgucm91bmQoZGVsYXkpfW1zYCk7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IGdsb2JhbFRoaXMuc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jaGFubmVscy5zaXplID09PSAwKSByZXR1cm47XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3RXZWJTb2NrZXQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN1YnNjcmliZUFsbENoYW5uZWxzKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVjb25uZWN0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfSwgZGVsYXkpO1xuICB9XG4gIGFzeW5jIHJlc3Vic2NyaWJlQWxsQ2hhbm5lbHMoKSB7XG4gICAgY29uc29sZS5sb2coYFxcdXsxRjUwNH0gUmVzdWJzY3JpYmluZyAke3RoaXMuY2hhbm5lbHMuc2l6ZX0gY2hhbm5lbHMuLi5gKTtcbiAgICBmb3IgKGNvbnN0IFtjaGFubmVsTmFtZSwgc3Vic2NyaXB0aW9uXSBvZiB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVNZXNzYWdlID0ge1xuICAgICAgICAgIHR5cGU6IFwic3Vic2NyaWJlXCIsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbE5hbWUsXG4gICAgICAgICAgICB1c2VySWQ6IHN1YnNjcmlwdGlvbi5vcHRpb25zLnVzZXJJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzdWJzY3JpcHRpb24ub3B0aW9ucy5tZXRhZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMud2Vic29ja2V0ICYmIHRoaXMud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHN1YnNjcmliZU1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlc3Vic2NyaWJlIHRvICR7Y2hhbm5lbE5hbWV9OmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWFsdGltZS50c1xudmFyIEJsaW5rUmVhbHRpbWVDaGFubmVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsTmFtZSwgY29ubmVjdGlvbiwgaHR0cENsaWVudCwgcHJvamVjdElkKSB7XG4gICAgdGhpcy5jaGFubmVsTmFtZSA9IGNoYW5uZWxOYW1lO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDtcbiAgfVxuICBtZXNzYWdlQ2FsbGJhY2tzID0gW107XG4gIHByZXNlbmNlQ2FsbGJhY2tzID0gW107XG4gIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICBzdWJzY3JpYmVPcHRpb25zID0ge307XG4gIC8qKlxuICAgKiBDaGVjayBpZiBjaGFubmVsIGlzIHJlYWR5IGZvciBwdWJsaXNoaW5nXG4gICAqL1xuICBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLmlzU3Vic2NyaWJlZCAmJiB0aGlzLmNvbm5lY3Rpb24uaXNSZWFkeSgpO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZShvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpYmVPcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgb25NZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2sobWVzc2FnZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBtZXNzYWdlIGNhbGxiYWNrOlwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvblByZXNlbmNlOiAodXNlcnMpID0+IHtcbiAgICAgICAgdGhpcy5wcmVzZW5jZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsYmFjayh1c2Vycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBwcmVzZW5jZSBjYWxsYmFjazpcIiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25TdWJzY3JpYmVkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQ2hhbm5lbCAke3RoaXMuY2hhbm5lbE5hbWV9IGVycm9yOmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5qb2luQ2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlZCA9IHRydWU7XG4gIH1cbiAgYXN5bmMgdW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3Vic2NyaWJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ubGVhdmVDaGFubmVsKHRoaXMuY2hhbm5lbE5hbWUpO1xuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2godHlwZSwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kKHRoaXMuY2hhbm5lbE5hbWUsIHR5cGUsIGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIG9uTWVzc2FnZShjYWxsYmFjaykge1xuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIG9uUHJlc2VuY2UoY2FsbGJhY2spIHtcbiAgICB0aGlzLnByZXNlbmNlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMucHJlc2VuY2VDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnByZXNlbmNlQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRQcmVzZW5jZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucmVhbHRpbWVHZXRQcmVzZW5jZSh0aGlzLnByb2plY3RJZCwgdGhpcy5jaGFubmVsTmFtZSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS51c2VycyB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rUmVhbHRpbWVFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgcHJlc2VuY2UgZm9yIGNoYW5uZWwgJHt0aGlzLmNoYW5uZWxOYW1lfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldE1lc3NhZ2VzKG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5yZWFsdGltZUdldE1lc3NhZ2VzKHRoaXMucHJvamVjdElkLCB7XG4gICAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbE5hbWUsXG4gICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgICAgICBzdGFydDogb3B0aW9ucy5hZnRlciB8fCBcIi1cIixcbiAgICAgICAgZW5kOiBvcHRpb25zLmJlZm9yZSB8fCBcIitcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXNzYWdlcyB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rUmVhbHRpbWVFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgbWVzc2FnZXMgZm9yIGNoYW5uZWwgJHt0aGlzLmNoYW5uZWxOYW1lfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgdGhpcy5pc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnNjcmliZU9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnByZXNlbmNlQ2FsbGJhY2tzID0gW107XG4gIH1cbn07XG52YXIgQmxpbmtSZWFsdGltZUltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQsIHByb2plY3RJZCkge1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IFJlYWx0aW1lQ29ubmVjdGlvbihodHRwQ2xpZW50LCBwcm9qZWN0SWQpO1xuICB9XG4gIGNvbm5lY3Rpb247XG4gIGNoYW5uZWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaGFuZGxlcnMgPSB7fTtcbiAgY2hhbm5lbChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmNoYW5uZWxzLmhhcyhuYW1lKSkge1xuICAgICAgdGhpcy5jaGFubmVscy5zZXQobmFtZSwgbmV3IEJsaW5rUmVhbHRpbWVDaGFubmVsKG5hbWUsIHRoaXMuY29ubmVjdGlvbiwgdGhpcy5odHRwQ2xpZW50LCB0aGlzLnByb2plY3RJZCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGFubmVscy5nZXQobmFtZSk7XG4gIH1cbiAgYXN5bmMgc3Vic2NyaWJlKGNoYW5uZWxOYW1lLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgYXdhaXQgY2hhbm5lbC5zdWJzY3JpYmUob3B0aW9ucyk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmhhbmRsZXJzW2NoYW5uZWxOYW1lXSA/Pz0ge1xuICAgICAgbXNnSGFuZGxlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBwcmVzSGFuZGxlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBzdWJzY3JpYmVkOiB0cnVlXG4gICAgfTtcbiAgICBzdGF0ZS5tc2dIYW5kbGVycy5hZGQoY2FsbGJhY2spO1xuICAgIGNvbnN0IG1lc3NhZ2VVbnN1YiA9IGNoYW5uZWwub25NZXNzYWdlKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVzc2FnZVVuc3ViKCk7XG4gICAgICBzdGF0ZS5tc2dIYW5kbGVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgaWYgKHN0YXRlLm1zZ0hhbmRsZXJzLnNpemUgPT09IDAgJiYgc3RhdGUucHJlc0hhbmRsZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5oYW5kbGVyc1tjaGFubmVsTmFtZV07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKGNoYW5uZWxOYW1lLCB0eXBlLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsKGNoYW5uZWxOYW1lKTtcbiAgICByZXR1cm4gY2hhbm5lbC5wdWJsaXNoKHR5cGUsIGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHByZXNlbmNlKGNoYW5uZWxOYW1lKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgcmV0dXJuIGNoYW5uZWwuZ2V0UHJlc2VuY2UoKTtcbiAgfVxuICBvblByZXNlbmNlKGNoYW5uZWxOYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoY2hhbm5lbE5hbWUpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5oYW5kbGVyc1tjaGFubmVsTmFtZV0gPz89IHtcbiAgICAgIG1zZ0hhbmRsZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgcHJlc0hhbmRsZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgc3Vic2NyaWJlZDogZmFsc2VcbiAgICB9O1xuICAgIHN0YXRlLnByZXNIYW5kbGVycy5hZGQoY2FsbGJhY2spO1xuICAgIGNvbnN0IHByZXNlbmNlVW5zdWIgPSBjaGFubmVsLm9uUHJlc2VuY2UoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwcmVzZW5jZVVuc3ViKCk7XG4gICAgICBzdGF0ZS5wcmVzSGFuZGxlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIGlmIChzdGF0ZS5tc2dIYW5kbGVycy5zaXplID09PSAwICYmIHN0YXRlLnByZXNIYW5kbGVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlcnNbY2hhbm5lbE5hbWVdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBXZWJTb2NrZXQgY29ubmVjdGlvbnMgKHNob3VsZCBhbHdheXMgYmUgMCBvciAxKVxuICAgKi9cbiAgZ2V0Q29ubmVjdGlvbkNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uaXNSZWFkeSgpID8gMSA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBjaGFubmVsc1xuICAgKi9cbiAgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uZ2V0Q2hhbm5lbENvdW50KCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ub3RpZmljYXRpb25zLnRzXG52YXIgQmxpbmtOb3RpZmljYXRpb25zSW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaHR0cENsaWVudCkge1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGVtYWlsIHVzaW5nIHRoZSBCbGluayBOb3RpZmljYXRpb25zIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkZXRhaWxzIGZvciB0aGUgZW1haWwuXG4gICAqICAgLSBgdG9gOiBUaGUgcmVjaXBpZW50J3MgZW1haWwgYWRkcmVzcyBvciBhbiBhcnJheSBvZiBhZGRyZXNzZXMuXG4gICAqICAgLSBgc3ViamVjdGA6IFRoZSBzdWJqZWN0IGxpbmUgb2YgdGhlIGVtYWlsLlxuICAgKiAgIC0gYGh0bWxgOiBUaGUgSFRNTCBib2R5IG9mIHRoZSBlbWFpbC4gRm9yIGJlc3QgcmVzdWx0cyBhY3Jvc3MgYWxsIGVtYWlsXG4gICAqICAgICAgICAgICAgIGNsaWVudHMgKGxpa2UgR21haWwsIE91dGxvb2spLCB1c2UgaW5saW5lIENTUyBhbmQgdGFibGUtYmFzZWQgbGF5b3V0cy5cbiAgICogICAtIGB0ZXh0YDogQSBwbGFpbi10ZXh0IHZlcnNpb24gb2YgdGhlIGVtYWlsIGJvZHkgKG9wdGlvbmFsKS5cbiAgICogICAtIGBmcm9tYDogQSBjdXN0b20gc2VuZGVyIG5hbWUgKGUuZy4sIFwiQWNtZSBJbmNcIikuIFRoZSBlbWFpbCBhZGRyZXNzIHdpbGxcbiAgICogICAgICAgICAgICAgYmUgYXV0by1nZW5lcmF0ZWQgYnkgdGhlIHByb2plY3QgKGUuZy4sIFwibm9yZXBseUBwcm9qZWN0LmJsaW5rLWVtYWlsLmNvbVwiKS5cbiAgICogICAtIGByZXBseVRvYDogQW4gZW1haWwgYWRkcmVzcyBmb3IgcmVjaXBpZW50cyB0byByZXBseSB0byAob3B0aW9uYWwpLlxuICAgKiAgIC0gYGNjYDogQSBDQyByZWNpcGllbnQncyBlbWFpbCBhZGRyZXNzIG9yIGFuIGFycmF5IG9mIGFkZHJlc3NlcyAob3B0aW9uYWwpLlxuICAgKiAgIC0gYGJjY2A6IEEgQkNDIHJlY2lwaWVudCdzIGVtYWlsIGFkZHJlc3Mgb3IgYW4gYXJyYXkgb2YgYWRkcmVzc2VzIChvcHRpb25hbCkuXG4gICAqICAgLSBgYXR0YWNobWVudHNgOiBBbiBhcnJheSBvZiBvYmplY3RzIGZvciBmaWxlcyB0byBhdHRhY2gsIGVhY2ggd2l0aCBhIGB1cmxgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgVGhlIGZpbGUgYXQgdGhlIFVSTCB3aWxsIGJlIGZldGNoZWQgYW5kIGF0dGFjaGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIFNlbmQgYSBzaW1wbGUgZW1haWxcbiAgICogY29uc3QgeyBzdWNjZXNzLCBtZXNzYWdlSWQgfSA9IGF3YWl0IGJsaW5rLm5vdGlmaWNhdGlvbnMuZW1haWwoe1xuICAgKiAgIHRvOiAnY3VzdG9tZXJAZXhhbXBsZS5jb20nLFxuICAgKiAgIHN1YmplY3Q6ICdZb3VyIG9yZGVyIGhhcyBzaGlwcGVkIScsXG4gICAqICAgaHRtbDogJzxoMT5PcmRlciBDb25maXJtYXRpb248L2gxPjxwPllvdXIgb3JkZXIgIzEyMzQ1IGlzIG9uIGl0cyB3YXkuPC9wPidcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFNlbmQgYW4gZW1haWwgd2l0aCBhdHRhY2htZW50cyBhbmQgYSBjdXN0b20gZnJvbSBuYW1lXG4gICAqIGNvbnN0IHsgc3VjY2VzcyB9ID0gYXdhaXQgYmxpbmsubm90aWZpY2F0aW9ucy5lbWFpbCh7XG4gICAqICAgdG86IFsndGVhbUBleGFtcGxlLmNvbScsICdtYW5hZ2VyQGV4YW1wbGUuY29tJ10sXG4gICAqICAgc3ViamVjdDogJ05ldyBJbnZvaWNlJyxcbiAgICogICBmcm9tOiAnQmxpbmsgSW52b2ljaW5nJyxcbiAgICogICBodG1sOiAnPHA+UGxlYXNlIGZpbmQgdGhlIGludm9pY2UgYXR0YWNoZWQuPC9wPicsXG4gICAqICAgYXR0YWNobWVudHM6IFtcbiAgICogICAgIHsgdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9pbnZvaWNlLnBkZicsIGZpbGVuYW1lOiAnaW52b2ljZS5wZGYnIH1cbiAgICogICBdXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhdHVzIG9mIHRoZSBlbWFpbCBzZW5kLlxuICAgKiAgIC0gYHN1Y2Nlc3NgOiBBIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgZW1haWwgd2FzIHNlbnQgc3VjY2Vzc2Z1bGx5LlxuICAgKiAgIC0gYG1lc3NhZ2VJZGA6IFRoZSB1bmlxdWUgSUQgb2YgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgZW1haWwgcHJvdmlkZXIuXG4gICAqL1xuICBhc3luYyBlbWFpbChwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFwYXJhbXMudG8gfHwgIXBhcmFtcy5zdWJqZWN0IHx8ICFwYXJhbXMuaHRtbCAmJiAhcGFyYW1zLnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rTm90aWZpY2F0aW9uc0Vycm9yKCdUaGUgXCJ0b1wiLCBcInN1YmplY3RcIiwgYW5kIGVpdGhlciBcImh0bWxcIiBvciBcInRleHRcIiBmaWVsZHMgYXJlIHJlcXVpcmVkLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdChgL2FwaS9ub3RpZmljYXRpb25zLyR7dGhpcy5odHRwQ2xpZW50LnByb2plY3RJZH0vZW1haWxgLCBwYXJhbXMpO1xuICAgICAgaWYgKCFyZXNwb25zZS5kYXRhIHx8IHR5cGVvZiByZXNwb25zZS5kYXRhLnN1Y2Nlc3MgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua05vdGlmaWNhdGlvbnNFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZnJvbSBlbWFpbCBBUElcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtOb3RpZmljYXRpb25zRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3I/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZSB8fCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIjtcbiAgICAgIHRocm93IG5ldyBCbGlua05vdGlmaWNhdGlvbnNFcnJvcihgRmFpbGVkIHRvIHNlbmQgZW1haWw6ICR7ZXJyb3JNZXNzYWdlfWAsIGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvYW5hbHl0aWNzLnRzXG52YXIgU0VTU0lPTl9EVVJBVElPTiA9IDMwICogNjAgKiAxZTM7XG52YXIgTUFYX0JBVENIX1NJWkUgPSAxMDtcbnZhciBCQVRDSF9USU1FT1VUID0gM2UzO1xudmFyIE1BWF9TVFJJTkdfTEVOR1RIID0gMjU2O1xudmFyIEJsaW5rQW5hbHl0aWNzSW1wbCA9IGNsYXNzIHtcbiAgaHR0cENsaWVudDtcbiAgcHJvamVjdElkO1xuICBxdWV1ZSA9IFtdO1xuICB0aW1lciA9IG51bGw7XG4gIGVuYWJsZWQgPSB0cnVlO1xuICB1c2VySWQgPSBudWxsO1xuICB1c2VyRW1haWwgPSBudWxsO1xuICBoYXNUcmFja2VkUGFnZXZpZXcgPSBmYWxzZTtcbiAgdXRtUGFyYW1zID0ge307XG4gIHBlcnNpc3RlZEF0dHJpYnV0aW9uID0ge307XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQsIHByb2plY3RJZCkge1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gICAgaWYgKCFpc1dlYikge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYXZpZ2F0b3IuZG9Ob3RUcmFjayA9PT0gXCIxXCIpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvYWRQZXJzaXN0ZWRBdHRyaWJ1dGlvbigpO1xuICAgIHRoaXMuY2FwdHVyZVVUTVBhcmFtcygpO1xuICAgIHRoaXMubG9hZFF1ZXVlKCk7XG4gICAgdGhpcy50cmFja1BhZ2V2aWV3KCk7XG4gICAgdGhpcy5zZXR1cFJvdXRlQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICB0aGlzLnNldHVwVW5sb2FkTGlzdGVuZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgcHJvamVjdC1zY29wZWQgc3RvcmFnZSBrZXkgZm9yIGFuYWx5dGljc1xuICAgKi9cbiAgZ2V0U3RvcmFnZUtleShzdWZmaXgpIHtcbiAgICByZXR1cm4gYGJsaW5rQW5hbHl0aWNzJHtzdWZmaXh9XyR7dGhpcy5wcm9qZWN0SWR9YDtcbiAgfVxuICAvKipcbiAgICogTG9nIGEgY3VzdG9tIGFuYWx5dGljcyBldmVudFxuICAgKi9cbiAgbG9nKGV2ZW50TmFtZSwgZGF0YSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIWlzV2ViKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5idWlsZEV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgdGhpcy5lbnF1ZXVlKGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBhbmFseXRpY3MgdHJhY2tpbmdcbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFudXAgYW5hbHl0aWNzIGluc3RhbmNlIChyZW1vdmUgZnJvbSBnbG9iYWwgdHJhY2tpbmcpXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cuX19ibGlua0FuYWx5dGljc0luc3RhbmNlcz8uZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5hYmxlIGFuYWx5dGljcyB0cmFja2luZ1xuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuYWx5dGljcyBpcyBlbmFibGVkXG4gICAqL1xuICBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB1c2VyIElEIGZvciBhbmFseXRpY3MgZXZlbnRzXG4gICAqL1xuICBzZXRVc2VySWQodXNlcklkKSB7XG4gICAgdGhpcy51c2VySWQgPSB1c2VySWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlciBlbWFpbCBmb3IgYW5hbHl0aWNzIGV2ZW50c1xuICAgKi9cbiAgc2V0VXNlckVtYWlsKGVtYWlsKSB7XG4gICAgdGhpcy51c2VyRW1haWwgPSBlbWFpbDtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgcGVyc2lzdGVkIGF0dHJpYnV0aW9uIGRhdGFcbiAgICovXG4gIGNsZWFyQXR0cmlidXRpb24oKSB7XG4gICAgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbiA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJBdHRyaWJ1dGlvblwiKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuICBidWlsZEV2ZW50KHR5cGUsIGRhdGEgPSB7fSkge1xuICAgIGNvbnN0IHNlc3Npb25JZCA9IHRoaXMuZ2V0T3JDcmVhdGVTZXNzaW9uSWQoKTtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5kZXRlY3RDaGFubmVsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICB0aW1lc3RhbXA6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSxcbiAgICAgIHByb2plY3RfaWQ6IHRoaXMucHJvamVjdElkLFxuICAgICAgdXNlcl9pZDogdGhpcy51c2VySWQsXG4gICAgICB1c2VyX2VtYWlsOiB0aGlzLnVzZXJFbWFpbCxcbiAgICAgIHNlc3Npb25faWQ6IHNlc3Npb25JZCxcbiAgICAgIHBhdGhuYW1lOiBnZXRMb2NhdGlvblBhdGhuYW1lKCksXG4gICAgICByZWZlcnJlcjogZ2V0RG9jdW1lbnRSZWZlcnJlcigpLFxuICAgICAgc2NyZWVuX3dpZHRoOiBnZXRXaW5kb3dJbm5lcldpZHRoKCksXG4gICAgICBjaGFubmVsLFxuICAgICAgdXRtX3NvdXJjZTogdGhpcy51dG1QYXJhbXMudXRtX3NvdXJjZSB8fCB0aGlzLnBlcnNpc3RlZEF0dHJpYnV0aW9uLnV0bV9zb3VyY2UgfHwgbnVsbCxcbiAgICAgIHV0bV9tZWRpdW06IHRoaXMudXRtUGFyYW1zLnV0bV9tZWRpdW0gfHwgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbi51dG1fbWVkaXVtIHx8IG51bGwsXG4gICAgICB1dG1fY2FtcGFpZ246IHRoaXMudXRtUGFyYW1zLnV0bV9jYW1wYWlnbiB8fCB0aGlzLnBlcnNpc3RlZEF0dHJpYnV0aW9uLnV0bV9jYW1wYWlnbiB8fCBudWxsLFxuICAgICAgdXRtX2NvbnRlbnQ6IHRoaXMudXRtUGFyYW1zLnV0bV9jb250ZW50IHx8IHRoaXMucGVyc2lzdGVkQXR0cmlidXRpb24udXRtX2NvbnRlbnQgfHwgbnVsbCxcbiAgICAgIHV0bV90ZXJtOiB0aGlzLnV0bVBhcmFtcy51dG1fdGVybSB8fCB0aGlzLnBlcnNpc3RlZEF0dHJpYnV0aW9uLnV0bV90ZXJtIHx8IG51bGwsXG4gICAgICAuLi50aGlzLnNhbml0aXplRGF0YShkYXRhKVxuICAgIH07XG4gIH1cbiAgc2FuaXRpemVEYXRhKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IE1BWF9TVFJJTkdfTEVOR1RIID8gZGF0YS5zbGljZSgwLCBNQVhfU1RSSU5HX0xFTkdUSCAtIDMpICsgXCIuLi5cIiA6IGRhdGE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLnNhbml0aXplRGF0YShkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZW5xdWV1ZShldmVudCkge1xuICAgIHRoaXMucXVldWUucHVzaChldmVudCk7XG4gICAgdGhpcy5wZXJzaXN0UXVldWUoKTtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPj0gTUFYX0JBVENIX1NJWkUpIHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoKCksIEJBVENIX1RJTUVPVVQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmbHVzaCgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5xdWV1ZS5zbGljZSgwLCBNQVhfQkFUQ0hfU0laRSk7XG4gICAgdGhpcy5xdWV1ZSA9IHRoaXMucXVldWUuc2xpY2UoTUFYX0JBVENIX1NJWkUpO1xuICAgIHRoaXMucGVyc2lzdFF1ZXVlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuaHR0cENsaWVudC5wb3N0KGAvYXBpL2FuYWx5dGljcy8ke3RoaXMucHJvamVjdElkfS9sb2dgLCB7IGV2ZW50cyB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5xdWV1ZSA9IFsuLi5ldmVudHMsIC4uLnRoaXMucXVldWVdO1xuICAgICAgdGhpcy5wZXJzaXN0UXVldWUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaCgpLCBCQVRDSF9USU1FT1VUKTtcbiAgICB9XG4gIH1cbiAgY2xlYXJUaW1lcigpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldE9yQ3JlYXRlU2Vzc2lvbklkKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJTZXNzaW9uXCIpKTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHNlc3Npb24ubGFzdEFjdGl2aXR5QXQgPiBTRVNTSU9OX0RVUkFUSU9OKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTmV3U2Vzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIHNlc3Npb24ubGFzdEFjdGl2aXR5QXQgPSBub3c7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuZ2V0U3RvcmFnZUtleShcIlNlc3Npb25cIiksIEpTT04uc3RyaW5naWZ5KHNlc3Npb24pKTtcbiAgICAgICAgcmV0dXJuIHNlc3Npb24uaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVOZXdTZXNzaW9uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTmV3U2Vzc2lvbigpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHJhbmRvbUlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbiAgICBjb25zdCBzZXNzaW9uID0ge1xuICAgICAgaWQ6IGBzZXNzXyR7bm93fV8ke3JhbmRvbUlkfWAsXG4gICAgICBzdGFydGVkQXQ6IG5vdyxcbiAgICAgIGxhc3RBY3Rpdml0eUF0OiBub3dcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJTZXNzaW9uXCIpLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiBzZXNzaW9uLmlkO1xuICB9XG4gIGxvYWRRdWV1ZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiUXVldWVcIikpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICB0aGlzLnF1ZXVlID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaCgpLCBCQVRDSF9USU1FT1VUKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cbiAgfVxuICBwZXJzaXN0UXVldWUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJRdWV1ZVwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJRdWV1ZVwiKSwgSlNPTi5zdHJpbmdpZnkodGhpcy5xdWV1ZSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICB0cmFja1BhZ2V2aWV3KCkge1xuICAgIGlmICghdGhpcy5oYXNUcmFja2VkUGFnZXZpZXcpIHtcbiAgICAgIHRoaXMubG9nKFwicGFnZXZpZXdcIik7XG4gICAgICB0aGlzLmhhc1RyYWNrZWRQYWdldmlldyA9IHRydWU7XG4gICAgfVxuICB9XG4gIHNldHVwUm91dGVDaGFuZ2VMaXN0ZW5lcigpIHtcbiAgICBpZiAoIWlzV2ViKSByZXR1cm47XG4gICAgaWYgKCF3aW5kb3cuX19ibGlua0FuYWx5dGljc1NldHVwKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbFB1c2hTdGF0ZSA9IGhpc3RvcnkucHVzaFN0YXRlO1xuICAgICAgY29uc3Qgb3JpZ2luYWxSZXBsYWNlU3RhdGUgPSBoaXN0b3J5LnJlcGxhY2VTdGF0ZTtcbiAgICAgIGNvbnN0IGFuYWx5dGljc0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB3aW5kb3cuX19ibGlua0FuYWx5dGljc0luc3RhbmNlcyA9IGFuYWx5dGljc0luc3RhbmNlcztcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgb3JpZ2luYWxQdXNoU3RhdGUuYXBwbHkoaGlzdG9yeSwgYXJncyk7XG4gICAgICAgIGFuYWx5dGljc0luc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5pc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgaW5zdGFuY2UubG9nKFwicGFnZXZpZXdcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIG9yaWdpbmFsUmVwbGFjZVN0YXRlLmFwcGx5KGhpc3RvcnksIGFyZ3MpO1xuICAgICAgICBhbmFseXRpY3NJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmxvZyhcInBhZ2V2aWV3XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGFuYWx5dGljc0luc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5pc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgaW5zdGFuY2UubG9nKFwicGFnZXZpZXdcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93Ll9fYmxpbmtBbmFseXRpY3NTZXR1cCA9IHRydWU7XG4gICAgfVxuICAgIHdpbmRvdy5fX2JsaW5rQW5hbHl0aWNzSW5zdGFuY2VzPy5hZGQodGhpcyk7XG4gIH1cbiAgc2V0dXBVbmxvYWRMaXN0ZW5lcigpIHtcbiAgICBpZiAoIWlzV2ViIHx8ICFoYXNXaW5kb3coKSkgcmV0dXJuO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9KTtcbiAgfVxuICBjYXB0dXJlVVRNUGFyYW1zKCkge1xuICAgIGlmICghaXNXZWIpIHJldHVybjtcbiAgICBjb25zdCBzZWFyY2ggPSBnZXRMb2NhdGlvblNlYXJjaCgpO1xuICAgIGlmICghc2VhcmNoKSB7XG4gICAgICB0aGlzLnV0bVBhcmFtcyA9IHt9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCk7XG4gICAgdGhpcy51dG1QYXJhbXMgPSB7XG4gICAgICB1dG1fc291cmNlOiB1cmxQYXJhbXMuZ2V0KFwidXRtX3NvdXJjZVwiKSxcbiAgICAgIHV0bV9tZWRpdW06IHVybFBhcmFtcy5nZXQoXCJ1dG1fbWVkaXVtXCIpLFxuICAgICAgdXRtX2NhbXBhaWduOiB1cmxQYXJhbXMuZ2V0KFwidXRtX2NhbXBhaWduXCIpLFxuICAgICAgdXRtX2NvbnRlbnQ6IHVybFBhcmFtcy5nZXQoXCJ1dG1fY29udGVudFwiKSxcbiAgICAgIHV0bV90ZXJtOiB1cmxQYXJhbXMuZ2V0KFwidXRtX3Rlcm1cIilcbiAgICB9O1xuICAgIGNvbnN0IGhhc05ld1BhcmFtcyA9IE9iamVjdC52YWx1ZXModGhpcy51dG1QYXJhbXMpLnNvbWUoKHYpID0+IHYgIT09IG51bGwpO1xuICAgIGlmIChoYXNOZXdQYXJhbXMpIHtcbiAgICAgIHRoaXMucGVyc2lzdEF0dHJpYnV0aW9uKCk7XG4gICAgfVxuICB9XG4gIGxvYWRQZXJzaXN0ZWRBdHRyaWJ1dGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiQXR0cmlidXRpb25cIikpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlZEF0dHJpYnV0aW9uID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbiA9IHt9O1xuICAgIH1cbiAgfVxuICBwZXJzaXN0QXR0cmlidXRpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0aW9uID0ge1xuICAgICAgICAuLi50aGlzLnBlcnNpc3RlZEF0dHJpYnV0aW9uLFxuICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy51dG1QYXJhbXMpLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSBudWxsKVxuICAgICAgICApXG4gICAgICB9O1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiQXR0cmlidXRpb25cIiksIEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0aW9uKSk7XG4gICAgICB0aGlzLnBlcnNpc3RlZEF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGRldGVjdENoYW5uZWwoKSB7XG4gICAgY29uc3QgcmVmZXJyZXIgPSBnZXREb2N1bWVudFJlZmVycmVyKCk7XG4gICAgY29uc3QgdXRtTWVkaXVtID0gdGhpcy51dG1QYXJhbXMudXRtX21lZGl1bTtcbiAgICB0aGlzLnV0bVBhcmFtcy51dG1fc291cmNlO1xuICAgIGlmICh1dG1NZWRpdW0pIHtcbiAgICAgIGlmICh1dG1NZWRpdW0gPT09IFwiY3BjXCIgfHwgdXRtTWVkaXVtID09PSBcInBwY1wiKSByZXR1cm4gXCJQYWlkIFNlYXJjaFwiO1xuICAgICAgaWYgKHV0bU1lZGl1bSA9PT0gXCJlbWFpbFwiKSByZXR1cm4gXCJFbWFpbFwiO1xuICAgICAgaWYgKHV0bU1lZGl1bSA9PT0gXCJzb2NpYWxcIikgcmV0dXJuIFwiU29jaWFsXCI7XG4gICAgICBpZiAodXRtTWVkaXVtID09PSBcInJlZmVycmFsXCIpIHJldHVybiBcIlJlZmVycmFsXCI7XG4gICAgICBpZiAodXRtTWVkaXVtID09PSBcImRpc3BsYXlcIikgcmV0dXJuIFwiRGlzcGxheVwiO1xuICAgICAgaWYgKHV0bU1lZGl1bSA9PT0gXCJhZmZpbGlhdGVcIikgcmV0dXJuIFwiQWZmaWxpYXRlXCI7XG4gICAgfVxuICAgIGlmICghcmVmZXJyZXIpIHJldHVybiBcIkRpcmVjdFwiO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWZlcnJlclVybCA9IG5ldyBVUkwocmVmZXJyZXIpO1xuICAgICAgY29uc3QgcmVmZXJyZXJEb21haW4gPSByZWZlcnJlclVybC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKC9nb29nbGVcXC58YmluZ1xcLnx5YWhvb1xcLnxkdWNrZHVja2dvXFwufGJhaWR1XFwufHlhbmRleFxcLi8udGVzdChyZWZlcnJlckRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIFwiT3JnYW5pYyBTZWFyY2hcIjtcbiAgICAgIH1cbiAgICAgIGlmICgvZmFjZWJvb2tcXC58dHdpdHRlclxcLnxsaW5rZWRpblxcLnxpbnN0YWdyYW1cXC58eW91dHViZVxcLnx0aWt0b2tcXC58cmVkZGl0XFwuLy50ZXN0KHJlZmVycmVyRG9tYWluKSkge1xuICAgICAgICByZXR1cm4gXCJTb2NpYWxcIjtcbiAgICAgIH1cbiAgICAgIGlmICgvbWFpbFxcLnxvdXRsb29rXFwufGdtYWlsXFwuLy50ZXN0KHJlZmVycmVyRG9tYWluKSkge1xuICAgICAgICByZXR1cm4gXCJFbWFpbFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiUmVmZXJyYWxcIjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBcIkRpcmVjdFwiO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Nvbm5lY3RvcnMudHNcbnZhciBCbGlua0Nvbm5lY3RvcnNJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50KSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgfVxuICBhc3luYyBzdGF0dXMocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5jb25uZWN0b3JTdGF0dXMocHJvdmlkZXIpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGUocHJvdmlkZXIsIHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5jb25uZWN0b3JFeGVjdXRlKHByb3ZpZGVyLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBzYXZlQXBpS2V5KHByb3ZpZGVyLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuY29ubmVjdG9yU2F2ZUFwaUtleShwcm92aWRlciwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbn07XG5cbi8vIHNyYy9mdW5jdGlvbnMudHNcbnZhciBCbGlua0Z1bmN0aW9uc0ltcGwgPSBjbGFzcyB7XG4gIGh0dHBDbGllbnQ7XG4gIHByb2plY3RJZDtcbiAgY29uc3RydWN0b3IoaHR0cENsaWVudCwgcHJvamVjdElkLCBfZ2V0VG9rZW4pIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHByb2plY3Qgc3VmZml4IGZyb20gdGhlIGZ1bGwgcHJvamVjdCBJRC5cbiAgICogUHJvamVjdCBJRHMgYXJlIGZvcm1hdHRlZCBhczogcHJqX3h4eHh4XG4gICAqIFRoZSBzdWZmaXggaXMgdGhlIGxhc3QgOCBjaGFyYWN0ZXJzIHVzZWQgaW4gZnVuY3Rpb24gVVJMcy5cbiAgICovXG4gIGdldFByb2plY3RTdWZmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdElkLnNsaWNlKC04KTtcbiAgfVxuICAvKipcbiAgICogQnVpbGQgdGhlIGZ1bGwgZnVuY3Rpb24gVVJMXG4gICAqL1xuICBidWlsZEZ1bmN0aW9uVXJsKGZ1bmN0aW9uU2x1Zywgc2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3Qgc3VmZml4ID0gdGhpcy5nZXRQcm9qZWN0U3VmZml4KCk7XG4gICAgY29uc3QgYmFzZVVybCA9IGBodHRwczovLyR7c3VmZml4fS0tJHtmdW5jdGlvblNsdWd9LmZ1bmN0aW9ucy5ibGluay5uZXdgO1xuICAgIGlmICghc2VhcmNoUGFyYW1zIHx8IE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYmFzZVVybDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICBPYmplY3QuZW50cmllcyhzZWFyY2hQYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICB9XG4gIGFzeW5jIGludm9rZShmdW5jdGlvblNsdWcsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbWV0aG9kID0gXCJQT1NUXCIsIGJvZHksIGhlYWRlcnMgPSB7fSwgc2VhcmNoUGFyYW1zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRGdW5jdGlvblVybChmdW5jdGlvblNsdWcsIHNlYXJjaFBhcmFtcyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJlcXVlc3QodXJsLCB7IG1ldGhvZCwgYm9keSwgaGVhZGVycyB9KTtcbiAgICByZXR1cm4geyBkYXRhOiByZXMuZGF0YSwgc3RhdHVzOiByZXMuc3RhdHVzLCBoZWFkZXJzOiByZXMuaGVhZGVycyB9O1xuICB9XG59O1xuXG4vLyBzcmMvcmFnLnRzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSB2b2lkIDApXG4gICk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29sbGVjdGlvbihhcGkpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogYXBpLmlkLFxuICAgIG5hbWU6IGFwaS5uYW1lLFxuICAgIGRlc2NyaXB0aW9uOiBhcGkuZGVzY3JpcHRpb24sXG4gICAgZW1iZWRkaW5nTW9kZWw6IGFwaS5lbWJlZGRpbmdfbW9kZWwsXG4gICAgZW1iZWRkaW5nRGltZW5zaW9uczogYXBpLmVtYmVkZGluZ19kaW1lbnNpb25zLFxuICAgIGluZGV4TWV0cmljOiBhcGkuaW5kZXhfbWV0cmljLFxuICAgIGNodW5rTWF4VG9rZW5zOiBhcGkuY2h1bmtfbWF4X3Rva2VucyxcbiAgICBjaHVua092ZXJsYXBUb2tlbnM6IGFwaS5jaHVua19vdmVybGFwX3Rva2VucyxcbiAgICBkb2N1bWVudENvdW50OiBhcGkuZG9jdW1lbnRfY291bnQsXG4gICAgY2h1bmtDb3VudDogYXBpLmNodW5rX2NvdW50LFxuICAgIHNoYXJlZDogYXBpLnNoYXJlZCxcbiAgICBjcmVhdGVkQXQ6IGFwaS5jcmVhdGVkX2F0LFxuICAgIHVwZGF0ZWRBdDogYXBpLnVwZGF0ZWRfYXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREb2N1bWVudChhcGkpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogYXBpLmlkLFxuICAgIGNvbGxlY3Rpb25JZDogYXBpLmNvbGxlY3Rpb25faWQsXG4gICAgZmlsZW5hbWU6IGFwaS5maWxlbmFtZSxcbiAgICBzb3VyY2VUeXBlOiBhcGkuc291cmNlX3R5cGUsXG4gICAgc291cmNlVXJsOiBhcGkuc291cmNlX3VybCxcbiAgICBjb250ZW50VHlwZTogYXBpLmNvbnRlbnRfdHlwZSxcbiAgICBmaWxlU2l6ZTogYXBpLmZpbGVfc2l6ZSxcbiAgICBzdGF0dXM6IGFwaS5zdGF0dXMsXG4gICAgZXJyb3JNZXNzYWdlOiBhcGkuZXJyb3JfbWVzc2FnZSxcbiAgICBwcm9jZXNzaW5nU3RhcnRlZEF0OiBhcGkucHJvY2Vzc2luZ19zdGFydGVkX2F0LFxuICAgIHByb2Nlc3NpbmdDb21wbGV0ZWRBdDogYXBpLnByb2Nlc3NpbmdfY29tcGxldGVkX2F0LFxuICAgIGNodW5rQ291bnQ6IGFwaS5jaHVua19jb3VudCxcbiAgICB0b2tlbkNvdW50OiBhcGkudG9rZW5fY291bnQsXG4gICAgbWV0YWRhdGE6IGFwaS5tZXRhZGF0YSxcbiAgICBjcmVhdGVkQXQ6IGFwaS5jcmVhdGVkX2F0LFxuICAgIHVwZGF0ZWRBdDogYXBpLnVwZGF0ZWRfYXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQYXJ0aWFsRG9jdW1lbnQoYXBpLCBvcHRpb25zKSB7XG4gIGxldCBzb3VyY2VUeXBlID0gXCJ0ZXh0XCI7XG4gIGlmIChvcHRpb25zLnVybCkgc291cmNlVHlwZSA9IFwidXJsXCI7XG4gIGlmIChvcHRpb25zLmZpbGUpIHNvdXJjZVR5cGUgPSBcImZpbGVcIjtcbiAgcmV0dXJuIHtcbiAgICBpZDogYXBpLmlkIHx8IFwiXCIsXG4gICAgY29sbGVjdGlvbklkOiBhcGkuY29sbGVjdGlvbl9pZCB8fCBvcHRpb25zLmNvbGxlY3Rpb25JZCB8fCBcIlwiLFxuICAgIGZpbGVuYW1lOiBhcGkuZmlsZW5hbWUgfHwgb3B0aW9ucy5maWxlbmFtZSxcbiAgICBzb3VyY2VUeXBlOiBhcGkuc291cmNlX3R5cGUgfHwgc291cmNlVHlwZSxcbiAgICBzb3VyY2VVcmw6IGFwaS5zb3VyY2VfdXJsID8/IG9wdGlvbnMudXJsID8/IG51bGwsXG4gICAgY29udGVudFR5cGU6IGFwaS5jb250ZW50X3R5cGUgPz8gb3B0aW9ucy5maWxlPy5jb250ZW50VHlwZSA/PyBudWxsLFxuICAgIGZpbGVTaXplOiBhcGkuZmlsZV9zaXplID8/IG51bGwsXG4gICAgc3RhdHVzOiBhcGkuc3RhdHVzIHx8IFwicGVuZGluZ1wiLFxuICAgIGVycm9yTWVzc2FnZTogYXBpLmVycm9yX21lc3NhZ2UgPz8gbnVsbCxcbiAgICBwcm9jZXNzaW5nU3RhcnRlZEF0OiBhcGkucHJvY2Vzc2luZ19zdGFydGVkX2F0ID8/IG51bGwsXG4gICAgcHJvY2Vzc2luZ0NvbXBsZXRlZEF0OiBhcGkucHJvY2Vzc2luZ19jb21wbGV0ZWRfYXQgPz8gbnVsbCxcbiAgICBjaHVua0NvdW50OiBhcGkuY2h1bmtfY291bnQgPz8gMCxcbiAgICB0b2tlbkNvdW50OiBhcGkudG9rZW5fY291bnQgPz8gbnVsbCxcbiAgICBtZXRhZGF0YTogYXBpLm1ldGFkYXRhIHx8IG9wdGlvbnMubWV0YWRhdGEgfHwge30sXG4gICAgY3JlYXRlZEF0OiBhcGkuY3JlYXRlZF9hdCB8fCAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBhcGkudXBkYXRlZF9hdCB8fCBhcGkuY3JlYXRlZF9hdCB8fCAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hSZXN1bHQoYXBpKSB7XG4gIHJldHVybiB7XG4gICAgY2h1bmtJZDogYXBpLmNodW5rX2lkLFxuICAgIGRvY3VtZW50SWQ6IGFwaS5kb2N1bWVudF9pZCxcbiAgICBmaWxlbmFtZTogYXBpLmZpbGVuYW1lLFxuICAgIGNvbnRlbnQ6IGFwaS5jb250ZW50LFxuICAgIHNjb3JlOiBhcGkuc2NvcmUsXG4gICAgY2h1bmtJbmRleDogYXBpLmNodW5rX2luZGV4LFxuICAgIG1ldGFkYXRhOiBhcGkubWV0YWRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hSZXNwb25zZShhcGkpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN1bHRzOiBhcGkucmVzdWx0cy5tYXAoY29udmVydFNlYXJjaFJlc3VsdCksXG4gICAgcXVlcnk6IGFwaS5xdWVyeSxcbiAgICBjb2xsZWN0aW9uSWQ6IGFwaS5jb2xsZWN0aW9uX2lkLFxuICAgIHRvdGFsUmVzdWx0czogYXBpLnRvdGFsX3Jlc3VsdHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBSVNlYXJjaFNvdXJjZShhcGkpIHtcbiAgcmV0dXJuIHtcbiAgICBkb2N1bWVudElkOiBhcGkuZG9jdW1lbnRfaWQsXG4gICAgZmlsZW5hbWU6IGFwaS5maWxlbmFtZSxcbiAgICBjaHVua0lkOiBhcGkuY2h1bmtfaWQsXG4gICAgZXhjZXJwdDogYXBpLmV4Y2VycHQsXG4gICAgc2NvcmU6IGFwaS5zY29yZVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydEFJU2VhcmNoUmVzdWx0KGFwaSkge1xuICByZXR1cm4ge1xuICAgIGFuc3dlcjogYXBpLmFuc3dlcixcbiAgICBzb3VyY2VzOiBhcGkuc291cmNlcy5tYXAoY29udmVydEFJU2VhcmNoU291cmNlKSxcbiAgICBxdWVyeTogYXBpLnF1ZXJ5LFxuICAgIG1vZGVsOiBhcGkubW9kZWwsXG4gICAgdXNhZ2U6IHtcbiAgICAgIGlucHV0VG9rZW5zOiBhcGkudXNhZ2UuaW5wdXRfdG9rZW5zLFxuICAgICAgb3V0cHV0VG9rZW5zOiBhcGkudXNhZ2Uub3V0cHV0X3Rva2Vuc1xuICAgIH1cbiAgfTtcbn1cbnZhciBCbGlua1JBR0ltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMucHJvamVjdElkID0gaHR0cENsaWVudC5wcm9qZWN0SWQ7XG4gIH1cbiAgcHJvamVjdElkO1xuICAvKipcbiAgICogQnVpbGQgVVJMIHdpdGggcHJvamVjdF9pZCBwcmVmaXhcbiAgICovXG4gIHVybChwYXRoKSB7XG4gICAgcmV0dXJuIGAvYXBpL3JhZy8ke3RoaXMucHJvamVjdElkfSR7cGF0aH1gO1xuICB9XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ29sbGVjdGlvbnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJBRyBjb2xsZWN0aW9uXG4gICAqL1xuICBhc3luYyBjcmVhdGVDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBib2R5ID0gcmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zLmRlc2NyaXB0aW9uLFxuICAgICAgZW1iZWRkaW5nX21vZGVsOiBvcHRpb25zLmVtYmVkZGluZ01vZGVsLFxuICAgICAgZW1iZWRkaW5nX2RpbWVuc2lvbnM6IG9wdGlvbnMuZW1iZWRkaW5nRGltZW5zaW9ucyxcbiAgICAgIGluZGV4X21ldHJpYzogb3B0aW9ucy5pbmRleE1ldHJpYyxcbiAgICAgIGNodW5rX21heF90b2tlbnM6IG9wdGlvbnMuY2h1bmtNYXhUb2tlbnMsXG4gICAgICBjaHVua19vdmVybGFwX3Rva2Vuczogb3B0aW9ucy5jaHVua092ZXJsYXBUb2tlbnMsXG4gICAgICBzaGFyZWQ6IG9wdGlvbnMuc2hhcmVkXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdCh0aGlzLnVybChcIi9jb2xsZWN0aW9uc1wiKSwgYm9keSk7XG4gICAgcmV0dXJuIGNvbnZlcnRDb2xsZWN0aW9uKHJlc3BvbnNlLmRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IGFsbCBjb2xsZWN0aW9ucyBhY2Nlc3NpYmxlIHRvIHRoZSBjdXJyZW50IHVzZXJcbiAgICovXG4gIGFzeW5jIGxpc3RDb2xsZWN0aW9ucygpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5nZXQodGhpcy51cmwoXCIvY29sbGVjdGlvbnNcIikpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmNvbGxlY3Rpb25zLm1hcChjb252ZXJ0Q29sbGVjdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHNwZWNpZmljIGNvbGxlY3Rpb24gYnkgSURcbiAgICovXG4gIGFzeW5jIGdldENvbGxlY3Rpb24oY29sbGVjdGlvbklkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZ2V0KHRoaXMudXJsKGAvY29sbGVjdGlvbnMvJHtjb2xsZWN0aW9uSWR9YCkpO1xuICAgIHJldHVybiBjb252ZXJ0Q29sbGVjdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgY29sbGVjdGlvbiBhbmQgYWxsIGl0cyBkb2N1bWVudHNcbiAgICovXG4gIGFzeW5jIGRlbGV0ZUNvbGxlY3Rpb24oY29sbGVjdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRlbGV0ZSh0aGlzLnVybChgL2NvbGxlY3Rpb25zLyR7Y29sbGVjdGlvbklkfWApKTtcbiAgfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERvY3VtZW50c1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBVcGxvYWQgYSBkb2N1bWVudCBmb3IgcHJvY2Vzc2luZ1xuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogLy8gVXBsb2FkIHRleHQgY29udGVudFxuICAgKiBjb25zdCBkb2MgPSBhd2FpdCBibGluay5yYWcudXBsb2FkKHtcbiAgICogICBjb2xsZWN0aW9uTmFtZTogJ2RvY3MnLFxuICAgKiAgIGZpbGVuYW1lOiAnbm90ZXMudHh0JyxcbiAgICogICBjb250ZW50OiAnTXkgZG9jdW1lbnQgY29udGVudC4uLidcbiAgICogfSlcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVwbG9hZCBmcm9tIFVSTFxuICAgKiBjb25zdCBkb2MgPSBhd2FpdCBibGluay5yYWcudXBsb2FkKHtcbiAgICogICBjb2xsZWN0aW9uSWQ6ICdjb2xfYWJjMTIzJyxcbiAgICogICBmaWxlbmFtZTogJ2FydGljbGUuaHRtbCcsXG4gICAqICAgdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hcnRpY2xlJ1xuICAgKiB9KVxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogLy8gVXBsb2FkIGEgZmlsZSAoYmFzZTY0KVxuICAgKiBjb25zdCBkb2MgPSBhd2FpdCBibGluay5yYWcudXBsb2FkKHtcbiAgICogICBjb2xsZWN0aW9uTmFtZTogJ2RvY3MnLFxuICAgKiAgIGZpbGVuYW1lOiAncmVwb3J0LnBkZicsXG4gICAqICAgZmlsZTogeyBkYXRhOiBiYXNlNjREYXRhLCBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3BkZicgfVxuICAgKiB9KVxuICAgKi9cbiAgYXN5bmMgdXBsb2FkKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuY29sbGVjdGlvbklkICYmICFvcHRpb25zLmNvbGxlY3Rpb25OYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsZWN0aW9uSWQgb3IgY29sbGVjdGlvbk5hbWUgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSByZW1vdmVVbmRlZmluZWQoe1xuICAgICAgY29sbGVjdGlvbl9pZDogb3B0aW9ucy5jb2xsZWN0aW9uSWQsXG4gICAgICBjb2xsZWN0aW9uX25hbWU6IG9wdGlvbnMuY29sbGVjdGlvbk5hbWUsXG4gICAgICBmaWxlbmFtZTogb3B0aW9ucy5maWxlbmFtZSxcbiAgICAgIGNvbnRlbnQ6IG9wdGlvbnMuY29udGVudCxcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLmZpbGUpIHtcbiAgICAgIGJvZHkuZmlsZSA9IHtcbiAgICAgICAgZGF0YTogb3B0aW9ucy5maWxlLmRhdGEsXG4gICAgICAgIGNvbnRlbnRfdHlwZTogb3B0aW9ucy5maWxlLmNvbnRlbnRUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5wb3N0KHRoaXMudXJsKFwiL2RvY3VtZW50c1wiKSwgYm9keSk7XG4gICAgcmV0dXJuIGNvbnZlcnRQYXJ0aWFsRG9jdW1lbnQocmVzcG9uc2UuZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBkb2N1bWVudCBzdGF0dXMgYW5kIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudChkb2N1bWVudElkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZ2V0KHRoaXMudXJsKGAvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH1gKSk7XG4gICAgcmV0dXJuIGNvbnZlcnREb2N1bWVudChyZXNwb25zZS5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBkb2N1bWVudHMsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgY29sbGVjdGlvbiBvciBzdGF0dXNcbiAgICovXG4gIGFzeW5jIGxpc3REb2N1bWVudHMob3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgIGlmIChvcHRpb25zPy5jb2xsZWN0aW9uSWQpIHBhcmFtcy5jb2xsZWN0aW9uX2lkID0gb3B0aW9ucy5jb2xsZWN0aW9uSWQ7XG4gICAgaWYgKG9wdGlvbnM/LnN0YXR1cykgcGFyYW1zLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzO1xuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPiAwID8gYD8ke25ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpfWAgOiBcIlwiO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmdldChcbiAgICAgIHRoaXMudXJsKGAvZG9jdW1lbnRzJHtxdWVyeVN0cmluZ31gKVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZG9jdW1lbnRzLm1hcChjb252ZXJ0RG9jdW1lbnQpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBkb2N1bWVudCBhbmQgaXRzIGNodW5rc1xuICAgKi9cbiAgYXN5bmMgZGVsZXRlRG9jdW1lbnQoZG9jdW1lbnRJZCkge1xuICAgIGF3YWl0IHRoaXMuaHR0cENsaWVudC5kZWxldGUodGhpcy51cmwoYC9kb2N1bWVudHMvJHtkb2N1bWVudElkfWApKTtcbiAgfVxuICAvKipcbiAgICogV2FpdCBmb3IgYSBkb2N1bWVudCB0byBmaW5pc2ggcHJvY2Vzc2luZ1xuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZG9jID0gYXdhaXQgYmxpbmsucmFnLnVwbG9hZCh7IC4uLiB9KVxuICAgKiBjb25zdCByZWFkeURvYyA9IGF3YWl0IGJsaW5rLnJhZy53YWl0Rm9yUmVhZHkoZG9jLmlkKVxuICAgKiBjb25zb2xlLmxvZyhgUHJvY2Vzc2VkICR7cmVhZHlEb2MuY2h1bmtDb3VudH0gY2h1bmtzYClcbiAgICovXG4gIGFzeW5jIHdhaXRGb3JSZWFkeShkb2N1bWVudElkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0aW1lb3V0TXMgPSAxMmU0LCBwb2xsSW50ZXJ2YWxNcyA9IDJlMyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydCA8IHRpbWVvdXRNcykge1xuICAgICAgY29uc3QgZG9jID0gYXdhaXQgdGhpcy5nZXREb2N1bWVudChkb2N1bWVudElkKTtcbiAgICAgIGlmIChkb2Muc3RhdHVzID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH1cbiAgICAgIGlmIChkb2Muc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb2N1bWVudCBwcm9jZXNzaW5nIGZhaWxlZDogJHtkb2MuZXJyb3JNZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9sbEludGVydmFsTXMpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBEb2N1bWVudCBwcm9jZXNzaW5nIHRpbWVvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKTtcbiAgfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNlYXJjaFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIHNpbWlsYXIgY2h1bmtzIHVzaW5nIHZlY3RvciBzaW1pbGFyaXR5XG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXN1bHRzID0gYXdhaXQgYmxpbmsucmFnLnNlYXJjaCh7XG4gICAqICAgY29sbGVjdGlvbk5hbWU6ICdkb2NzJyxcbiAgICogICBxdWVyeTogJ0hvdyBkbyBJIGNvbmZpZ3VyZSBhdXRoZW50aWNhdGlvbj8nLFxuICAgKiAgIG1heFJlc3VsdHM6IDVcbiAgICogfSlcbiAgICovXG4gIGFzeW5jIHNlYXJjaChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmNvbGxlY3Rpb25JZCAmJiAhb3B0aW9ucy5jb2xsZWN0aW9uTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGVjdGlvbklkIG9yIGNvbGxlY3Rpb25OYW1lIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gcmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgIGNvbGxlY3Rpb25faWQ6IG9wdGlvbnMuY29sbGVjdGlvbklkLFxuICAgICAgY29sbGVjdGlvbl9uYW1lOiBvcHRpb25zLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgcXVlcnk6IG9wdGlvbnMucXVlcnksXG4gICAgICBtYXhfcmVzdWx0czogb3B0aW9ucy5tYXhSZXN1bHRzLFxuICAgICAgc2NvcmVfdGhyZXNob2xkOiBvcHRpb25zLnNjb3JlVGhyZXNob2xkLFxuICAgICAgZmlsdGVyczogb3B0aW9ucy5maWx0ZXJzLFxuICAgICAgaW5jbHVkZV9jb250ZW50OiBvcHRpb25zLmluY2x1ZGVDb250ZW50XG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdCh0aGlzLnVybChcIi9zZWFyY2hcIiksIGJvZHkpO1xuICAgIHJldHVybiBjb252ZXJ0U2VhcmNoUmVzcG9uc2UocmVzcG9uc2UuZGF0YSk7XG4gIH1cbiAgYXN5bmMgYWlTZWFyY2gob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5jb2xsZWN0aW9uSWQgJiYgIW9wdGlvbnMuY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxlY3Rpb25JZCBvciBjb2xsZWN0aW9uTmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICBjb2xsZWN0aW9uX2lkOiBvcHRpb25zLmNvbGxlY3Rpb25JZCxcbiAgICAgIGNvbGxlY3Rpb25fbmFtZTogb3B0aW9ucy5jb2xsZWN0aW9uTmFtZSxcbiAgICAgIHF1ZXJ5OiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICBtYXhfY29udGV4dF9jaHVua3M6IG9wdGlvbnMubWF4Q29udGV4dENodW5rcyxcbiAgICAgIHNjb3JlX3RocmVzaG9sZDogb3B0aW9ucy5zY29yZVRocmVzaG9sZCxcbiAgICAgIHN5c3RlbV9wcm9tcHQ6IG9wdGlvbnMuc3lzdGVtUHJvbXB0LFxuICAgICAgc3RyZWFtOiBvcHRpb25zLnN0cmVhbVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJhZ0FpU2VhcmNoU3RyZWFtKGJvZHksIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXNwb25zZTIuYm9keTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdCh0aGlzLnVybChcIi9haS1zZWFyY2hcIiksIGJvZHkpO1xuICAgIHJldHVybiBjb252ZXJ0QUlTZWFyY2hSZXN1bHQocmVzcG9uc2UuZGF0YSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zYW5kYm94LnRzXG52YXIgU0FOREJPWF9URU1QTEFURVMgPSBbXG4gIFwiZGV2dG9vbHMtYmFzZVwiLFxuICAvLyBOb2RlIDIyICsgQnVuICsgUHl0aG9uICsgR2l0ICsgcmlwZ3JlcCAoREVGQVVMVClcbiAgXCJuZXh0anMtYXBwXCIsXG4gIC8vIE5leHQuanMgKyBUYWlsd2luZCArIHNoYWRjbiBVSSAoTm9kZSlcbiAgXCJuZXh0anMtYXBwLWJ1blwiLFxuICAvLyBOZXh0LmpzICsgVGFpbHdpbmQgKyBzaGFkY24gVUkgKEJ1bilcbiAgXCJ2aXRlLXJlYWN0XCIsXG4gIC8vIFZpdGUgKyBSZWFjdCArIFRhaWx3aW5kICsgc2hhZGNuIChOb2RlKVxuICBcInZpdGUtcmVhY3QtYnVuXCIsXG4gIC8vIFZpdGUgKyBSZWFjdCArIFRhaWx3aW5kICsgc2hhZGNuIChCdW4pXG4gIFwiZXhwby1hcHBcIixcbiAgLy8gRXhwbyArIFJlYWN0IE5hdGl2ZVxuICBcImRlc2t0b3BcIixcbiAgLy8gRWxlY3Ryb24gKyBWaXRlICsgUmVhY3RcbiAgXCJjbGF1ZGUtY29kZVwiXG4gIC8vIE5vZGUgMjEgKyBQeXRob24gKyBHaXQgKyByaXBncmVwXG5dO1xudmFyIFNhbmRib3hDb25uZWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgc2FuZGJveElkO1xuICBjb25zdHJ1Y3RvcihzYW5kYm94SWQsIGNhdXNlKSB7XG4gICAgc3VwZXIoYEZhaWxlZCB0byBjb25uZWN0IHRvIHNhbmRib3ggJHtzYW5kYm94SWR9YCk7XG4gICAgdGhpcy5uYW1lID0gXCJTYW5kYm94Q29ubmVjdGlvbkVycm9yXCI7XG4gICAgdGhpcy5zYW5kYm94SWQgPSBzYW5kYm94SWQ7XG4gICAgaWYgKGNhdXNlKSB7XG4gICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxuICB9XG59O1xudmFyIFNhbmRib3hJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpZCwgdGVtcGxhdGUsIGhvc3RQYXR0ZXJuKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB0aGlzLmhvc3RQYXR0ZXJuID0gaG9zdFBhdHRlcm47XG4gIH1cbiAgZ2V0SG9zdChwb3J0KSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdFBhdHRlcm4ucmVwbGFjZShcIntwb3J0fVwiLCBTdHJpbmcocG9ydCkpO1xuICB9XG59O1xudmFyIE1BWF9SRVRSSUVTID0gMztcbnZhciBJTklUSUFMX1JFVFJZX0RFTEFZX01TID0gMjUwO1xudmFyIEJsaW5rU2FuZGJveEltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMucHJvamVjdElkID0gaHR0cENsaWVudC5wcm9qZWN0SWQ7XG4gIH1cbiAgcHJvamVjdElkO1xuICAvKipcbiAgICogQnVpbGQgVVJMIHdpdGggcHJvamVjdF9pZCBwcmVmaXhcbiAgICovXG4gIHVybChwYXRoKSB7XG4gICAgcmV0dXJuIGAvYXBpL3NhbmRib3gvJHt0aGlzLnByb2plY3RJZH0ke3BhdGh9YDtcbiAgfVxuICBhc3luYyBjcmVhdGUob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIHRlbXBsYXRlOiBvcHRpb25zLnRlbXBsYXRlLFxuICAgICAgdGltZW91dF9tczogb3B0aW9ucy50aW1lb3V0TXMsXG4gICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgIHNlY3JldHM6IG9wdGlvbnMuc2VjcmV0c1xuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdCh0aGlzLnVybChcIi9jcmVhdGVcIiksIGJvZHkpO1xuICAgIGNvbnN0IHsgaWQsIHRlbXBsYXRlLCBob3N0X3BhdHRlcm4gfSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgcmV0dXJuIG5ldyBTYW5kYm94SW1wbChpZCwgdGVtcGxhdGUsIGhvc3RfcGF0dGVybik7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChzYW5kYm94SWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBsYXN0RXJyb3I7XG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBNQVhfUkVUUklFUzsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgIHNhbmRib3hfaWQ6IHNhbmRib3hJZCxcbiAgICAgICAgICB0aW1lb3V0X21zOiBvcHRpb25zLnRpbWVvdXRNc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5wb3N0KHRoaXMudXJsKFwiL2Nvbm5lY3RcIiksIGJvZHkpO1xuICAgICAgICBjb25zdCB7IGlkLCB0ZW1wbGF0ZSwgaG9zdF9wYXR0ZXJuIH0gPSByZXNwb25zZS5kYXRhO1xuICAgICAgICByZXR1cm4gbmV3IFNhbmRib3hJbXBsKGlkLCB0ZW1wbGF0ZSwgaG9zdF9wYXR0ZXJuKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtTYW5kYm94XSBDb25uZWN0IGF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpO1xuICAgICAgICBpZiAobGFzdEVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCI0MDRcIikgfHwgbGFzdEVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJub3QgZm91bmRcIikgfHwgbGFzdEVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJ1bmF1dGhvcml6ZWRcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU2FuZGJveENvbm5lY3Rpb25FcnJvcihzYW5kYm94SWQsIGxhc3RFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dGVtcHQgPCBNQVhfUkVUUklFUyAtIDEpIHtcbiAgICAgICAgICBjb25zdCBkZWxheSA9IElOSVRJQUxfUkVUUllfREVMQVlfTVMgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoYFtTYW5kYm94XSBBbGwgJHtNQVhfUkVUUklFU30gY29ubmVjdGlvbiBhdHRlbXB0cyBmYWlsZWQgZm9yIHNhbmRib3ggJHtzYW5kYm94SWR9YCk7XG4gICAgdGhyb3cgbmV3IFNhbmRib3hDb25uZWN0aW9uRXJyb3Ioc2FuZGJveElkLCBsYXN0RXJyb3IpO1xuICB9XG4gIGFzeW5jIGtpbGwoc2FuZGJveElkKSB7XG4gICAgYXdhaXQgdGhpcy5odHRwQ2xpZW50LnBvc3QodGhpcy51cmwoXCIva2lsbFwiKSwgeyBzYW5kYm94X2lkOiBzYW5kYm94SWQgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9jbGllbnQudHNcbnZhciBkZWZhdWx0Q2xpZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldERlZmF1bHRDbGllbnQoKSB7XG4gIGlmICghZGVmYXVsdENsaWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiTm8gQmxpbmsgY2xpZW50IGluaXRpYWxpemVkLiBDYWxsIGNyZWF0ZUNsaWVudCgpIGZpcnN0IGJlZm9yZSB1c2luZyBBZ2VudCBvciBvdGhlciBTREsgZmVhdHVyZXMuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBkZWZhdWx0Q2xpZW50O1xufVxuZnVuY3Rpb24gX2dldERlZmF1bHRIdHRwQ2xpZW50KCkge1xuICByZXR1cm4gZ2V0RGVmYXVsdENsaWVudCgpLl9odHRwQ2xpZW50O1xufVxudmFyIEJsaW5rQ2xpZW50SW1wbCA9IGNsYXNzIHtcbiAgYXV0aDtcbiAgZGI7XG4gIHN0b3JhZ2U7XG4gIGFpO1xuICBkYXRhO1xuICByZWFsdGltZTtcbiAgbm90aWZpY2F0aW9ucztcbiAgYW5hbHl0aWNzO1xuICBjb25uZWN0b3JzO1xuICBmdW5jdGlvbnM7XG4gIHJhZztcbiAgc2FuZGJveDtcbiAgLyoqIEBpbnRlcm5hbCBIVFRQIGNsaWVudCBmb3IgQWdlbnQgYXV0by1iaW5kaW5nICovXG4gIF9odHRwQ2xpZW50O1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBpZiAoKGNvbmZpZy5zZWNyZXRLZXkgfHwgY29uZmlnLnNlcnZpY2VUb2tlbikgJiYgaXNCcm93c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWNyZXRLZXkvc2VydmljZVRva2VuIGlzIHNlcnZlci1vbmx5LiBEbyBub3QgcHJvdmlkZSBpdCBpbiBicm93c2VyL1JlYWN0IE5hdGl2ZSBjbGllbnRzLlwiKTtcbiAgICB9XG4gICAgdGhpcy5hdXRoID0gbmV3IEJsaW5rQXV0aChjb25maWcpO1xuICAgIHRoaXMuX2h0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudChcbiAgICAgIGNvbmZpZyxcbiAgICAgICgpID0+IHRoaXMuYXV0aC5nZXRUb2tlbigpLFxuICAgICAgKCkgPT4gdGhpcy5hdXRoLmdldFZhbGlkVG9rZW4oKVxuICAgICk7XG4gICAgdGhpcy5kYiA9IG5ldyBCbGlua0RhdGFiYXNlKHRoaXMuX2h0dHBDbGllbnQpO1xuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBCbGlua1N0b3JhZ2VJbXBsKHRoaXMuX2h0dHBDbGllbnQpO1xuICAgIHRoaXMuYWkgPSBuZXcgQmxpbmtBSUltcGwodGhpcy5faHR0cENsaWVudCk7XG4gICAgdGhpcy5kYXRhID0gbmV3IEJsaW5rRGF0YUltcGwodGhpcy5faHR0cENsaWVudCwgY29uZmlnLnByb2plY3RJZCk7XG4gICAgdGhpcy5yZWFsdGltZSA9IG5ldyBCbGlua1JlYWx0aW1lSW1wbCh0aGlzLl9odHRwQ2xpZW50LCBjb25maWcucHJvamVjdElkKTtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBuZXcgQmxpbmtOb3RpZmljYXRpb25zSW1wbCh0aGlzLl9odHRwQ2xpZW50KTtcbiAgICB0aGlzLmFuYWx5dGljcyA9IG5ldyBCbGlua0FuYWx5dGljc0ltcGwodGhpcy5faHR0cENsaWVudCwgY29uZmlnLnByb2plY3RJZCk7XG4gICAgdGhpcy5jb25uZWN0b3JzID0gbmV3IEJsaW5rQ29ubmVjdG9yc0ltcGwodGhpcy5faHR0cENsaWVudCk7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBuZXcgQmxpbmtGdW5jdGlvbnNJbXBsKFxuICAgICAgdGhpcy5faHR0cENsaWVudCxcbiAgICAgIGNvbmZpZy5wcm9qZWN0SWQsXG4gICAgICAoKSA9PiB0aGlzLmF1dGguZ2V0VmFsaWRUb2tlbigpXG4gICAgKTtcbiAgICB0aGlzLnJhZyA9IG5ldyBCbGlua1JBR0ltcGwodGhpcy5faHR0cENsaWVudCk7XG4gICAgdGhpcy5zYW5kYm94ID0gbmV3IEJsaW5rU2FuZGJveEltcGwodGhpcy5faHR0cENsaWVudCk7XG4gICAgdGhpcy5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlZCgoc3RhdGUpID0+IHtcbiAgICAgIGlmIChzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQgJiYgc3RhdGUudXNlcikge1xuICAgICAgICB0aGlzLmFuYWx5dGljcy5zZXRVc2VySWQoc3RhdGUudXNlci5pZCk7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzLnNldFVzZXJFbWFpbChzdGF0ZS51c2VyLmVtYWlsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzLnNldFVzZXJJZChudWxsKTtcbiAgICAgICAgdGhpcy5hbmFseXRpY3Muc2V0VXNlckVtYWlsKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KGNvbmZpZykge1xuICBpZiAoIWNvbmZpZy5wcm9qZWN0SWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9qZWN0SWQgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgY29uc3QgY2xpZW50ID0gbmV3IEJsaW5rQ2xpZW50SW1wbChjb25maWcpO1xuICBkZWZhdWx0Q2xpZW50ID0gY2xpZW50O1xuICByZXR1cm4gY2xpZW50O1xufVxuXG5leHBvcnQgeyBBZ2VudCwgQXN5bmNTdG9yYWdlQWRhcHRlciwgQmxpbmtBSUltcGwsIEJsaW5rQW5hbHl0aWNzSW1wbCwgQmxpbmtDb25uZWN0b3JzSW1wbCwgQmxpbmtEYXRhSW1wbCwgQmxpbmtEYXRhYmFzZSwgQmxpbmtSQUdJbXBsLCBCbGlua1JlYWx0aW1lQ2hhbm5lbCwgQmxpbmtSZWFsdGltZUltcGwsIEJsaW5rU2FuZGJveEltcGwsIEJsaW5rU3RvcmFnZUltcGwsIEJsaW5rVGFibGUsIE5vT3BTdG9yYWdlQWRhcHRlciwgU0FOREJPWF9URU1QTEFURVMsIFNhbmRib3hDb25uZWN0aW9uRXJyb3IsIFdlYlN0b3JhZ2VBZGFwdGVyLCBjb3JlVG9vbHMsIGNyZWF0ZUNsaWVudCwgZGJEZWxldGUsIGRiR2V0LCBkYkluc2VydCwgZGJMaXN0LCBkYlRvb2xzLCBkYlVwZGF0ZSwgZWRpdEltYWdlLCBmZXRjaFVybCwgZ2VuZXJhdGVJbWFnZSwgZ2VuZXJhdGVWaWRlbywgZ2V0RGVmYXVsdENsaWVudCwgZ2V0RGVmYXVsdFN0b3JhZ2VBZGFwdGVyLCBnZXRIb3N0LCBnbG9iRmlsZVNlYXJjaCwgZ3JlcCwgaW1hZ2VUb1ZpZGVvLCBpc0Jyb3dzZXIsIGlzRGVubywgaXNOb2RlLCBpc1JlYWN0TmF0aXZlLCBpc1NlcnZlciwgaXNXZWIsIGxpc3REaXIsIG1lZGlhVG9vbHMsIHBsYXRmb3JtLCByYWdTZWFyY2gsIHJhZ1Rvb2xzLCByZWFkRmlsZSwgcnVuQ29kZSwgcnVuVGVybWluYWxDbWQsIHNhbmRib3hUb29scywgc2VhcmNoUmVwbGFjZSwgc2VyaWFsaXplVG9vbHMsIHN0ZXBDb3VudElzLCBzdG9yYWdlQ29weSwgc3RvcmFnZURlbGV0ZSwgc3RvcmFnZURvd25sb2FkLCBzdG9yYWdlTGlzdCwgc3RvcmFnZU1vdmUsIHN0b3JhZ2VQdWJsaWNVcmwsIHN0b3JhZ2VUb29scywgc3RvcmFnZVVwbG9hZCwgd2ViU2VhcmNoLCB3cml0ZUZpbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@blinkdotnew/sdk/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Space_Grotesk%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-display%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22spaceGrotesk%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-sans%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Com%5C%5Cvs%20code%20scripts%5C%5Caesthetic-3d-image-describer%5C%5Csrc%5C%5Ccomponents%5C%5Cproviders%5C%5Cblink-provider.tsx%22%2C%22ids%22%3A%5B%22BlinkProvider%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);