"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@blinkdotnew";
exports.ids = ["vendor-chunks/@blinkdotnew"];
exports.modules = {

/***/ "(ssr)/./node_modules/@blinkdotnew/react/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@blinkdotnew/react/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.Agent),\n/* harmony export */   AsyncStorageAdapter: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.AsyncStorageAdapter),\n/* harmony export */   BlinkAIImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkAIImpl),\n/* harmony export */   BlinkAnalyticsImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkAnalyticsImpl),\n/* harmony export */   BlinkAuthProvider: () => (/* binding */ BlinkAuthProvider),\n/* harmony export */   BlinkConnectorsImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkConnectorsImpl),\n/* harmony export */   BlinkDataImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkDataImpl),\n/* harmony export */   BlinkDatabase: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkDatabase),\n/* harmony export */   BlinkProvider: () => (/* binding */ BlinkProvider),\n/* harmony export */   BlinkRAGImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkRAGImpl),\n/* harmony export */   BlinkRealtimeChannel: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkRealtimeChannel),\n/* harmony export */   BlinkRealtimeImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkRealtimeImpl),\n/* harmony export */   BlinkSandboxImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkSandboxImpl),\n/* harmony export */   BlinkStorageImpl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkStorageImpl),\n/* harmony export */   BlinkTable: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.BlinkTable),\n/* harmony export */   NoOpStorageAdapter: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.NoOpStorageAdapter),\n/* harmony export */   SANDBOX_TEMPLATES: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.SANDBOX_TEMPLATES),\n/* harmony export */   SandboxConnectionError: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.SandboxConnectionError),\n/* harmony export */   WebStorageAdapter: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.WebStorageAdapter),\n/* harmony export */   coreTools: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.coreTools),\n/* harmony export */   createClient: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.createClient),\n/* harmony export */   dbDelete: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbDelete),\n/* harmony export */   dbGet: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbGet),\n/* harmony export */   dbInsert: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbInsert),\n/* harmony export */   dbList: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbList),\n/* harmony export */   dbTools: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbTools),\n/* harmony export */   dbUpdate: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.dbUpdate),\n/* harmony export */   editImage: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.editImage),\n/* harmony export */   fetchUrl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.fetchUrl),\n/* harmony export */   generateImage: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.generateImage),\n/* harmony export */   generateVideo: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.generateVideo),\n/* harmony export */   getDefaultClient: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.getDefaultClient),\n/* harmony export */   getDefaultStorageAdapter: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.getDefaultStorageAdapter),\n/* harmony export */   getHost: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.getHost),\n/* harmony export */   globFileSearch: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.globFileSearch),\n/* harmony export */   grep: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.grep),\n/* harmony export */   imageToVideo: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.imageToVideo),\n/* harmony export */   isBrowser: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isBrowser),\n/* harmony export */   isDeno: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isDeno),\n/* harmony export */   isNode: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isNode),\n/* harmony export */   isReactNative: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isReactNative),\n/* harmony export */   isServer: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isServer),\n/* harmony export */   isWeb: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.isWeb),\n/* harmony export */   listDir: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.listDir),\n/* harmony export */   mediaTools: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.mediaTools),\n/* harmony export */   platform: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   ragSearch: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.ragSearch),\n/* harmony export */   ragTools: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.ragTools),\n/* harmony export */   readFile: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.readFile),\n/* harmony export */   runCode: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.runCode),\n/* harmony export */   runTerminalCmd: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.runTerminalCmd),\n/* harmony export */   sandboxTools: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.sandboxTools),\n/* harmony export */   searchReplace: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.searchReplace),\n/* harmony export */   serializeTools: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.serializeTools),\n/* harmony export */   stepCountIs: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.stepCountIs),\n/* harmony export */   storageCopy: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageCopy),\n/* harmony export */   storageDelete: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageDelete),\n/* harmony export */   storageDownload: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageDownload),\n/* harmony export */   storageList: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageList),\n/* harmony export */   storageMove: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageMove),\n/* harmony export */   storagePublicUrl: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storagePublicUrl),\n/* harmony export */   storageTools: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageTools),\n/* harmony export */   storageUpload: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.storageUpload),\n/* harmony export */   useAgent: () => (/* binding */ useAgent),\n/* harmony export */   useBlink: () => (/* binding */ useBlink),\n/* harmony export */   useBlinkAuth: () => (/* binding */ useBlinkAuth),\n/* harmony export */   useBlinkClient: () => (/* binding */ useBlinkClient),\n/* harmony export */   webSearch: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.webSearch),\n/* harmony export */   writeFile: () => (/* reexport safe */ _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.writeFile)\n/* harmony export */ });\n/* harmony import */ var _blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @blinkdotnew/sdk */ \"(ssr)/./node_modules/@blinkdotnew/sdk/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/index.ts\n\n\n// src/context.tsx\n\n\n\nvar BlinkContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction BlinkProvider({\n  projectId,\n  publishableKey,\n  secretKey,\n  auth,\n  children\n}) {\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => (0,_blinkdotnew_sdk__WEBPACK_IMPORTED_MODULE_0__.createClient)({\n      projectId,\n      publishableKey,\n      secretKey,\n      auth\n    }),\n    [projectId, publishableKey, secretKey, auth]\n  );\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => ({\n      client,\n      projectId\n    }),\n    [client, projectId]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlinkContext.Provider, { value, children });\n}\nfunction useBlink() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BlinkContext);\n  if (!context) {\n    throw new Error(\"useBlink must be used within a BlinkProvider\");\n  }\n  return context;\n}\nfunction useBlinkClient() {\n  return useBlink().client;\n}\nvar BlinkAuthContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction BlinkAuthProvider({ children }) {\n  const { client } = useBlink();\n  const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_1__.useState(true);\n  const [user, setUser] = react__WEBPACK_IMPORTED_MODULE_1__.useState(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    let mounted = true;\n    const initAuth = async () => {\n      try {\n        const currentUser = await client.auth.me();\n        if (mounted) {\n          setUser(currentUser);\n        }\n      } catch {\n        if (mounted) {\n          setUser(null);\n        }\n      } finally {\n        if (mounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n    initAuth();\n    const unsubscribe = client.auth.onAuthStateChanged((state) => {\n      setUser(state.user);\n    });\n    return () => {\n      mounted = false;\n      unsubscribe();\n    };\n  }, [client]);\n  const signIn = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    async (email, password) => {\n      const result = await client.auth.signInWithEmail(email, password);\n      setUser(result);\n    },\n    [client]\n  );\n  const signUp = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    async (email, password) => {\n      const result = await client.auth.signUp({ email, password });\n      setUser(result);\n    },\n    [client]\n  );\n  const signOut = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(async () => {\n    await client.auth.signOut();\n    setUser(null);\n  }, [client]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => ({\n      isAuthenticated: !!user,\n      isLoading,\n      user,\n      signIn,\n      signUp,\n      signOut\n    }),\n    [isLoading, user, signIn, signUp, signOut]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlinkAuthContext.Provider, { value, children });\n}\nfunction useBlinkAuth() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BlinkAuthContext);\n  if (!context) {\n    throw new Error(\"useBlinkAuth must be used within a BlinkAuthProvider\");\n  }\n  return context;\n}\n\n// src/use-agent.ts\n\nfunction useAgent(options) {\n  const client = useBlinkClient();\n  const { agent: agentInput, initialMessages = [], sandbox, onFinish, onError } = options;\n  const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialMessages);\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n  const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const agent = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return client.ai.bindAgent(agentInput);\n  }, [agentInput, client]);\n  const agentModel = agent.model;\n  const generateId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    return `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;\n  }, []);\n  const parseStream = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    async (response, assistantMessageId) => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = \"\";\n      let currentText = \"\";\n      let currentParts = [];\n      let finishData = null;\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split(\"\\n\");\n          buffer = lines.pop() || \"\";\n          for (const line of lines) {\n            const trimmedLine = line.trim();\n            if (!trimmedLine || !trimmedLine.startsWith(\"data:\")) continue;\n            if (trimmedLine === \"data: [DONE]\" || trimmedLine === \"data:[DONE]\") continue;\n            try {\n              const jsonStr = trimmedLine.startsWith(\"data: \") ? trimmedLine.slice(6) : trimmedLine.slice(5);\n              if (!jsonStr.trim()) continue;\n              const json = JSON.parse(jsonStr);\n              switch (json.type) {\n                // Handle text events (AI SDK v5 uses 'text-delta' with 'delta' property)\n                case \"text-delta\":\n                case \"text\": {\n                  const textChunk = json.delta || json.textDelta || json.value || json.text || \"\";\n                  currentText += textChunk;\n                  setMessages(\n                    (prev) => prev.map(\n                      (m) => m.id === assistantMessageId ? { ...m, content: currentText, parts: [...currentParts.filter((p) => p.type !== \"text\"), { type: \"text\", text: currentText }] } : m\n                    )\n                  );\n                  break;\n                }\n                // Handle tool call events\n                case \"tool-call\":\n                case \"tool-call-start\": {\n                  const existingTool = currentParts.find(\n                    (p) => p.type === \"tool-invocation\" && p.toolCallId === json.toolCallId\n                  );\n                  if (!existingTool) {\n                    const toolPart = {\n                      type: \"tool-invocation\",\n                      toolCallId: json.toolCallId,\n                      toolName: json.toolName,\n                      state: \"pending\",\n                      input: json.args || {}\n                    };\n                    currentParts = [...currentParts.filter((p) => p.type !== \"text\"), toolPart];\n                    setMessages(\n                      (prev) => prev.map(\n                        (m) => m.id === assistantMessageId ? { ...m, parts: [...currentParts, { type: \"text\", text: currentText }] } : m\n                      )\n                    );\n                  }\n                  break;\n                }\n                // Handle tool result events\n                case \"tool-result\": {\n                  currentParts = currentParts.map(\n                    (p) => p.type === \"tool-invocation\" && p.toolCallId === json.toolCallId ? { ...p, state: \"result\", output: json.result } : p\n                  );\n                  setMessages(\n                    (prev) => prev.map(\n                      (m) => m.id === assistantMessageId ? { ...m, parts: [...currentParts.filter((p) => p.type !== \"text\"), { type: \"text\", text: currentText }] } : m\n                    )\n                  );\n                  break;\n                }\n                // Handle finish event\n                case \"finish\":\n                case \"done\": {\n                  finishData = json;\n                  break;\n                }\n                // Ignore other event types (start, text-start, text-end, etc.)\n                default:\n                  break;\n              }\n            } catch {\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n      return { text: currentText, finishData };\n    },\n    []\n  );\n  const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    async (content) => {\n      const messageContent = content ?? input;\n      if (!messageContent.trim() && messages.length === 0) return;\n      setError(null);\n      setIsLoading(true);\n      abortControllerRef.current = new AbortController();\n      try {\n        let newMessages = [...messages];\n        if (messageContent.trim()) {\n          const userMessage = {\n            id: generateId(),\n            role: \"user\",\n            content: messageContent.trim()\n          };\n          newMessages = [...newMessages, userMessage];\n          setMessages(newMessages);\n          setInput(\"\");\n        }\n        const assistantMessageId = generateId();\n        const assistantMessage = {\n          id: assistantMessageId,\n          role: \"assistant\",\n          content: \"\",\n          parts: []\n        };\n        setMessages([...newMessages, assistantMessage]);\n        const response = await agent.stream({\n          messages: newMessages,\n          sandbox,\n          signal: abortControllerRef.current.signal\n        });\n        const { text, finishData } = await parseStream(response, assistantMessageId);\n        setMessages(\n          (prev) => prev.map(\n            (m) => m.id === assistantMessageId ? { ...m, content: text } : m\n          )\n        );\n        if (onFinish && finishData) {\n          onFinish({\n            text,\n            finishReason: finishData.finishReason || \"stop\",\n            steps: [],\n            usage: finishData.usage || { inputTokens: 0, outputTokens: 0 },\n            _billing: finishData._billing || { model: agentModel, creditsCharged: 0, costUSD: 0 }\n          });\n        }\n      } catch (err) {\n        const error2 = err instanceof Error ? err : new Error(String(err));\n        if (error2.name !== \"AbortError\") {\n          setError(error2);\n          onError?.(error2);\n        }\n      } finally {\n        setIsLoading(false);\n        abortControllerRef.current = null;\n      }\n    },\n    [agent, agentModel, messages, input, sandbox, generateId, parseStream, onFinish, onError]\n  );\n  const append = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((message) => {\n    setMessages((prev) => [...prev, { ...message, id: message.id || generateId() }]);\n  }, [generateId]);\n  const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (e) => {\n      setInput(e.target.value);\n    },\n    []\n  );\n  const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (e) => {\n      e?.preventDefault();\n      sendMessage();\n    },\n    [sendMessage]\n  );\n  const addToolOutput = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    ({ toolCallId, tool, output }) => {\n      setMessages(\n        (prev) => prev.map((m) => {\n          if (m.role !== \"assistant\" || !m.parts) return m;\n          const updatedParts = m.parts.map(\n            (p) => p.type === \"tool-invocation\" && p.toolCallId === toolCallId && p.toolName === tool ? { ...p, state: \"output-available\", output } : p\n          );\n          return { ...m, parts: updatedParts };\n        })\n      );\n    },\n    []\n  );\n  const clearMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    setMessages(initialMessages);\n    setError(null);\n  }, [initialMessages]);\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    abortControllerRef.current?.abort();\n  }, []);\n  const reload = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async () => {\n    let lastUserIndex = -1;\n    for (let i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].role === \"user\") {\n        lastUserIndex = i;\n        break;\n      }\n    }\n    if (lastUserIndex === -1) return;\n    const messagesUpToLastUser = messages.slice(0, lastUserIndex + 1);\n    setMessages(messagesUpToLastUser);\n    await sendMessage();\n  }, [messages, sendMessage]);\n  return {\n    messages,\n    input,\n    setInput,\n    isLoading,\n    error,\n    sendMessage,\n    append,\n    handleInputChange,\n    handleSubmit,\n    addToolOutput,\n    clearMessages,\n    stop,\n    reload\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsaW5rZG90bmV3L3JlYWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2lDOztBQUVqQztBQUNrRTtBQUNsQjtBQUNSO0FBQ3hDLG1CQUFtQixvREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLDhDQUFPO0FBQ3hCLFVBQVUsOERBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QixzREFBRywwQkFBMEIsaUJBQWlCO0FBQ3ZFO0FBQ0E7QUFDQSxrQkFBa0IsaURBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvREFBYTtBQUNwQyw2QkFBNkIsVUFBVTtBQUN2QyxVQUFVLFNBQVM7QUFDbkIsb0NBQW9DLDJDQUFjO0FBQ2xELDBCQUEwQiwyQ0FBYztBQUN4QyxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUIsOENBQWlCO0FBQ2xDO0FBQ0EsZ0RBQWdELGlCQUFpQjtBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFpQjtBQUNuQztB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QVc7QUFDNUI7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWVzdGhldGljLTNkLWltYWdlLWRlc2NyaWJlci8uL25vZGVfbW9kdWxlcy9AYmxpbmtkb3RuZXcvcmVhY3QvZGlzdC9pbmRleC5tanM/Y2M5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJAYmxpbmtkb3RuZXcvc2RrXCI7XG5cbi8vIHNyYy9jb250ZXh0LnRzeFxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCJAYmxpbmtkb3RuZXcvc2RrXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBCbGlua0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gQmxpbmtQcm92aWRlcih7XG4gIHByb2plY3RJZCxcbiAgcHVibGlzaGFibGVLZXksXG4gIHNlY3JldEtleSxcbiAgYXV0aCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlTWVtbyhcbiAgICAoKSA9PiBjcmVhdGVDbGllbnQoe1xuICAgICAgcHJvamVjdElkLFxuICAgICAgcHVibGlzaGFibGVLZXksXG4gICAgICBzZWNyZXRLZXksXG4gICAgICBhdXRoXG4gICAgfSksXG4gICAgW3Byb2plY3RJZCwgcHVibGlzaGFibGVLZXksIHNlY3JldEtleSwgYXV0aF1cbiAgKTtcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBjbGllbnQsXG4gICAgICBwcm9qZWN0SWRcbiAgICB9KSxcbiAgICBbY2xpZW50LCBwcm9qZWN0SWRdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEJsaW5rQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZSwgY2hpbGRyZW4gfSk7XG59XG5mdW5jdGlvbiB1c2VCbGluaygpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQmxpbmtDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlQmxpbmsgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJsaW5rUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB1c2VCbGlua0NsaWVudCgpIHtcbiAgcmV0dXJuIHVzZUJsaW5rKCkuY2xpZW50O1xufVxudmFyIEJsaW5rQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gQmxpbmtBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VCbGluaygpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBtb3VudGVkID0gdHJ1ZTtcbiAgICBjb25zdCBpbml0QXV0aCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgY2xpZW50LmF1dGgubWUoKTtcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICBzZXRVc2VyKGN1cnJlbnRVc2VyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgc2V0VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0QXV0aCgpO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY2xpZW50LmF1dGgub25BdXRoU3RhdGVDaGFuZ2VkKChzdGF0ZSkgPT4ge1xuICAgICAgc2V0VXNlcihzdGF0ZS51c2VyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbW91bnRlZCA9IGZhbHNlO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbY2xpZW50XSk7XG4gIGNvbnN0IHNpZ25JbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChlbWFpbCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5hdXRoLnNpZ25JbldpdGhFbWFpbChlbWFpbCwgcGFzc3dvcmQpO1xuICAgICAgc2V0VXNlcihyZXN1bHQpO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbiAgY29uc3Qgc2lnblVwID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGVtYWlsLCBwYXNzd29yZCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LmF1dGguc2lnblVwKHsgZW1haWwsIHBhc3N3b3JkIH0pO1xuICAgICAgc2V0VXNlcihyZXN1bHQpO1xuICAgIH0sXG4gICAgW2NsaWVudF1cbiAgKTtcbiAgY29uc3Qgc2lnbk91dCA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBjbGllbnQuYXV0aC5zaWduT3V0KCk7XG4gICAgc2V0VXNlcihudWxsKTtcbiAgfSwgW2NsaWVudF0pO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgdXNlcixcbiAgICAgIHNpZ25JbixcbiAgICAgIHNpZ25VcCxcbiAgICAgIHNpZ25PdXRcbiAgICB9KSxcbiAgICBbaXNMb2FkaW5nLCB1c2VyLCBzaWduSW4sIHNpZ25VcCwgc2lnbk91dF1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQmxpbmtBdXRoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZSwgY2hpbGRyZW4gfSk7XG59XG5mdW5jdGlvbiB1c2VCbGlua0F1dGgoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEJsaW5rQXV0aENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VCbGlua0F1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJsaW5rQXV0aFByb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG4vLyBzcmMvdXNlLWFnZW50LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlTWVtbyBhcyB1c2VNZW1vMiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlQWdlbnQob3B0aW9ucykge1xuICBjb25zdCBjbGllbnQgPSB1c2VCbGlua0NsaWVudCgpO1xuICBjb25zdCB7IGFnZW50OiBhZ2VudElucHV0LCBpbml0aWFsTWVzc2FnZXMgPSBbXSwgc2FuZGJveCwgb25GaW5pc2gsIG9uRXJyb3IgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGUoaW5pdGlhbE1lc3NhZ2VzKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBhZ2VudCA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICByZXR1cm4gY2xpZW50LmFpLmJpbmRBZ2VudChhZ2VudElucHV0KTtcbiAgfSwgW2FnZW50SW5wdXQsIGNsaWVudF0pO1xuICBjb25zdCBhZ2VudE1vZGVsID0gYWdlbnQubW9kZWw7XG4gIGNvbnN0IGdlbmVyYXRlSWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGBtc2dfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpfWA7XG4gIH0sIFtdKTtcbiAgY29uc3QgcGFyc2VTdHJlYW0gPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAocmVzcG9uc2UsIGFzc2lzdGFudE1lc3NhZ2VJZCkgPT4ge1xuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGJvZHlcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgICBsZXQgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgbGV0IGN1cnJlbnRQYXJ0cyA9IFtdO1xuICAgICAgbGV0IGZpbmlzaERhdGEgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGJ1ZmZlciA9IGxpbmVzLnBvcCgpIHx8IFwiXCI7XG4gICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkTGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCF0cmltbWVkTGluZSB8fCAhdHJpbW1lZExpbmUuc3RhcnRzV2l0aChcImRhdGE6XCIpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0cmltbWVkTGluZSA9PT0gXCJkYXRhOiBbRE9ORV1cIiB8fCB0cmltbWVkTGluZSA9PT0gXCJkYXRhOltET05FXVwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb25TdHIgPSB0cmltbWVkTGluZS5zdGFydHNXaXRoKFwiZGF0YTogXCIpID8gdHJpbW1lZExpbmUuc2xpY2UoNikgOiB0cmltbWVkTGluZS5zbGljZSg1KTtcbiAgICAgICAgICAgICAgaWYgKCFqc29uU3RyLnRyaW0oKSkgY29udGludWU7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGpzb24udHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0ZXh0IGV2ZW50cyAoQUkgU0RLIHY1IHVzZXMgJ3RleHQtZGVsdGEnIHdpdGggJ2RlbHRhJyBwcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDaHVuayA9IGpzb24uZGVsdGEgfHwganNvbi50ZXh0RGVsdGEgfHwganNvbi52YWx1ZSB8fCBqc29uLnRleHQgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ICs9IHRleHRDaHVuaztcbiAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKFxuICAgICAgICAgICAgICAgICAgICAocHJldikgPT4gcHJldi5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgKG0pID0+IG0uaWQgPT09IGFzc2lzdGFudE1lc3NhZ2VJZCA/IHsgLi4ubSwgY29udGVudDogY3VycmVudFRleHQsIHBhcnRzOiBbLi4uY3VycmVudFBhcnRzLmZpbHRlcigocCkgPT4gcC50eXBlICE9PSBcInRleHRcIiksIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGN1cnJlbnRUZXh0IH1dIH0gOiBtXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRvb2wgY2FsbCBldmVudHNcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1Rvb2wgPSBjdXJyZW50UGFydHMuZmluZChcbiAgICAgICAgICAgICAgICAgICAgKHApID0+IHAudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIiAmJiBwLnRvb2xDYWxsSWQgPT09IGpzb24udG9vbENhbGxJZFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdUb29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xQYXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDoganNvbi50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBqc29uLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dDoganNvbi5hcmdzIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0cyA9IFsuLi5jdXJyZW50UGFydHMuZmlsdGVyKChwKSA9PiBwLnR5cGUgIT09IFwidGV4dFwiKSwgdG9vbFBhcnRdO1xuICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhcbiAgICAgICAgICAgICAgICAgICAgICAocHJldikgPT4gcHJldi5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAobSkgPT4gbS5pZCA9PT0gYXNzaXN0YW50TWVzc2FnZUlkID8geyAuLi5tLCBwYXJ0czogWy4uLmN1cnJlbnRQYXJ0cywgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY3VycmVudFRleHQgfV0gfSA6IG1cbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRvb2wgcmVzdWx0IGV2ZW50c1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50UGFydHMgPSBjdXJyZW50UGFydHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAocCkgPT4gcC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiICYmIHAudG9vbENhbGxJZCA9PT0ganNvbi50b29sQ2FsbElkID8geyAuLi5wLCBzdGF0ZTogXCJyZXN1bHRcIiwgb3V0cHV0OiBqc29uLnJlc3VsdCB9IDogcFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKFxuICAgICAgICAgICAgICAgICAgICAocHJldikgPT4gcHJldi5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgKG0pID0+IG0uaWQgPT09IGFzc2lzdGFudE1lc3NhZ2VJZCA/IHsgLi4ubSwgcGFydHM6IFsuLi5jdXJyZW50UGFydHMuZmlsdGVyKChwKSA9PiBwLnR5cGUgIT09IFwidGV4dFwiKSwgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY3VycmVudFRleHQgfV0gfSA6IG1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZmluaXNoIGV2ZW50XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJkb25lXCI6IHtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaERhdGEgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBvdGhlciBldmVudCB0eXBlcyAoc3RhcnQsIHRleHQtc3RhcnQsIHRleHQtZW5kLCBldGMuKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHRleHQ6IGN1cnJlbnRUZXh0LCBmaW5pc2hEYXRhIH07XG4gICAgfSxcbiAgICBbXVxuICApO1xuICBjb25zdCBzZW5kTWVzc2FnZSA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjb250ZW50KSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlQ29udGVudCA9IGNvbnRlbnQgPz8gaW5wdXQ7XG4gICAgICBpZiAoIW1lc3NhZ2VDb250ZW50LnRyaW0oKSAmJiBtZXNzYWdlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbmV3TWVzc2FnZXMgPSBbLi4ubWVzc2FnZXNdO1xuICAgICAgICBpZiAobWVzc2FnZUNvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgY29uc3QgdXNlck1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlQ29udGVudC50cmltKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld01lc3NhZ2VzID0gWy4uLm5ld01lc3NhZ2VzLCB1c2VyTWVzc2FnZV07XG4gICAgICAgICAgc2V0TWVzc2FnZXMobmV3TWVzc2FnZXMpO1xuICAgICAgICAgIHNldElucHV0KFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2lzdGFudE1lc3NhZ2VJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZSA9IHtcbiAgICAgICAgICBpZDogYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICBwYXJ0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgc2V0TWVzc2FnZXMoWy4uLm5ld01lc3NhZ2VzLCBhc3Npc3RhbnRNZXNzYWdlXSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWdlbnQuc3RyZWFtKHtcbiAgICAgICAgICBtZXNzYWdlczogbmV3TWVzc2FnZXMsXG4gICAgICAgICAgc2FuZGJveCxcbiAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LnNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB0ZXh0LCBmaW5pc2hEYXRhIH0gPSBhd2FpdCBwYXJzZVN0cmVhbShyZXNwb25zZSwgYXNzaXN0YW50TWVzc2FnZUlkKTtcbiAgICAgICAgc2V0TWVzc2FnZXMoXG4gICAgICAgICAgKHByZXYpID0+IHByZXYubWFwKFxuICAgICAgICAgICAgKG0pID0+IG0uaWQgPT09IGFzc2lzdGFudE1lc3NhZ2VJZCA/IHsgLi4ubSwgY29udGVudDogdGV4dCB9IDogbVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG9uRmluaXNoICYmIGZpbmlzaERhdGEpIHtcbiAgICAgICAgICBvbkZpbmlzaCh7XG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBmaW5pc2hEYXRhLmZpbmlzaFJlYXNvbiB8fCBcInN0b3BcIixcbiAgICAgICAgICAgIHN0ZXBzOiBbXSxcbiAgICAgICAgICAgIHVzYWdlOiBmaW5pc2hEYXRhLnVzYWdlIHx8IHsgaW5wdXRUb2tlbnM6IDAsIG91dHB1dFRva2VuczogMCB9LFxuICAgICAgICAgICAgX2JpbGxpbmc6IGZpbmlzaERhdGEuX2JpbGxpbmcgfHwgeyBtb2RlbDogYWdlbnRNb2RlbCwgY3JlZGl0c0NoYXJnZWQ6IDAsIGNvc3RVU0Q6IDAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3IyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgICBpZiAoZXJyb3IyLm5hbWUgIT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgc2V0RXJyb3IoZXJyb3IyKTtcbiAgICAgICAgICBvbkVycm9yPy4oZXJyb3IyKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2FnZW50LCBhZ2VudE1vZGVsLCBtZXNzYWdlcywgaW5wdXQsIHNhbmRib3gsIGdlbmVyYXRlSWQsIHBhcnNlU3RyZWFtLCBvbkZpbmlzaCwgb25FcnJvcl1cbiAgKTtcbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2UpID0+IHtcbiAgICBzZXRNZXNzYWdlcygocHJldikgPT4gWy4uLnByZXYsIHsgLi4ubWVzc2FnZSwgaWQ6IG1lc3NhZ2UuaWQgfHwgZ2VuZXJhdGVJZCgpIH1dKTtcbiAgfSwgW2dlbmVyYXRlSWRdKTtcbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAoZSkgPT4ge1xuICAgICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICAgIH0sXG4gICAgW11cbiAgKTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGUpID0+IHtcbiAgICAgIGU/LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzZW5kTWVzc2FnZSgpO1xuICAgIH0sXG4gICAgW3NlbmRNZXNzYWdlXVxuICApO1xuICBjb25zdCBhZGRUb29sT3V0cHV0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgdG9vbENhbGxJZCwgdG9vbCwgb3V0cHV0IH0pID0+IHtcbiAgICAgIHNldE1lc3NhZ2VzKFxuICAgICAgICAocHJldikgPT4gcHJldi5tYXAoKG0pID0+IHtcbiAgICAgICAgICBpZiAobS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFtLnBhcnRzKSByZXR1cm4gbTtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUGFydHMgPSBtLnBhcnRzLm1hcChcbiAgICAgICAgICAgIChwKSA9PiBwLnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIgJiYgcC50b29sQ2FsbElkID09PSB0b29sQ2FsbElkICYmIHAudG9vbE5hbWUgPT09IHRvb2wgPyB7IC4uLnAsIHN0YXRlOiBcIm91dHB1dC1hdmFpbGFibGVcIiwgb3V0cHV0IH0gOiBwXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4geyAuLi5tLCBwYXJ0czogdXBkYXRlZFBhcnRzIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0sXG4gICAgW11cbiAgKTtcbiAgY29uc3QgY2xlYXJNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRNZXNzYWdlcyhpbml0aWFsTWVzc2FnZXMpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICB9LCBbaW5pdGlhbE1lc3NhZ2VzXSk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQ/LmFib3J0KCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGxldCBsYXN0VXNlckluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IG1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAobWVzc2FnZXNbaV0ucm9sZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgbGFzdFVzZXJJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVzZXJJbmRleCA9PT0gLTEpIHJldHVybjtcbiAgICBjb25zdCBtZXNzYWdlc1VwVG9MYXN0VXNlciA9IG1lc3NhZ2VzLnNsaWNlKDAsIGxhc3RVc2VySW5kZXggKyAxKTtcbiAgICBzZXRNZXNzYWdlcyhtZXNzYWdlc1VwVG9MYXN0VXNlcik7XG4gICAgYXdhaXQgc2VuZE1lc3NhZ2UoKTtcbiAgfSwgW21lc3NhZ2VzLCBzZW5kTWVzc2FnZV0pO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBzZW5kTWVzc2FnZSxcbiAgICBhcHBlbmQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGFkZFRvb2xPdXRwdXQsXG4gICAgY2xlYXJNZXNzYWdlcyxcbiAgICBzdG9wLFxuICAgIHJlbG9hZFxuICB9O1xufVxuZXhwb3J0IHtcbiAgQmxpbmtBdXRoUHJvdmlkZXIsXG4gIEJsaW5rUHJvdmlkZXIsXG4gIHVzZUFnZW50LFxuICB1c2VCbGluayxcbiAgdXNlQmxpbmtBdXRoLFxuICB1c2VCbGlua0NsaWVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blinkdotnew/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@blinkdotnew/sdk/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@blinkdotnew/sdk/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: () => (/* binding */ Agent),\n/* harmony export */   AsyncStorageAdapter: () => (/* binding */ AsyncStorageAdapter),\n/* harmony export */   BlinkAIImpl: () => (/* binding */ BlinkAIImpl),\n/* harmony export */   BlinkAnalyticsImpl: () => (/* binding */ BlinkAnalyticsImpl),\n/* harmony export */   BlinkConnectorsImpl: () => (/* binding */ BlinkConnectorsImpl),\n/* harmony export */   BlinkDataImpl: () => (/* binding */ BlinkDataImpl),\n/* harmony export */   BlinkDatabase: () => (/* binding */ BlinkDatabase),\n/* harmony export */   BlinkRAGImpl: () => (/* binding */ BlinkRAGImpl),\n/* harmony export */   BlinkRealtimeChannel: () => (/* binding */ BlinkRealtimeChannel),\n/* harmony export */   BlinkRealtimeImpl: () => (/* binding */ BlinkRealtimeImpl),\n/* harmony export */   BlinkSandboxImpl: () => (/* binding */ BlinkSandboxImpl),\n/* harmony export */   BlinkStorageImpl: () => (/* binding */ BlinkStorageImpl),\n/* harmony export */   BlinkTable: () => (/* binding */ BlinkTable),\n/* harmony export */   NoOpStorageAdapter: () => (/* binding */ NoOpStorageAdapter),\n/* harmony export */   SANDBOX_TEMPLATES: () => (/* binding */ SANDBOX_TEMPLATES),\n/* harmony export */   SandboxConnectionError: () => (/* binding */ SandboxConnectionError),\n/* harmony export */   WebStorageAdapter: () => (/* binding */ WebStorageAdapter),\n/* harmony export */   coreTools: () => (/* binding */ coreTools),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   dbDelete: () => (/* binding */ dbDelete),\n/* harmony export */   dbGet: () => (/* binding */ dbGet),\n/* harmony export */   dbInsert: () => (/* binding */ dbInsert),\n/* harmony export */   dbList: () => (/* binding */ dbList),\n/* harmony export */   dbTools: () => (/* binding */ dbTools),\n/* harmony export */   dbUpdate: () => (/* binding */ dbUpdate),\n/* harmony export */   editImage: () => (/* binding */ editImage),\n/* harmony export */   fetchUrl: () => (/* binding */ fetchUrl),\n/* harmony export */   generateImage: () => (/* binding */ generateImage),\n/* harmony export */   generateVideo: () => (/* binding */ generateVideo),\n/* harmony export */   getDefaultClient: () => (/* binding */ getDefaultClient),\n/* harmony export */   getDefaultStorageAdapter: () => (/* binding */ getDefaultStorageAdapter),\n/* harmony export */   getHost: () => (/* binding */ getHost),\n/* harmony export */   globFileSearch: () => (/* binding */ globFileSearch),\n/* harmony export */   grep: () => (/* binding */ grep),\n/* harmony export */   imageToVideo: () => (/* binding */ imageToVideo),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isServer: () => (/* binding */ isServer),\n/* harmony export */   isWeb: () => (/* binding */ isWeb),\n/* harmony export */   listDir: () => (/* binding */ listDir),\n/* harmony export */   mediaTools: () => (/* binding */ mediaTools),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   ragSearch: () => (/* binding */ ragSearch),\n/* harmony export */   ragTools: () => (/* binding */ ragTools),\n/* harmony export */   readFile: () => (/* binding */ readFile),\n/* harmony export */   runCode: () => (/* binding */ runCode),\n/* harmony export */   runTerminalCmd: () => (/* binding */ runTerminalCmd),\n/* harmony export */   sandboxTools: () => (/* binding */ sandboxTools),\n/* harmony export */   searchReplace: () => (/* binding */ searchReplace),\n/* harmony export */   serializeTools: () => (/* binding */ serializeTools),\n/* harmony export */   stepCountIs: () => (/* binding */ stepCountIs),\n/* harmony export */   storageCopy: () => (/* binding */ storageCopy),\n/* harmony export */   storageDelete: () => (/* binding */ storageDelete),\n/* harmony export */   storageDownload: () => (/* binding */ storageDownload),\n/* harmony export */   storageList: () => (/* binding */ storageList),\n/* harmony export */   storageMove: () => (/* binding */ storageMove),\n/* harmony export */   storagePublicUrl: () => (/* binding */ storagePublicUrl),\n/* harmony export */   storageTools: () => (/* binding */ storageTools),\n/* harmony export */   storageUpload: () => (/* binding */ storageUpload),\n/* harmony export */   webSearch: () => (/* binding */ webSearch),\n/* harmony export */   writeFile: () => (/* binding */ writeFile)\n/* harmony export */ });\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// ../core/src/platform.ts\nfunction detectPlatform() {\n  if (typeof Deno !== \"undefined\") {\n    return \"deno\";\n  }\n  if (typeof process !== \"undefined\" && process.versions?.node) {\n    if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n      return \"react-native\";\n    }\n    return \"node\";\n  }\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return \"react-native\";\n  }\n  if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    return \"web\";\n  }\n  return \"node\";\n}\nvar platform = detectPlatform();\nvar isWeb = platform === \"web\";\nvar isReactNative = platform === \"react-native\";\nvar isNode = platform === \"node\";\nvar isDeno = platform === \"deno\";\nvar isBrowser = isWeb || isReactNative;\nvar isServer = isNode || isDeno;\n\n// ../core/src/storage-adapter.ts\nvar WebStorageAdapter = class {\n  getItem(key) {\n    try {\n      if (typeof localStorage === \"undefined\") return null;\n      return localStorage.getItem(key);\n    } catch (error) {\n      console.warn(\"Failed to get item from localStorage:\", error);\n      return null;\n    }\n  }\n  setItem(key, value) {\n    try {\n      if (typeof localStorage === \"undefined\") return;\n      localStorage.setItem(key, value);\n    } catch (error) {\n      console.warn(\"Failed to set item in localStorage:\", error);\n    }\n  }\n  removeItem(key) {\n    try {\n      if (typeof localStorage === \"undefined\") return;\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.warn(\"Failed to remove item from localStorage:\", error);\n    }\n  }\n  clear() {\n    try {\n      if (typeof localStorage === \"undefined\") return;\n      localStorage.clear();\n    } catch (error) {\n      console.warn(\"Failed to clear localStorage:\", error);\n    }\n  }\n};\nvar AsyncStorageAdapter = class {\n  constructor(asyncStorage) {\n    this.asyncStorage = asyncStorage;\n    if (!asyncStorage) {\n      throw new Error(\"AsyncStorage instance is required\");\n    }\n  }\n  async getItem(key) {\n    try {\n      return await this.asyncStorage.getItem(key);\n    } catch (error) {\n      console.warn(\"Failed to get item from AsyncStorage:\", error);\n      return null;\n    }\n  }\n  async setItem(key, value) {\n    try {\n      await this.asyncStorage.setItem(key, value);\n    } catch (error) {\n      console.warn(\"Failed to set item in AsyncStorage:\", error);\n    }\n  }\n  async removeItem(key) {\n    try {\n      await this.asyncStorage.removeItem(key);\n    } catch (error) {\n      console.warn(\"Failed to remove item from AsyncStorage:\", error);\n    }\n  }\n  async clear() {\n    try {\n      await this.asyncStorage.clear();\n    } catch (error) {\n      console.warn(\"Failed to clear AsyncStorage:\", error);\n    }\n  }\n};\nvar NoOpStorageAdapter = class {\n  getItem(_key) {\n    return null;\n  }\n  setItem(_key, _value) {\n  }\n  removeItem(_key) {\n  }\n  clear() {\n  }\n};\nfunction getDefaultStorageAdapter() {\n  if (isDeno) {\n    return new NoOpStorageAdapter();\n  }\n  if (typeof window !== \"undefined\" && typeof localStorage !== \"undefined\") {\n    try {\n      localStorage.setItem(\"__test__\", \"test\");\n      localStorage.removeItem(\"__test__\");\n      return new WebStorageAdapter();\n    } catch {\n    }\n  }\n  return new NoOpStorageAdapter();\n}\n\n// ../core/src/types.ts\nvar BlinkError = class extends Error {\n  constructor(message, code, status, details) {\n    super(message);\n    this.code = code;\n    this.status = status;\n    this.details = details;\n    this.name = \"BlinkError\";\n  }\n};\nvar BlinkAuthError = class extends BlinkError {\n  code;\n  retryable;\n  userMessage;\n  constructor(code, message, userMessage, details) {\n    super(message, code, 401, details);\n    this.name = \"BlinkAuthError\";\n    this.code = code;\n    this.retryable = [\"NETWORK_ERROR\", \"RATE_LIMITED\"].includes(code);\n    this.userMessage = userMessage || this.getDefaultUserMessage(code);\n  }\n  getDefaultUserMessage(code) {\n    switch (code) {\n      case \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */:\n        return \"Invalid email or password. Please try again.\";\n      case \"EMAIL_NOT_VERIFIED\" /* EMAIL_NOT_VERIFIED */:\n        return \"Please verify your email address before signing in.\";\n      case \"POPUP_CANCELED\" /* POPUP_CANCELED */:\n        return \"Sign-in was canceled. Please try again.\";\n      case \"NETWORK_ERROR\" /* NETWORK_ERROR */:\n        return \"Network error. Please check your connection and try again.\";\n      case \"RATE_LIMITED\" /* RATE_LIMITED */:\n        return \"Too many attempts. Please wait a moment and try again.\";\n      case \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */:\n        return \"Authentication timed out. Please try again.\";\n      case \"REDIRECT_FAILED\" /* REDIRECT_FAILED */:\n        return \"Redirect failed. Please try again.\";\n      case \"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */:\n        return \"Session expired. Please sign in again.\";\n      case \"USER_NOT_FOUND\" /* USER_NOT_FOUND */:\n        return \"User not found. Please check your email and try again.\";\n      case \"EMAIL_ALREADY_EXISTS\" /* EMAIL_ALREADY_EXISTS */:\n        return \"An account with this email already exists.\";\n      case \"WEAK_PASSWORD\" /* WEAK_PASSWORD */:\n        return \"Password is too weak. Please choose a stronger password.\";\n      case \"INVALID_EMAIL\" /* INVALID_EMAIL */:\n        return \"Please enter a valid email address.\";\n      case \"MAGIC_LINK_EXPIRED\" /* MAGIC_LINK_EXPIRED */:\n        return \"Magic link has expired. Please request a new one.\";\n      case \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */:\n        return \"Verification failed. Please try again.\";\n      default:\n        return \"Authentication error. Please try again.\";\n    }\n  }\n};\nvar BlinkNetworkError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"NETWORK_ERROR\", status, details);\n    this.name = \"BlinkNetworkError\";\n  }\n};\nvar BlinkValidationError = class extends BlinkError {\n  constructor(message, details) {\n    super(message, \"VALIDATION_ERROR\", 400, details);\n    this.name = \"BlinkValidationError\";\n  }\n};\nvar BlinkStorageError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"STORAGE_ERROR\", status, details);\n    this.name = \"BlinkStorageError\";\n  }\n};\nvar BlinkAIError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"AI_ERROR\", status, details);\n    this.name = \"BlinkAIError\";\n  }\n};\nvar BlinkDataError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"DATA_ERROR\", status, details);\n    this.name = \"BlinkDataError\";\n  }\n};\nvar BlinkRealtimeError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"REALTIME_ERROR\", status, details);\n    this.name = \"BlinkRealtimeError\";\n  }\n};\nvar BlinkNotificationsError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"NOTIFICATIONS_ERROR\", status, details);\n    this.name = \"BlinkNotificationsError\";\n  }\n};\n\n// ../core/src/query-builder.ts\nfunction camelToSnake(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction convertFilterKeysToSnakeCase(condition) {\n  if (!condition) return condition;\n  if (\"AND\" in condition) {\n    return {\n      AND: condition.AND?.map(convertFilterKeysToSnakeCase)\n    };\n  }\n  if (\"OR\" in condition) {\n    return {\n      OR: condition.OR?.map(convertFilterKeysToSnakeCase)\n    };\n  }\n  const converted = {};\n  for (const [field, value] of Object.entries(condition)) {\n    const snakeField = camelToSnake(field);\n    converted[snakeField] = value;\n  }\n  return converted;\n}\nfunction buildFilterQuery(condition) {\n  if (!condition) return \"\";\n  if (\"AND\" in condition) {\n    const andConditions = condition.AND?.map(buildFilterQuery).filter(Boolean) || [];\n    return andConditions.length > 0 ? `and=(${andConditions.join(\",\")})` : \"\";\n  }\n  if (\"OR\" in condition) {\n    const orConditions = condition.OR?.map(buildFilterQuery).filter(Boolean) || [];\n    return orConditions.length > 0 ? `or=(${orConditions.join(\",\")})` : \"\";\n  }\n  const params = [];\n  for (const [field, value] of Object.entries(condition)) {\n    if (value === void 0 || value === null) continue;\n    if (typeof value === \"object\" && !Array.isArray(value)) {\n      for (const [operator, operatorValue] of Object.entries(value)) {\n        const param = buildOperatorQuery(field, operator, operatorValue);\n        if (param) params.push(param);\n      }\n    } else {\n      params.push(`${field}=eq.${encodeQueryValue(value)}`);\n    }\n  }\n  return params.join(\"&\");\n}\nfunction buildOperatorQuery(field, operator, value) {\n  switch (operator) {\n    case \"eq\":\n      return `${field}=eq.${encodeQueryValue(value)}`;\n    case \"neq\":\n      return `${field}=neq.${encodeQueryValue(value)}`;\n    case \"gt\":\n      return `${field}=gt.${encodeQueryValue(value)}`;\n    case \"gte\":\n      return `${field}=gte.${encodeQueryValue(value)}`;\n    case \"lt\":\n      return `${field}=lt.${encodeQueryValue(value)}`;\n    case \"lte\":\n      return `${field}=lte.${encodeQueryValue(value)}`;\n    case \"like\":\n      return `${field}=like.${encodeQueryValue(value)}`;\n    case \"ilike\":\n      return `${field}=ilike.${encodeQueryValue(value)}`;\n    case \"is\":\n      return `${field}=is.${value === null ? \"null\" : encodeQueryValue(value)}`;\n    case \"not\":\n      return `${field}=not.${encodeQueryValue(value)}`;\n    case \"in\":\n      if (Array.isArray(value)) {\n        const values = value.map(encodeQueryValue).join(\",\");\n        return `${field}=in.(${values})`;\n      }\n      return \"\";\n    case \"not_in\":\n      if (Array.isArray(value)) {\n        const values = value.map(encodeQueryValue).join(\",\");\n        return `${field}=not.in.(${values})`;\n      }\n      return \"\";\n    default:\n      return \"\";\n  }\n}\nfunction encodeQueryValue(value) {\n  if (value === null) return \"null\";\n  if (typeof value === \"boolean\") {\n    return value ? \"1\" : \"0\";\n  }\n  if (typeof value === \"number\") return value.toString();\n  return encodeURIComponent(String(value));\n}\nfunction buildQuery(options = {}) {\n  const params = {};\n  if (options.select && options.select.length > 0) {\n    const snakeFields = options.select.map(camelToSnake);\n    params.select = snakeFields.join(\",\");\n  } else {\n    params.select = \"*\";\n  }\n  if (options.where) {\n    const convertedWhere = convertFilterKeysToSnakeCase(options.where);\n    const filterQuery = buildFilterQuery(convertedWhere);\n    if (filterQuery) {\n      const filterParams = filterQuery.split(\"&\");\n      for (const param of filterParams) {\n        const [key, value] = param.split(\"=\", 2);\n        if (key && value) {\n          params[key] = value;\n        }\n      }\n    }\n  }\n  if (options.orderBy) {\n    if (typeof options.orderBy === \"string\") {\n      params.order = options.orderBy;\n    } else {\n      const orderClauses = Object.entries(options.orderBy).map(([field, direction]) => `${camelToSnake(field)}.${direction}`);\n      params.order = orderClauses.join(\",\");\n    }\n  }\n  if (options.limit !== void 0) {\n    params.limit = options.limit.toString();\n  }\n  if (options.offset !== void 0) {\n    params.offset = options.offset.toString();\n  }\n  if (options.cursor) {\n    params.cursor = options.cursor;\n  }\n  return params;\n}\n\n// ../core/src/http-client.ts\nfunction camelToSnake2(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction snakeToCamel(str) {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\nfunction convertKeysToSnakeCase(obj) {\n  if (obj === null || obj === void 0) return obj;\n  if (typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.map(convertKeysToSnakeCase);\n  const converted = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const snakeKey = camelToSnake2(key);\n    converted[snakeKey] = convertKeysToSnakeCase(value);\n  }\n  return converted;\n}\nfunction convertKeysToCamelCase(obj) {\n  if (obj === null || obj === void 0) return obj;\n  if (typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.map(convertKeysToCamelCase);\n  const converted = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const camelKey = snakeToCamel(key);\n    converted[camelKey] = convertKeysToCamelCase(value);\n  }\n  return converted;\n}\nvar HttpClient = class {\n  authUrl = \"https://blink.new\";\n  coreUrl = \"https://core.blink.new\";\n  projectId;\n  publishableKey;\n  secretKey;\n  // Permanent, non-expiring key (like Stripe's sk_live_...)\n  getToken;\n  getValidToken;\n  constructor(config, getToken, getValidToken) {\n    this.projectId = config.projectId;\n    this.publishableKey = config.publishableKey;\n    this.secretKey = config.secretKey || config.serviceToken;\n    this.getToken = getToken;\n    this.getValidToken = getValidToken;\n  }\n  shouldAttachPublishableKey(path, method) {\n    if (method !== \"GET\" && method !== \"POST\") return false;\n    if (path.includes(\"/api/analytics/\")) return true;\n    if (path.includes(\"/api/storage/\")) return true;\n    if (path.includes(\"/api/db/\") && path.includes(\"/rest/v1/\")) return method === \"GET\";\n    return false;\n  }\n  shouldSkipSecretKey(url) {\n    try {\n      const parsed = new URL(url);\n      return parsed.hostname.endsWith(\".functions.blink.new\");\n    } catch {\n      return false;\n    }\n  }\n  getAuthorizationHeader(url, token) {\n    if (this.secretKey && !this.shouldSkipSecretKey(url)) {\n      return `Bearer ${this.secretKey}`;\n    }\n    if (token) {\n      return `Bearer ${token}`;\n    }\n    return null;\n  }\n  /**\n   * Make an authenticated request to the Blink API\n   */\n  async request(path, options = {}) {\n    const url = this.buildUrl(path, options.searchParams);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const method = options.method || \"GET\";\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      ...options.headers\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) {\n      headers.Authorization = auth;\n    } else if (this.publishableKey && !headers[\"x-blink-publishable-key\"] && this.shouldAttachPublishableKey(path, method)) {\n      headers[\"x-blink-publishable-key\"] = this.publishableKey;\n    }\n    const requestInit = {\n      method,\n      headers,\n      signal: options.signal\n    };\n    if (options.body && method !== \"GET\") {\n      requestInit.body = typeof options.body === \"string\" ? options.body : JSON.stringify(options.body);\n    }\n    try {\n      const response = await fetch(url, requestInit);\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      const data = await this.parseResponse(response);\n      return {\n        data,\n        status: response.status,\n        headers: response.headers\n      };\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Network request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * GET request\n   */\n  async get(path, searchParams) {\n    return this.request(path, { method: \"GET\", searchParams });\n  }\n  /**\n   * POST request\n   */\n  async post(path, body, headers) {\n    return this.request(path, { method: \"POST\", body, headers });\n  }\n  /**\n   * PATCH request\n   */\n  async patch(path, body, headers) {\n    return this.request(path, { method: \"PATCH\", body, headers });\n  }\n  /**\n   * DELETE request\n   */\n  async delete(path, searchParams) {\n    return this.request(path, { method: \"DELETE\", searchParams });\n  }\n  /**\n   * Database-specific requests\n   */\n  // Table operations (PostgREST-compatible)\n  async dbGet(table, searchParams) {\n    const response = await this.get(`/api/db/${this.projectId}/rest/v1/${table}`, searchParams);\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbPost(table, body, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const convertedBody = convertKeysToSnakeCase(body);\n    const response = await this.post(`/api/db/${this.projectId}/rest/v1/${table}`, convertedBody, headers);\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbPatch(table, body, searchParams, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const convertedBody = convertKeysToSnakeCase(body);\n    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {\n      method: \"PATCH\",\n      body: convertedBody,\n      headers,\n      searchParams\n    });\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbDelete(table, searchParams, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {\n      method: \"DELETE\",\n      headers,\n      searchParams\n    });\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  // Raw SQL operations\n  async dbSql(query, params) {\n    const response = await this.post(`/api/db/${this.projectId}/sql`, { query, params });\n    const convertedData = {\n      ...response.data,\n      rows: convertKeysToCamelCase(response.data.rows)\n    };\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  // Batch SQL operations\n  async dbBatch(statements, mode = \"write\") {\n    const response = await this.post(`/api/db/${this.projectId}/batch`, { statements, mode });\n    const convertedData = {\n      ...response.data,\n      results: response.data.results.map((result) => ({\n        ...result,\n        rows: convertKeysToCamelCase(result.rows)\n      }))\n    };\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  /**\n   * Upload file with progress tracking\n   */\n  async uploadFile(path, file, filePath, options = {}) {\n    const url = this.buildUrl(path);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const formData = new FormData();\n    if (file instanceof File) {\n      formData.append(\"file\", file);\n    } else if (file instanceof Blob) {\n      const blobWithType = options.contentType ? new Blob([file], { type: options.contentType }) : file;\n      formData.append(\"file\", blobWithType);\n    } else if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n      const blob = new Blob([file], { type: options.contentType || \"application/octet-stream\" });\n      formData.append(\"file\", blob);\n    } else {\n      throw new BlinkValidationError(\"Unsupported file type\");\n    }\n    formData.append(\"path\", filePath);\n    const headers = {};\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) {\n      headers.Authorization = auth;\n    } else if (this.publishableKey && path.includes(\"/api/storage/\") && !headers[\"x-blink-publishable-key\"]) {\n      headers[\"x-blink-publishable-key\"] = this.publishableKey;\n    }\n    try {\n      if (typeof XMLHttpRequest !== \"undefined\" && options.onProgress) {\n        return this.uploadWithProgress(url, formData, headers, options.onProgress);\n      }\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: formData\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      const data = await this.parseResponse(response);\n      return {\n        data,\n        status: response.status,\n        headers: response.headers\n      };\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `File upload failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Upload with progress tracking using XMLHttpRequest\n   */\n  uploadWithProgress(url, formData, headers, onProgress) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          const percent = Math.round(event.loaded / event.total * 100);\n          onProgress(percent);\n        }\n      });\n      xhr.addEventListener(\"load\", async () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            const data = JSON.parse(xhr.responseText);\n            resolve({\n              data,\n              status: xhr.status,\n              headers: new Headers()\n              // XMLHttpRequest doesn't provide easy access to response headers\n            });\n          } catch (error) {\n            reject(new BlinkNetworkError(\"Failed to parse response\", xhr.status));\n          }\n        } else {\n          try {\n            const errorData = JSON.parse(xhr.responseText);\n            const message = errorData.error?.message || errorData.message || `HTTP ${xhr.status}`;\n            switch (xhr.status) {\n              case 401:\n                reject(new BlinkAuthError(message, errorData));\n                break;\n              case 400:\n                reject(new BlinkValidationError(message, errorData));\n                break;\n              default:\n                reject(new BlinkNetworkError(message, xhr.status, errorData));\n            }\n          } catch {\n            reject(new BlinkNetworkError(`HTTP ${xhr.status}`, xhr.status));\n          }\n        }\n      });\n      xhr.addEventListener(\"error\", () => {\n        reject(new BlinkNetworkError(\"Network error during file upload\"));\n      });\n      xhr.open(\"POST\", url);\n      Object.entries(headers).forEach(([key, value]) => {\n        xhr.setRequestHeader(key, value);\n      });\n      xhr.send(formData);\n    });\n  }\n  /**\n   * AI-specific requests\n   */\n  async aiText(prompt, options = {}) {\n    const { signal, ...body } = options;\n    const requestBody = { ...body };\n    if (prompt) {\n      requestBody.prompt = prompt;\n    }\n    return this.request(`/api/ai/${this.projectId}/text`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * Stream AI text generation - uses Vercel AI SDK's pipeUIMessageStreamToResponse (Data Stream Protocol)\n   */\n  async streamAiText(prompt, options = {}, onChunk) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/text`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const body = {\n      prompt,\n      stream: true,\n      ...options\n    };\n    const { signal: _signal, ...jsonBody } = body;\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(jsonBody),\n        signal: options.signal\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      if (!response.body) {\n        throw new BlinkNetworkError(\"No response body for streaming\");\n      }\n      return this.parseDataStreamProtocol(response.body, onChunk);\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Streaming request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  async aiObject(prompt, options = {}) {\n    const { signal, ...body } = options;\n    const requestBody = { ...body };\n    if (prompt) {\n      requestBody.prompt = prompt;\n    }\n    return this.request(`/api/ai/${this.projectId}/object`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * Stream AI object generation - uses Vercel AI SDK's pipeTextStreamToResponse\n   */\n  async streamAiObject(prompt, options = {}, onPartial) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/object`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const body = {\n      prompt,\n      stream: true,\n      ...options\n    };\n    const { signal: _signal2, ...jsonBody2 } = body;\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(jsonBody2),\n        signal: options.signal\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      if (!response.body) {\n        throw new BlinkNetworkError(\"No response body for streaming\");\n      }\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = \"\";\n      let latestObject = {};\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          const chunk = decoder.decode(value, { stream: true });\n          buffer += chunk;\n          try {\n            const parsed = JSON.parse(buffer);\n            latestObject = parsed;\n            if (onPartial) {\n              onPartial(parsed);\n            }\n          } catch {\n          }\n        }\n        if (buffer) {\n          try {\n            latestObject = JSON.parse(buffer);\n          } catch {\n          }\n        }\n        return { object: latestObject };\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Streaming request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  async aiImage(prompt, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/image`, {\n      method: \"POST\",\n      body: {\n        prompt,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiSpeech(text, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/speech`, {\n      method: \"POST\",\n      body: {\n        text,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiTranscribe(audio, options = {}) {\n    const { signal, ...body } = options;\n    let payloadAudio;\n    if (typeof audio === \"string\" || Array.isArray(audio)) {\n      payloadAudio = audio;\n    } else if (audio instanceof Uint8Array) {\n      payloadAudio = Array.from(audio);\n    } else if (audio instanceof ArrayBuffer) {\n      payloadAudio = Array.from(new Uint8Array(audio));\n    } else if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(audio)) {\n      payloadAudio = Array.from(new Uint8Array(audio));\n    } else {\n      throw new BlinkValidationError(\"Unsupported audio input type\");\n    }\n    return this.request(`/api/ai/${this.projectId}/transcribe`, {\n      method: \"POST\",\n      body: {\n        audio: payloadAudio,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiVideo(prompt, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/video`, {\n      method: \"POST\",\n      body: {\n        prompt,\n        ...body\n      },\n      signal\n    });\n  }\n  /**\n   * AI Agent request (non-streaming)\n   * Returns JSON response with text, steps, usage, and billing\n   */\n  async aiAgent(requestBody, signal) {\n    return this.request(`/api/ai/${this.projectId}/agent`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * AI Agent streaming request\n   * Returns raw Response for SSE streaming (compatible with AI SDK useChat)\n   */\n  async aiAgentStream(requestBody, signal) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/agent`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(requestBody),\n      signal\n    });\n    if (!response.ok) {\n      await this.handleErrorResponse(response);\n    }\n    return response;\n  }\n  /**\n   * RAG AI Search streaming request\n   * Returns raw Response for SSE streaming\n   */\n  async ragAiSearchStream(body, signal) {\n    const url = this.buildUrl(`/api/rag/${this.projectId}/ai-search`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    const auth = this.getAuthorizationHeader(url, token);\n    if (auth) headers.Authorization = auth;\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body),\n      signal\n    });\n    if (!response.ok) {\n      await this.handleErrorResponse(response);\n    }\n    return response;\n  }\n  /**\n   * Data-specific requests\n   */\n  async dataExtractFromUrl(projectId, request) {\n    return this.request(`/api/data/${projectId}/extract-from-url`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataExtractFromBlob(projectId, file, chunking, chunkSize) {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    if (chunking !== void 0) {\n      formData.append(\"chunking\", String(chunking));\n    }\n    if (chunkSize !== void 0) {\n      formData.append(\"chunkSize\", String(chunkSize));\n    }\n    return this.request(`/api/data/${projectId}/extract-from-blob`, {\n      method: \"POST\",\n      body: formData\n    });\n  }\n  async dataScrape(projectId, request) {\n    return this.request(`/api/data/${projectId}/scrape`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataScreenshot(projectId, request) {\n    return this.request(`/api/data/${projectId}/screenshot`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataFetch(projectId, request) {\n    return this.post(`/api/data/${projectId}/fetch`, request);\n  }\n  async dataSearch(projectId, request) {\n    return this.post(`/api/data/${projectId}/search`, request);\n  }\n  /**\n   * Connector requests\n   */\n  formatProviderForPath(provider) {\n    return provider.replace(\"_\", \"-\");\n  }\n  async connectorStatus(provider) {\n    return this.request(`/api/connectors/${this.formatProviderForPath(provider)}/${this.projectId}/status`, {\n      method: \"GET\"\n    });\n  }\n  async connectorExecute(provider, request) {\n    const path = request.method.startsWith(\"/\") ? request.method : `/${request.method}`;\n    const url = `/api/connectors/${this.formatProviderForPath(provider)}/${this.projectId}${path}`;\n    const method = (request.http_method || \"GET\").toUpperCase();\n    if (method === \"GET\") {\n      return this.request(url, {\n        method: \"GET\",\n        searchParams: request.params\n      });\n    }\n    return this.request(url, {\n      method,\n      body: request.params || {}\n    });\n  }\n  async connectorSaveApiKey(provider, request) {\n    return this.request(`/api/connectors/${this.formatProviderForPath(provider)}/${this.projectId}/api-key`, {\n      method: \"POST\",\n      body: request\n    });\n  }\n  /**\n   * Realtime-specific requests\n   */\n  async realtimePublish(projectId, request) {\n    return this.post(`/api/realtime/${projectId}/publish`, request);\n  }\n  async realtimeGetPresence(projectId, channel) {\n    return this.get(`/api/realtime/${projectId}/presence`, { channel });\n  }\n  async realtimeGetMessages(projectId, options) {\n    const { channel, ...searchParams } = options;\n    return this.get(`/api/realtime/${projectId}/messages`, {\n      channel,\n      ...Object.fromEntries(\n        Object.entries(searchParams).filter(([k, v]) => v !== void 0).map(([k, v]) => [k, String(v)])\n      )\n    });\n  }\n  /**\n   * Private helper methods\n   */\n  buildUrl(path, searchParams) {\n    const baseUrl = path.includes(\"/api/auth/\") ? this.authUrl : this.coreUrl;\n    const url = new URL(path, baseUrl);\n    if (searchParams) {\n      Object.entries(searchParams).forEach(([key, value]) => {\n        url.searchParams.set(key, value);\n      });\n    }\n    return url.toString();\n  }\n  async parseResponse(response) {\n    const contentType = response.headers.get(\"content-type\");\n    if (contentType?.includes(\"application/json\")) {\n      return response.json();\n    }\n    if (contentType?.includes(\"text/\")) {\n      return response.text();\n    }\n    return response.blob();\n  }\n  async handleErrorResponse(response) {\n    let errorData;\n    try {\n      const contentType = response.headers.get(\"content-type\");\n      if (contentType?.includes(\"application/json\")) {\n        errorData = await response.json();\n      } else {\n        errorData = { message: await response.text() };\n      }\n    } catch {\n      errorData = { message: \"Unknown error occurred\" };\n    }\n    const message = errorData.error?.message || errorData.message || `HTTP ${response.status}`;\n    errorData.error?.code || errorData.code;\n    switch (response.status) {\n      case 401:\n        throw new BlinkAuthError(message, errorData);\n      case 400:\n        throw new BlinkValidationError(message, errorData);\n      default:\n        throw new BlinkNetworkError(message, response.status, errorData);\n    }\n  }\n  /**\n   * Parse Vercel AI SDK v5 Data Stream Protocol (Server-Sent Events)\n   * Supports all event types from the UI Message Stream protocol\n   */\n  async parseDataStreamProtocol(body, onChunk) {\n    const reader = body.getReader();\n    const decoder = new TextDecoder();\n    const finalResult = {\n      text: \"\",\n      toolCalls: [],\n      toolResults: [],\n      sources: [],\n      files: [],\n      reasoning: []\n    };\n    let buffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split(\"\\n\");\n        buffer = lines.pop() || \"\";\n        for (const line of lines) {\n          if (!line.trim()) continue;\n          if (line === \"[DONE]\") {\n            continue;\n          }\n          if (!line.startsWith(\"data: \")) continue;\n          try {\n            const jsonStr = line.slice(6);\n            const part = JSON.parse(jsonStr);\n            switch (part.type) {\n              case \"text-start\":\n                break;\n              case \"text-delta\":\n                if (part.delta) {\n                  finalResult.text += part.delta;\n                  if (onChunk) onChunk(part.delta);\n                }\n                if (part.textDelta) {\n                  finalResult.text += part.textDelta;\n                  if (onChunk) onChunk(part.textDelta);\n                }\n                break;\n              case \"text-end\":\n                break;\n              case \"tool-call\":\n                finalResult.toolCalls.push({\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  args: part.args\n                });\n                break;\n              case \"tool-result\":\n                finalResult.toolResults.push({\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  result: part.result\n                });\n                break;\n              case \"source-url\":\n                finalResult.sources.push({\n                  id: part.id,\n                  url: part.url,\n                  title: part.title\n                });\n                break;\n              case \"file\":\n                finalResult.files.push(part.file);\n                break;\n              case \"reasoning\":\n                finalResult.reasoning.push(part.content);\n                break;\n              case \"finish\":\n                finalResult.finishReason = part.finishReason;\n                finalResult.usage = part.usage;\n                if (part.response) finalResult.response = part.response;\n                break;\n              case \"error\":\n                finalResult.error = part.error;\n                throw new Error(part.error);\n              case \"data\":\n                if (!finalResult.customData) finalResult.customData = [];\n                finalResult.customData.push(part.value);\n                break;\n            }\n          } catch (e) {\n          }\n        }\n      }\n      return finalResult;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n};\n\n// src/utils/browser-env.ts\nfunction hasWindow() {\n  return typeof window !== \"undefined\";\n}\nfunction hasWindowLocation() {\n  return typeof window !== \"undefined\" && typeof window.location !== \"undefined\";\n}\nfunction hasDocument() {\n  return typeof document !== \"undefined\";\n}\nfunction isReactNative2() {\n  return typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\n}\nfunction getWindowLocation() {\n  if (!hasWindow()) return null;\n  try {\n    return window.location;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHref() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.href;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationOrigin() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.origin;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHostname() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.hostname;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationPathname() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.pathname;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationSearch() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.search;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHash() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.hash;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationProtocol() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.protocol;\n  } catch {\n    return null;\n  }\n}\nfunction getLocationHost() {\n  const loc = getWindowLocation();\n  if (!loc) return null;\n  try {\n    return loc.host;\n  } catch {\n    return null;\n  }\n}\nfunction constructFullUrl() {\n  if (!hasWindow()) return null;\n  const protocol = getLocationProtocol();\n  const host = getLocationHost();\n  const pathname = getLocationPathname();\n  const search = getLocationSearch();\n  const hash = getLocationHash();\n  if (!protocol || !host) return null;\n  return `${protocol}//${host}${pathname || \"\"}${search || \"\"}${hash || \"\"}`;\n}\nfunction getDocumentReferrer() {\n  if (!hasDocument()) return null;\n  try {\n    return document.referrer || null;\n  } catch {\n    return null;\n  }\n}\nfunction getWindowInnerWidth() {\n  if (!hasWindow()) return null;\n  try {\n    return window.innerWidth;\n  } catch {\n    return null;\n  }\n}\nfunction isIframe() {\n  if (!hasWindow()) return false;\n  try {\n    return window.self !== window.top;\n  } catch {\n    return true;\n  }\n}\nfunction getSessionStorage() {\n  if (!hasWindow()) return null;\n  try {\n    return window.sessionStorage;\n  } catch {\n    return null;\n  }\n}\n\n// src/auth.ts\nvar BlinkAuth = class {\n  config;\n  authConfig;\n  authState;\n  listeners = /* @__PURE__ */ new Set();\n  authUrl;\n  coreUrl;\n  parentWindowTokens = null;\n  isIframe = false;\n  initializationPromise = null;\n  isInitialized = false;\n  storage;\n  constructor(config) {\n    this.config = config;\n    if (!config.projectId) {\n      throw new Error(\"projectId is required for authentication\");\n    }\n    this.authConfig = {\n      mode: \"managed\",\n      // Default mode\n      authUrl: \"https://blink.new\",\n      coreUrl: \"https://core.blink.new\",\n      detectSessionInUrl: true,\n      // Default to true for web compatibility\n      ...config.auth\n    };\n    this.authUrl = this.authConfig.authUrl || \"https://blink.new\";\n    this.coreUrl = this.authConfig.coreUrl || \"https://core.blink.new\";\n    const hostname = getLocationHostname();\n    if (hostname && this.authUrl === \"https://blink.new\" && (hostname === \"localhost\" || hostname === \"127.0.0.1\")) {\n      console.warn(\"\\u26A0\\uFE0F Using default authUrl in development. Set auth.authUrl to your app origin for headless auth endpoints to work.\");\n    }\n    if (config.authRequired !== void 0 && !config.auth?.mode) {\n      this.authConfig.mode = config.authRequired ? \"managed\" : \"headless\";\n    }\n    this.authState = {\n      user: null,\n      tokens: null,\n      isAuthenticated: false,\n      isLoading: false\n    };\n    this.storage = config.auth?.storage || config.storage || getDefaultStorageAdapter();\n    if (isWeb) {\n      this.isIframe = isIframe();\n      this.setupParentWindowListener();\n      this.setupCrossTabSync();\n      this.initializationPromise = this.initialize();\n    } else {\n      this.isInitialized = true;\n    }\n  }\n  /**\n   * Generate project-scoped storage key\n   */\n  getStorageKey(suffix) {\n    return `blink_${suffix}_${this.config.projectId}`;\n  }\n  /**\n   * Migrate existing global tokens to project-scoped storage\n   * DISABLED: We don't migrate global blink_tokens anymore because:\n   * 1. Platform uses blink_tokens for platform auth (different user)\n   * 2. Migrating platform tokens would cause project to show wrong user\n   * 3. Projects should always authenticate fresh via their own flow\n   */\n  migrateExistingTokens() {\n  }\n  /**\n   * Wait for authentication initialization to complete\n   */\n  async waitForInitialization() {\n    if (this.isInitialized) return;\n    if (this.initializationPromise) {\n      await this.initializationPromise;\n    }\n  }\n  /**\n   * Setup listener for tokens from parent window\n   */\n  setupParentWindowListener() {\n    if (!isWeb || !this.isIframe || !hasWindow()) return;\n    window.addEventListener(\"message\", (event) => {\n      if (event.origin !== \"https://blink.new\" && event.origin !== \"http://localhost:3000\" && event.origin !== \"http://localhost:3001\") {\n        return;\n      }\n      if (event.data?.type === \"BLINK_AUTH_TOKENS\") {\n        console.log(\"\\u{1F4E5} Received auth tokens from parent window\");\n        const { tokens } = event.data;\n        if (tokens) {\n          this.parentWindowTokens = tokens;\n          this.setTokens(tokens, false).then(() => {\n            console.log(\"\\u2705 Tokens from parent window applied\");\n          }).catch((error) => {\n            console.error(\"Failed to apply parent window tokens:\", error);\n          });\n        }\n      }\n      if (event.data?.type === \"BLINK_AUTH_LOGOUT\") {\n        console.log(\"\\u{1F4E4} Received logout command from parent window\");\n        this.clearTokens();\n      }\n    });\n    if (hasWindow() && window.parent !== window) {\n      console.log(\"\\u{1F504} Requesting auth tokens from parent window\");\n      window.parent.postMessage({\n        type: \"BLINK_REQUEST_AUTH_TOKENS\",\n        projectId: this.config.projectId\n      }, \"*\");\n    }\n  }\n  /**\n   * Initialize authentication from stored tokens or URL fragments\n   */\n  async initialize() {\n    console.log(\"\\u{1F680} Initializing Blink Auth...\");\n    this.setLoading(true);\n    try {\n      this.migrateExistingTokens();\n      if (this.isIframe) {\n        console.log(\"\\u{1F50D} Detected iframe environment, waiting for parent tokens...\");\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        if (this.parentWindowTokens) {\n          console.log(\"\\u2705 Using tokens from parent window\");\n          await this.setTokens(this.parentWindowTokens, false);\n          return;\n        }\n      }\n      if (this.authConfig.detectSessionInUrl !== false) {\n        const tokensFromUrl = this.extractTokensFromUrl();\n        if (tokensFromUrl) {\n          console.log(\"\\u{1F4E5} Found tokens in URL, setting them...\");\n          await this.setTokens(tokensFromUrl, true);\n          this.clearUrlTokens();\n          console.log(\"\\u2705 Auth initialization complete (from URL)\");\n          return;\n        }\n      }\n      const storedTokens = await this.getStoredTokens();\n      if (storedTokens) {\n        console.log(\"\\u{1F4BE} Found stored tokens, validating...\", {\n          hasAccessToken: !!storedTokens.access_token,\n          hasRefreshToken: !!storedTokens.refresh_token,\n          issuedAt: storedTokens.issued_at,\n          expiresIn: storedTokens.expires_in,\n          refreshExpiresIn: storedTokens.refresh_expires_in,\n          currentTime: Math.floor(Date.now() / 1e3)\n        });\n        this.authState.tokens = storedTokens;\n        console.log(\"\\u{1F527} Tokens set in auth state, refresh token available:\", !!this.authState.tokens?.refresh_token);\n        const isValid = await this.validateStoredTokens(storedTokens);\n        if (isValid) {\n          console.log(\"\\u2705 Auth initialization complete (from storage)\");\n          return;\n        } else {\n          console.log(\"\\u{1F504} Stored tokens invalid, clearing...\");\n          this.clearTokens();\n        }\n      }\n      console.log(\"\\u274C No tokens found\");\n      if (this.config.authRequired && hasWindowLocation()) {\n        console.log(\"\\u{1F504} Auth required, redirecting to auth page...\");\n        this.redirectToAuth();\n      } else {\n        console.log(\"\\u26A0\\uFE0F Auth not required or no window.location, continuing without authentication\");\n      }\n    } finally {\n      this.setLoading(false);\n      this.isInitialized = true;\n    }\n  }\n  /**\n   * Redirect to Blink auth page\n   */\n  login(nextUrl) {\n    if (!hasWindowLocation()) {\n      console.warn(\"login() called in non-browser environment (no window.location available)\");\n      return;\n    }\n    let redirectUrl = nextUrl || this.authConfig.redirectUrl;\n    if (!redirectUrl) {\n      const href = getLocationHref();\n      if (href && href.startsWith(\"http\")) {\n        redirectUrl = href;\n      } else {\n        redirectUrl = constructFullUrl() || void 0;\n      }\n    }\n    if (redirectUrl) {\n      try {\n        const url = new URL(redirectUrl);\n        url.searchParams.delete(\"redirect_url\");\n        url.searchParams.delete(\"redirect\");\n        redirectUrl = url.toString();\n      } catch (e) {\n        console.warn(\"Failed to parse redirect URL:\", e);\n      }\n    }\n    const authUrl = new URL(\"/auth\", this.authUrl);\n    authUrl.searchParams.set(\"redirect_url\", redirectUrl || \"\");\n    if (this.config.projectId) {\n      authUrl.searchParams.set(\"project_id\", this.config.projectId);\n    }\n    window.location.href = authUrl.toString();\n  }\n  /**\n   * Logout and clear stored tokens\n   */\n  logout(redirectUrl) {\n    this.clearTokens();\n    if (redirectUrl && hasWindowLocation()) {\n      window.location.href = redirectUrl;\n    }\n  }\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated() {\n    return this.authState.isAuthenticated;\n  }\n  /**\n   * Get current user (sync)\n   */\n  currentUser() {\n    return this.authState.user;\n  }\n  /**\n   * Get current access token\n   */\n  getToken() {\n    return this.authState.tokens?.access_token || null;\n  }\n  /**\n   * Check if access token is expired based on timestamp\n   */\n  isAccessTokenExpired() {\n    const tokens = this.authState.tokens;\n    if (!tokens || !tokens.issued_at) {\n      return true;\n    }\n    const now = Math.floor(Date.now() / 1e3);\n    const expiresAt = tokens.issued_at + tokens.expires_in;\n    const bufferTime = 30;\n    return now >= expiresAt - bufferTime;\n  }\n  /**\n   * Check if refresh token is expired based on timestamp\n   */\n  isRefreshTokenExpired() {\n    const tokens = this.authState.tokens;\n    if (!tokens || !tokens.refresh_token || !tokens.issued_at || !tokens.refresh_expires_in) {\n      return true;\n    }\n    const now = Math.floor(Date.now() / 1e3);\n    const expiresAt = tokens.issued_at + tokens.refresh_expires_in;\n    return now >= expiresAt;\n  }\n  /**\n   * Get a valid access token, refreshing if necessary\n   */\n  async getValidToken() {\n    const tokens = this.authState.tokens;\n    if (!tokens) {\n      return null;\n    }\n    if (!this.isAccessTokenExpired()) {\n      console.log(\"\\u2705 Access token is still valid\");\n      return tokens.access_token;\n    }\n    console.log(\"\\u23F0 Access token expired, attempting refresh...\");\n    if (this.isRefreshTokenExpired()) {\n      console.log(\"\\u274C Refresh token also expired, clearing tokens\");\n      this.clearTokens();\n      if (this.config.authRequired) {\n        this.redirectToAuth();\n      }\n      return null;\n    }\n    const refreshed = await this.refreshToken();\n    if (refreshed) {\n      console.log(\"\\u2705 Token refreshed successfully\");\n      return this.authState.tokens?.access_token || null;\n    } else {\n      console.log(\"\\u274C Token refresh failed\");\n      this.clearTokens();\n      if (this.config.authRequired) {\n        this.redirectToAuth();\n      }\n      return null;\n    }\n  }\n  /**\n   * Fetch current user profile from API\n   * Gracefully waits for auth initialization to complete before throwing errors\n   */\n  async me() {\n    await this.waitForInitialization();\n    if (this.authState.isAuthenticated && this.authState.user) {\n      return this.authState.user;\n    }\n    if (!this.authState.isAuthenticated) {\n      return new Promise((resolve, reject) => {\n        if (this.authState.user) {\n          resolve(this.authState.user);\n          return;\n        }\n        const timeout = setTimeout(() => {\n          unsubscribe();\n          reject(new BlinkAuthError(\"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */, \"Authentication timeout - no user available\"));\n        }, 5e3);\n        const unsubscribe = this.onAuthStateChanged((state) => {\n          if (state.user) {\n            clearTimeout(timeout);\n            unsubscribe();\n            resolve(state.user);\n          } else if (!state.isLoading && !state.isAuthenticated) {\n            clearTimeout(timeout);\n            unsubscribe();\n            reject(new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"Not authenticated\"));\n          }\n        });\n      });\n    }\n    let token = this.getToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${token}`\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          const refreshed = await this.refreshToken();\n          if (refreshed) {\n            token = this.getToken();\n            if (token) {\n              const retryResponse = await fetch(`${this.authUrl}/api/auth/me`, {\n                headers: {\n                  \"Authorization\": `Bearer ${token}`\n                }\n              });\n              if (retryResponse.ok) {\n                const retryData = await retryResponse.json();\n                const user2 = retryData.user;\n                this.updateAuthState({\n                  ...this.authState,\n                  user: user2\n                });\n                return user2;\n              }\n            }\n          }\n          this.clearTokens();\n          if (this.config.authRequired) {\n            this.redirectToAuth();\n          }\n        }\n        const errorData = await response.json().catch(() => ({}));\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || `Failed to fetch user: ${response.statusText}`);\n      }\n      const data = await response.json();\n      const user = data.user;\n      this.updateAuthState({\n        ...this.authState,\n        user\n      });\n      return user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign up with email and password (headless mode)\n   */\n  async signUp(data) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signUp is only available in headless mode\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signup`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          ...data,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Sign up failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign in with email and password (headless mode)\n   */\n  async signInWithEmail(email, password) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithEmail is only available in headless mode\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/email`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          password,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Sign in failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign in with Google (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * \n   * On React Native, requires `webBrowser` to be configured in client:\n   * ```typescript\n   * const blink = createClient({\n   *   auth: { mode: 'headless', webBrowser: WebBrowser }\n   * })\n   * await blink.auth.signInWithGoogle() // Works on both platforms!\n   * ```\n   */\n  async signInWithGoogle(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithGoogle is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"google\", options);\n  }\n  /**\n   * Sign in with GitHub (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * See signInWithGoogle() for setup instructions.\n   */\n  async signInWithGitHub(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithGitHub is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"github\", options);\n  }\n  /**\n   * Sign in with Apple (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * See signInWithGoogle() for setup instructions.\n   */\n  async signInWithApple(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithApple is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"apple\", options);\n  }\n  /**\n   * Sign in with Microsoft (headless mode)\n   * \n   * **Universal OAuth** - Works on both Web and React Native!\n   * See signInWithGoogle() for setup instructions.\n   */\n  async signInWithMicrosoft(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithMicrosoft is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"microsoft\", options);\n  }\n  /**\n   * Initiate OAuth for mobile without deep linking (expo-web-browser pattern)\n   * \n   * This method:\n   * 1. Generates a unique session ID\n   * 2. Returns OAuth URL with session parameter\n   * 3. App opens URL in expo-web-browser\n   * 4. App polls checkMobileOAuthSession() until complete\n   * \n   * @param provider - OAuth provider (google, github, apple, etc.)\n   * @param options - Optional metadata\n   * @returns Session ID and OAuth URL\n   * \n   * @example\n   * // React Native with expo-web-browser\n   * import * as WebBrowser from 'expo-web-browser';\n   * \n   * const { sessionId, authUrl } = await blink.auth.initiateMobileOAuth('google');\n   * \n   * // Open browser\n   * await WebBrowser.openAuthSessionAsync(authUrl);\n   * \n   * // Poll for completion\n   * const user = await blink.auth.pollMobileOAuthSession(sessionId);\n   * console.log('Authenticated:', user.email);\n   */\n  async initiateMobileOAuth(provider, options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\n        \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */,\n        \"initiateMobileOAuth is only available in headless mode\"\n      );\n    }\n    const sessionId = this.generateSessionId();\n    const authUrl = new URL(\"/auth\", this.authUrl);\n    authUrl.searchParams.set(\"provider\", provider);\n    authUrl.searchParams.set(\"project_id\", this.config.projectId);\n    authUrl.searchParams.set(\"mode\", \"mobile-session\");\n    authUrl.searchParams.set(\"session_id\", sessionId);\n    if (options?.metadata) {\n      authUrl.searchParams.set(\"metadata\", JSON.stringify(options.metadata));\n    }\n    return {\n      sessionId,\n      authUrl: authUrl.toString()\n    };\n  }\n  /**\n   * Check mobile OAuth session status (single check)\n   * \n   * @param sessionId - Session ID from initiateMobileOAuth\n   * @returns Tokens if session is complete, null if still pending\n   */\n  async checkMobileOAuthSession(sessionId) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/mobile-session/${sessionId}`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (response.status === 404 || response.status === 202) {\n        return null;\n      }\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to check OAuth session\"\n        );\n      }\n      const data = await response.json();\n      return {\n        access_token: data.access_token,\n        refresh_token: data.refresh_token,\n        token_type: data.token_type || \"Bearer\",\n        expires_in: data.expires_in || 3600,\n        refresh_expires_in: data.refresh_expires_in\n      };\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  /**\n   * Poll mobile OAuth session until complete (convenience method)\n   * \n   * @param sessionId - Session ID from initiateMobileOAuth\n   * @param options - Polling options\n   * @returns Authenticated user\n   * \n   * @example\n   * const { sessionId, authUrl } = await blink.auth.initiateMobileOAuth('google');\n   * await WebBrowser.openAuthSessionAsync(authUrl);\n   * const user = await blink.auth.pollMobileOAuthSession(sessionId, {\n   *   maxAttempts: 60,\n   *   intervalMs: 1000\n   * });\n   */\n  async pollMobileOAuthSession(sessionId, options) {\n    const maxAttempts = options?.maxAttempts || 60;\n    const intervalMs = options?.intervalMs || 1e3;\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      const tokens = await this.checkMobileOAuthSession(sessionId);\n      if (tokens) {\n        await this.setTokens(tokens, true);\n        return this.authState.user;\n      }\n      await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    }\n    throw new BlinkAuthError(\n      \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */,\n      \"Mobile OAuth session timed out\"\n    );\n  }\n  /**\n   * Sign in with OAuth provider using expo-web-browser (React Native)\n   * \n   * This is a convenience method that handles the entire flow:\n   * 1. Initiates mobile OAuth session\n   * 2. Returns auth URL to open in WebBrowser\n   * 3. Provides polling function to call after browser opens\n   * \n   * @param provider - OAuth provider\n   * @returns Object with authUrl and authenticate function\n   * \n   * @example\n   * import * as WebBrowser from 'expo-web-browser';\n   * \n   * const { authUrl, authenticate } = await blink.auth.signInWithProviderMobile('google');\n   * \n   * // Open browser\n   * await WebBrowser.openAuthSessionAsync(authUrl);\n   * \n   * // Wait for authentication\n   * const user = await authenticate();\n   */\n  async signInWithProviderMobile(provider, options) {\n    const { sessionId, authUrl } = await this.initiateMobileOAuth(provider, options);\n    return {\n      authUrl,\n      authenticate: () => this.pollMobileOAuthSession(sessionId, {\n        maxAttempts: 60,\n        intervalMs: 1e3\n      })\n    };\n  }\n  /**\n   * Universal OAuth flow using session-based authentication (internal)\n   * Works on ALL platforms: Web, iOS, Android\n   * Uses expo-web-browser to open auth URL and polls for completion\n   */\n  async signInWithProviderUniversal(provider, options) {\n    const webBrowser = this.authConfig.webBrowser;\n    if (!webBrowser) {\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"webBrowser module is required for universal OAuth flow\"\n      );\n    }\n    const { sessionId, authUrl } = await this.initiateMobileOAuth(provider, options);\n    console.log(\"\\u{1F510} Opening OAuth browser for\", provider);\n    const browserPromise = webBrowser.openAuthSessionAsync(authUrl);\n    const raceResult = await Promise.race([\n      browserPromise.then((result) => ({ closed: true, result })).catch((err) => ({ closed: true, error: err })),\n      new Promise(\n        (resolve) => setTimeout(() => resolve({ closed: false }), 5e3)\n      )\n    ]);\n    if (raceResult.closed) {\n      if (\"result\" in raceResult) {\n        console.log(\"\\u{1F510} Browser closed with result:\", raceResult.result.type);\n      } else {\n        console.log(\"\\u{1F510} Browser closed with error\");\n      }\n    } else {\n      console.log(\"\\u{1F510} Browser still open (new tab/stuck popup), starting to poll...\");\n    }\n    const user = await this.pollMobileOAuthSession(sessionId, {\n      maxAttempts: 120,\n      // 60 seconds (give user time to complete auth)\n      intervalMs: 500\n    });\n    console.log(\"\\u2705 OAuth completed successfully\");\n    return user;\n  }\n  /**\n   * Generic provider sign-in method (headless mode)\n   * \n   * **Universal OAuth** - Works seamlessly on both Web and React Native!\n   * \n   * When `webBrowser` is configured in the client, this method automatically\n   * uses the session-based OAuth flow that works on ALL platforms.\n   * \n   * **Universal Setup (configure once, works everywhere):**\n   * ```typescript\n   * import * as WebBrowser from 'expo-web-browser'\n   * import AsyncStorage from '@react-native-async-storage/async-storage'\n   * \n   * const blink = createClient({\n   *   projectId: 'your-project',\n   *   auth: {\n   *     mode: 'headless',\n   *     webBrowser: WebBrowser  // Pass the module here\n   *   },\n   *   storage: new AsyncStorageAdapter(AsyncStorage)\n   * })\n   * \n   * // Now this works on ALL platforms - no platform checks needed!\n   * const user = await blink.auth.signInWithGoogle()\n   * ```\n   * \n   * @param provider - OAuth provider (google, github, apple, etc.)\n   * @param options - Optional redirect URL and metadata\n   * @returns Promise that resolves with authenticated user\n   */\n  async signInWithProvider(provider, options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithProvider is only available in headless mode\");\n    }\n    if (this.authConfig.webBrowser) {\n      return this.signInWithProviderUniversal(provider, options);\n    }\n    if (isReactNative2()) {\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        'React Native OAuth requires webBrowser in config!\\n\\nimport * as WebBrowser from \"expo-web-browser\";\\n\\nconst blink = createClient({\\n  projectId: \"your-project\",\\n  auth: {\\n    mode: \"headless\",\\n    webBrowser: WebBrowser\\n  }\\n})\\n\\nawait blink.auth.signInWithGoogle() // Works on all platforms!'\n      );\n    }\n    if (!hasWindow()) {\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, \"signInWithProvider requires a browser environment\");\n    }\n    const shouldPreferRedirect = isWeb && this.isIframe || typeof window !== \"undefined\" && window.crossOriginIsolated === true;\n    const state = this.generateState();\n    try {\n      const sessionStorage = getSessionStorage();\n      if (sessionStorage) {\n        sessionStorage.setItem(\"blink_oauth_state\", state);\n      }\n    } catch {\n    }\n    const redirectUrl = options?.redirectUrl || getLocationOrigin() || \"\";\n    const buildAuthUrl = (mode) => {\n      const url = new URL(\"/auth\", this.authUrl);\n      url.searchParams.set(\"provider\", provider);\n      url.searchParams.set(\"project_id\", this.config.projectId);\n      url.searchParams.set(\"state\", state);\n      url.searchParams.set(\"mode\", mode);\n      url.searchParams.set(\"redirect_url\", redirectUrl);\n      url.searchParams.set(\"opener_origin\", getLocationOrigin() || \"\");\n      return url;\n    };\n    if (shouldPreferRedirect) {\n      window.location.href = buildAuthUrl(\"redirect\").toString();\n      return new Promise(() => {\n      });\n    }\n    return new Promise((resolve, reject) => {\n      const popupUrl = buildAuthUrl(\"popup\");\n      const popup = window.open(\n        popupUrl.toString(),\n        \"blink-auth\",\n        \"width=500,height=600,scrollbars=yes,resizable=yes\"\n      );\n      if (!popup) {\n        reject(new BlinkAuthError(\"POPUP_CANCELED\" /* POPUP_CANCELED */, \"Popup was blocked\"));\n        return;\n      }\n      let timeoutId;\n      let closedIntervalId;\n      let cleanedUp = false;\n      const cleanup = () => {\n        if (cleanedUp) return;\n        cleanedUp = true;\n        clearTimeout(timeoutId);\n        if (closedIntervalId) clearInterval(closedIntervalId);\n        window.removeEventListener(\"message\", messageListener);\n      };\n      const messageListener = (event) => {\n        let allowed = false;\n        try {\n          const authOrigin = new URL(this.authUrl).origin;\n          if (event.origin === authOrigin) allowed = true;\n        } catch {\n        }\n        if (event.origin === \"http://localhost:3000\" || event.origin === \"http://localhost:3001\") allowed = true;\n        if (!allowed) return;\n        if (event.data?.type === \"BLINK_AUTH_TOKENS\") {\n          const { access_token, refresh_token, token_type, expires_in, refresh_expires_in, projectId, state: returnedState } = event.data;\n          try {\n            const sessionStorage = getSessionStorage();\n            const expected = sessionStorage?.getItem(\"blink_oauth_state\");\n            if (returnedState && expected && returnedState !== expected) {\n              reject(new BlinkAuthError(\"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */, \"State mismatch\"));\n              clearTimeout(timeoutId);\n              window.removeEventListener(\"message\", messageListener);\n              popup.close();\n              return;\n            }\n          } catch {\n          }\n          if (projectId !== this.config.projectId) {\n            reject(new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"Project ID mismatch\"));\n            return;\n          }\n          this.setTokens({\n            access_token,\n            refresh_token,\n            token_type,\n            expires_in,\n            refresh_expires_in\n          }, true).then(() => {\n            resolve(this.authState.user);\n          }).catch(reject);\n          cleanup();\n          popup.close();\n        } else if (event.data?.type === \"BLINK_AUTH_ERROR\") {\n          const errorCode = this.mapErrorCodeFromResponse(event.data.code);\n          reject(new BlinkAuthError(errorCode, event.data.message || \"Authentication failed\"));\n          cleanup();\n          popup.close();\n        }\n      };\n      if (popup.opener === null) {\n        try {\n          popup.close();\n        } catch {\n        }\n        cleanup();\n        window.location.href = buildAuthUrl(\"redirect\").toString();\n        return;\n      }\n      timeoutId = setTimeout(() => {\n        cleanup();\n        if (!popup.closed) {\n          popup.close();\n        }\n        reject(new BlinkAuthError(\"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */, \"Authentication timed out\"));\n      }, 3e5);\n      closedIntervalId = setInterval(() => {\n        if (popup.closed) {\n          cleanup();\n          reject(new BlinkAuthError(\"POPUP_CANCELED\" /* POPUP_CANCELED */, \"Authentication was canceled\"));\n        }\n      }, 1e3);\n      window.addEventListener(\"message\", messageListener);\n    });\n  }\n  /**\n   * Generate password reset token (for custom email delivery)\n   */\n  async generatePasswordResetToken(email) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate password reset token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate password reset token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send password reset email (using Blink default email service)\n   */\n  async sendPasswordResetEmail(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          projectId: this.config.projectId,\n          redirectUrl: options?.redirectUrl\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send password reset email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Confirm password reset with token\n   */\n  async confirmPasswordReset(token, newPassword) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset/confirm`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token,\n          password: newPassword,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to reset password\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Change password (requires current authentication)\n   */\n  async changePassword(oldPassword, newPassword) {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/change`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          oldPassword,\n          newPassword\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to change password\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Generate email verification token (for custom email delivery)\n   */\n  async generateEmailVerificationToken() {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate email verification token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate email verification token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send email verification (using Blink default email service)\n   */\n  async sendEmailVerification() {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify/send`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send verification email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Verify email with token\n   */\n  async verifyEmail(token) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to verify email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Generate magic link token (for custom email delivery)\n   */\n  async generateMagicLinkToken(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          redirectUrl: options?.redirectUrl,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate magic link token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate magic link token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send magic link (using Blink default email service)\n   */\n  async sendMagicLink(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          redirectUrl: options?.redirectUrl,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send magic link\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Verify magic link (automatic on redirect)\n   */\n  async verifyMagicLink(token) {\n    const magicToken = token || this.extractMagicTokenFromUrl();\n    if (!magicToken) {\n      throw new BlinkAuthError(\"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */, \"No magic link token found\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic/verify`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token: magicToken,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Magic link verification failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Get available providers for the current project\n   */\n  async getAvailableProviders() {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/providers?projectId=${encodeURIComponent(this.config.projectId)}`);\n      if (!response.ok) {\n        return [\"email\", \"google\"];\n      }\n      const data = await response.json();\n      return data.providers || [\"email\", \"google\"];\n    } catch (error) {\n      return [\"email\", \"google\"];\n    }\n  }\n  /**\n   * Check if user has a specific role\n   */\n  hasRole(role) {\n    const user = this.authState.user;\n    if (!user || !user.role) {\n      return false;\n    }\n    if (Array.isArray(role)) {\n      return role.includes(user.role);\n    }\n    return user.role === role;\n  }\n  /**\n   * Check if user can perform a specific action\n   */\n  can(permission, resource) {\n    const user = this.authState.user;\n    if (!user || !user.role) {\n      return false;\n    }\n    const roles = this.authConfig.roles;\n    if (!roles) {\n      return false;\n    }\n    const roleConfig = roles[user.role];\n    if (!roleConfig) {\n      return false;\n    }\n    if (roleConfig.permissions.includes(\"*\")) {\n      return true;\n    }\n    const fullPermission = resource ? `${permission}.${resource}` : permission;\n    if (roleConfig.permissions.includes(fullPermission)) {\n      return true;\n    }\n    if (roleConfig.permissions.includes(permission)) {\n      return true;\n    }\n    const visited = /* @__PURE__ */ new Set();\n    const hasPermissionInRole = (roleName) => {\n      if (visited.has(roleName)) return false;\n      visited.add(roleName);\n      const rc = roles[roleName];\n      if (!rc) return false;\n      if (rc.permissions.includes(\"*\")) return true;\n      const fullPermission2 = resource ? `${permission}.${resource}` : permission;\n      if (rc.permissions.includes(fullPermission2) || rc.permissions.includes(permission)) return true;\n      if (rc.inherit) {\n        for (const parent of rc.inherit) {\n          if (hasPermissionInRole(parent)) return true;\n        }\n      }\n      return false;\n    };\n    if (hasPermissionInRole(user.role)) return true;\n    return false;\n  }\n  /**\n   * Sign out (clear local tokens)\n   * Note: With stateless tokens, this only clears local storage\n   */\n  async signOut() {\n    this.clearTokens();\n  }\n  /**\n   * @deprecated Use signOut() instead. Kept for backward compatibility.\n   */\n  async revokeAllSessions() {\n    return this.signOut();\n  }\n  /**\n   * Recover auth state (clear corrupted tokens and re-initialize)\n   */\n  async recoverAuthState() {\n    console.log(\"\\u{1F504} Recovering auth state...\");\n    this.clearTokens();\n    this.isInitialized = false;\n    this.initializationPromise = null;\n    if (typeof window !== \"undefined\") {\n      this.initializationPromise = this.initialize();\n      await this.initializationPromise;\n    }\n    console.log(\"\\u2705 Auth state recovery complete\");\n  }\n  /**\n   * Update user profile\n   */\n  async updateMe(updates) {\n    const token = this.getToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        method: \"PATCH\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(updates)\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || `Failed to update user: ${response.statusText}`);\n      }\n      const data = await response.json();\n      const user = data.user;\n      this.updateAuthState({\n        ...this.authState,\n        user\n      });\n      return user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Manually set tokens (for server-side usage)\n   */\n  async setToken(jwt, persist = false) {\n    const tokens = {\n      access_token: jwt,\n      token_type: \"Bearer\",\n      expires_in: 15 * 60\n      // Default 15 minutes\n    };\n    await this.setTokens(tokens, persist);\n  }\n  /**\n   * Manually set auth session from tokens (React Native deep link OAuth)\n   * \n   * Use this method to set the user session after receiving tokens from a deep link callback.\n   * This is the React Native equivalent of automatic URL token detection on web.\n   * \n   * @param tokens - Auth tokens received from deep link or OAuth callback\n   * @param persist - Whether to persist tokens to storage (default: true)\n   * \n   * @example\n   * // React Native: Handle deep link OAuth callback\n   * import * as Linking from 'expo-linking'\n   * \n   * Linking.addEventListener('url', async ({ url }) => {\n   *   const { queryParams } = Linking.parse(url)\n   *   \n   *   if (queryParams.access_token) {\n   *     await blink.auth.setSession({\n   *       access_token: queryParams.access_token,\n   *       refresh_token: queryParams.refresh_token,\n   *       expires_in: parseInt(queryParams.expires_in) || 3600,\n   *       refresh_expires_in: parseInt(queryParams.refresh_expires_in)\n   *     })\n   *     \n   *     console.log('User authenticated:', blink.auth.currentUser())\n   *   }\n   * })\n   */\n  async setSession(tokens, persist = true) {\n    const authTokens = {\n      access_token: tokens.access_token,\n      refresh_token: tokens.refresh_token,\n      token_type: \"Bearer\",\n      expires_in: tokens.expires_in || 3600,\n      // Default 1 hour\n      refresh_expires_in: tokens.refresh_expires_in,\n      issued_at: Math.floor(Date.now() / 1e3)\n    };\n    await this.setTokens(authTokens, persist);\n    const user = await this.me();\n    return user;\n  }\n  /**\n   * Verify a Blink Auth token using the introspection endpoint.\n   * \n   * **Server-side / Edge Function use only.**\n   * \n   * This is the recommended way to verify user tokens in Deno Edge Functions\n   * and other server-side contexts. It calls the Blink API introspection \n   * endpoint which validates the token without exposing the JWT secret.\n   * \n   * @param token - The raw JWT token (without \"Bearer \" prefix) or full Authorization header\n   * @returns Token introspection result with validity and claims\n   * \n   * @example\n   * // Deno Edge Function usage\n   * import { createClient } from \"npm:@blinkdotnew/sdk\";\n   * \n   * const blink = createClient({\n   *   projectId: Deno.env.get(\"BLINK_PROJECT_ID\")!,\n   *   secretKey: Deno.env.get(\"BLINK_SECRET_KEY\"),\n   * });\n   * \n   * async function handler(req: Request): Promise<Response> {\n   *   const authHeader = req.headers.get(\"Authorization\");\n   *   const result = await blink.auth.verifyToken(authHeader);\n   *   \n   *   if (!result.valid) {\n   *     return new Response(JSON.stringify({ error: result.error }), { status: 401 });\n   *   }\n   *   \n   *   // User is authenticated\n   *   console.log(\"User ID:\", result.userId);\n   *   console.log(\"Email:\", result.email);\n   *   console.log(\"Project:\", result.projectId);\n   *   \n   *   // Continue with your logic...\n   * }\n   */\n  async verifyToken(token) {\n    if (!token) {\n      return { valid: false, error: \"Token required\" };\n    }\n    let cleanToken = token.toLowerCase().startsWith(\"bearer \") ? token.slice(7) : token;\n    cleanToken = cleanToken.trim();\n    if (!cleanToken) {\n      return { valid: false, error: \"Token required\" };\n    }\n    try {\n      const response = await fetch(`${this.coreUrl}/api/auth/introspect`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${cleanToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      const contentType = response.headers.get(\"content-type\")?.toLowerCase();\n      if (!contentType || !contentType.includes(\"application/json\")) {\n        return {\n          valid: false,\n          error: `Server error: ${response.status} ${response.statusText}`\n        };\n      }\n      const result = await response.json();\n      if (!result || typeof result !== \"object\" || typeof result.valid !== \"boolean\") {\n        return {\n          valid: false,\n          error: result && (result.error || result.message) || `Request failed: ${response.status}`\n        };\n      }\n      return result;\n    } catch (error) {\n      console.error(\"[BlinkAuth] Token verification failed:\", error);\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : \"Token verification failed\"\n      };\n    }\n  }\n  /**\n   * Refresh access token using refresh token\n   */\n  async refreshToken() {\n    const refreshToken = this.authState.tokens?.refresh_token;\n    if (!refreshToken) {\n      return false;\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          refresh_token: refreshToken\n        })\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          this.clearTokens();\n          if (this.config.authRequired) {\n            this.redirectToAuth();\n          }\n        }\n        return false;\n      }\n      const data = await response.json();\n      await this.setTokens({\n        access_token: data.access_token,\n        refresh_token: data.refresh_token,\n        token_type: data.token_type,\n        expires_in: data.expires_in,\n        refresh_expires_in: data.refresh_expires_in\n      }, true);\n      return true;\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      return false;\n    }\n  }\n  /**\n   * Add auth state change listener\n   */\n  onAuthStateChanged(callback) {\n    this.listeners.add(callback);\n    queueMicrotask(() => {\n      try {\n        callback(this.authState);\n      } catch (error) {\n        console.error(\"Error in auth state change callback:\", error);\n      }\n    });\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n  /**\n   * Private helper methods\n   */\n  async validateStoredTokens(tokens) {\n    try {\n      console.log(\"\\u{1F50D} Validating stored tokens...\");\n      if (this.isAccessTokenExpired()) {\n        console.log(\"\\u23F0 Access token expired based on timestamp, attempting refresh...\");\n        if (!tokens.refresh_token) {\n          console.log(\"\\u274C No refresh token available\");\n          return false;\n        }\n        if (this.isRefreshTokenExpired()) {\n          console.log(\"\\u274C Refresh token also expired\");\n          return false;\n        }\n        const refreshed = await this.refreshToken();\n        if (refreshed) {\n          console.log(\"\\u2705 Token refreshed successfully during validation\");\n          return true;\n        } else {\n          console.log(\"\\u274C Token refresh failed during validation\");\n          return false;\n        }\n      }\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${tokens.access_token}`\n        }\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const user = data.user;\n        this.updateAuthState({\n          user,\n          tokens,\n          isAuthenticated: true,\n          isLoading: false\n        });\n        console.log(\"\\u2705 Stored tokens are valid, user authenticated\");\n        return true;\n      } else if (response.status === 401 && tokens.refresh_token) {\n        console.log(\"\\u{1F504} Access token expired (server validation), attempting refresh...\");\n        if (this.isRefreshTokenExpired()) {\n          console.log(\"\\u274C Refresh token expired\");\n          return false;\n        }\n        const refreshed = await this.refreshToken();\n        if (refreshed) {\n          console.log(\"\\u2705 Token refreshed successfully after server validation\");\n          return true;\n        } else {\n          console.log(\"\\u274C Token refresh failed after server validation\");\n          return false;\n        }\n      } else {\n        console.log(\"\\u274C Token validation failed:\", response.status, response.statusText);\n        return false;\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error validating tokens:\", error);\n      return false;\n    }\n  }\n  async setTokens(tokens, persist) {\n    const tokensWithTimestamp = {\n      ...tokens,\n      issued_at: tokens.issued_at || Math.floor(Date.now() / 1e3)\n    };\n    console.log(\"\\u{1F510} Setting tokens:\", {\n      persist,\n      hasAccessToken: !!tokensWithTimestamp.access_token,\n      hasRefreshToken: !!tokensWithTimestamp.refresh_token,\n      expiresIn: tokensWithTimestamp.expires_in,\n      issuedAt: tokensWithTimestamp.issued_at\n    });\n    if (persist) {\n      try {\n        const result = this.storage.setItem(\n          this.getStorageKey(\"tokens\"),\n          JSON.stringify(tokensWithTimestamp)\n        );\n        if (result instanceof Promise) {\n          await result;\n        }\n        console.log(\"\\u{1F4BE} Tokens persisted to storage\");\n      } catch (error) {\n        console.log(\"\\u{1F4A5} Error persisting tokens:\", error);\n      }\n    }\n    let user = null;\n    try {\n      console.log(\"\\u{1F464} Fetching user data...\");\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${tokensWithTimestamp.access_token}`\n        }\n      });\n      console.log(\"\\u{1F4E1} User fetch response:\", {\n        status: response.status,\n        statusText: response.statusText,\n        ok: response.ok\n      });\n      if (response.ok) {\n        const data = await response.json();\n        user = data.user;\n        console.log(\"\\u2705 User data fetched successfully:\", {\n          id: user?.id,\n          email: user?.email,\n          displayName: user?.displayName\n        });\n      } else {\n        console.log(\"\\u274C Failed to fetch user data:\", await response.text());\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error fetching user data:\", error);\n    }\n    this.updateAuthState({\n      user,\n      tokens: tokensWithTimestamp,\n      isAuthenticated: !!user,\n      isLoading: false\n    });\n    console.log(\"\\u{1F3AF} Auth state updated:\", {\n      hasUser: !!user,\n      isAuthenticated: !!user,\n      isLoading: false\n    });\n  }\n  clearTokens() {\n    try {\n      const result = this.storage.removeItem(this.getStorageKey(\"tokens\"));\n      if (result instanceof Promise) {\n        result.catch((error) => {\n          console.log(\"\\u{1F4A5} Error clearing tokens from storage:\", error);\n        });\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error clearing tokens:\", error);\n    }\n    this.updateAuthState({\n      user: null,\n      tokens: null,\n      isAuthenticated: false,\n      isLoading: false\n    });\n  }\n  async getStoredTokens() {\n    if (isWeb && this.isIframe && this.parentWindowTokens) {\n      return this.parentWindowTokens;\n    }\n    try {\n      const result = this.storage.getItem(this.getStorageKey(\"tokens\"));\n      const stored = result instanceof Promise ? await result : result;\n      console.log(\"\\u{1F50D} Checking storage for tokens:\", {\n        hasStoredData: !!stored,\n        storedLength: stored?.length || 0,\n        isIframe: isWeb && this.isIframe\n      });\n      if (stored) {\n        const tokens = JSON.parse(stored);\n        console.log(\"\\u{1F4E6} Parsed stored tokens:\", {\n          hasAccessToken: !!tokens.access_token,\n          hasRefreshToken: !!tokens.refresh_token,\n          tokenType: tokens.token_type,\n          expiresIn: tokens.expires_in\n        });\n        return tokens;\n      }\n      return null;\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error reading tokens from storage:\", error);\n      return null;\n    }\n  }\n  extractTokensFromUrl() {\n    const search = getLocationSearch();\n    if (!search) return null;\n    const params = new URLSearchParams(search);\n    const accessToken = params.get(\"access_token\");\n    const refreshToken = params.get(\"refresh_token\");\n    console.log(\"\\u{1F50D} Extracting tokens from URL:\", {\n      url: getLocationHref(),\n      accessToken: accessToken ? `${accessToken.substring(0, 20)}...` : null,\n      refreshToken: refreshToken ? `${refreshToken.substring(0, 20)}...` : null,\n      allParams: Object.fromEntries(params.entries())\n    });\n    if (accessToken) {\n      const tokens = {\n        access_token: accessToken,\n        refresh_token: refreshToken || void 0,\n        token_type: \"Bearer\",\n        expires_in: 15 * 60,\n        // 15 minutes default\n        refresh_expires_in: refreshToken ? 30 * 24 * 60 * 60 : void 0,\n        // 30 days default\n        issued_at: Math.floor(Date.now() / 1e3)\n        // Current timestamp\n      };\n      console.log(\"\\u2705 Tokens extracted successfully:\", {\n        hasAccessToken: !!tokens.access_token,\n        hasRefreshToken: !!tokens.refresh_token\n      });\n      return tokens;\n    }\n    console.log(\"\\u274C No access token found in URL\");\n    return null;\n  }\n  clearUrlTokens() {\n    const href = getLocationHref();\n    if (!href || !hasWindowLocation()) return;\n    const url = new URL(href);\n    url.searchParams.delete(\"access_token\");\n    url.searchParams.delete(\"refresh_token\");\n    url.searchParams.delete(\"token_type\");\n    url.searchParams.delete(\"project_id\");\n    url.searchParams.delete(\"expires_in\");\n    url.searchParams.delete(\"refresh_expires_in\");\n    url.searchParams.delete(\"state\");\n    url.searchParams.delete(\"code\");\n    url.searchParams.delete(\"error\");\n    url.searchParams.delete(\"error_description\");\n    window.history.replaceState({}, \"\", url.toString());\n    console.log(\"\\u{1F9F9} URL cleaned up, removed auth parameters\");\n  }\n  redirectToAuth() {\n    if (hasWindowLocation()) {\n      this.login();\n    }\n  }\n  setLoading(loading) {\n    this.updateAuthState({\n      ...this.authState,\n      isLoading: loading\n    });\n  }\n  updateAuthState(newState) {\n    this.authState = newState;\n    this.listeners.forEach((callback) => {\n      try {\n        callback(newState);\n      } catch (error) {\n        console.error(\"Error in auth state change callback:\", error);\n      }\n    });\n  }\n  /**\n   * Generate secure random state for OAuth flows\n   */\n  generateState() {\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n      const array = new Uint8Array(16);\n      crypto.getRandomValues(array);\n      return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n    } else {\n      return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n    }\n  }\n  /**\n   * Generate unique session ID for mobile OAuth\n   */\n  generateSessionId() {\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n      const array = new Uint8Array(32);\n      crypto.getRandomValues(array);\n      return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n    } else {\n      return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n    }\n  }\n  /**\n   * Extract magic link token from URL\n   */\n  extractMagicTokenFromUrl() {\n    const search = getLocationSearch();\n    if (!search) return null;\n    const params = new URLSearchParams(search);\n    return params.get(\"magic_token\") || params.get(\"token\");\n  }\n  /**\n   * Map server error codes to BlinkAuthErrorCode\n   */\n  mapErrorCodeFromResponse(serverCode) {\n    switch (serverCode) {\n      case \"INVALID_CREDENTIALS\":\n      case \"auth/invalid-credential\":\n      case \"auth/wrong-password\":\n      case \"auth/user-not-found\":\n        return \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */;\n      case \"EMAIL_NOT_VERIFIED\":\n      case \"auth/email-not-verified\":\n        return \"EMAIL_NOT_VERIFIED\" /* EMAIL_NOT_VERIFIED */;\n      case \"EMAIL_ALREADY_VERIFIED\":\n        return \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */;\n      case \"POPUP_CANCELED\":\n      case \"auth/popup-closed-by-user\":\n        return \"POPUP_CANCELED\" /* POPUP_CANCELED */;\n      case \"NETWORK_ERROR\":\n        return \"NETWORK_ERROR\" /* NETWORK_ERROR */;\n      case \"RATE_LIMITED\":\n      case \"auth/too-many-requests\":\n        return \"RATE_LIMITED\" /* RATE_LIMITED */;\n      case \"AUTH_TIMEOUT\":\n        return \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */;\n      case \"REDIRECT_FAILED\":\n        return \"REDIRECT_FAILED\" /* REDIRECT_FAILED */;\n      case \"TOKEN_EXPIRED\":\n      case \"auth/id-token-expired\":\n        return \"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */;\n      case \"USER_NOT_FOUND\":\n        return \"USER_NOT_FOUND\" /* USER_NOT_FOUND */;\n      case \"EMAIL_ALREADY_EXISTS\":\n      case \"auth/email-already-in-use\":\n        return \"EMAIL_ALREADY_EXISTS\" /* EMAIL_ALREADY_EXISTS */;\n      case \"WEAK_PASSWORD\":\n      case \"auth/weak-password\":\n        return \"WEAK_PASSWORD\" /* WEAK_PASSWORD */;\n      case \"INVALID_EMAIL\":\n      case \"auth/invalid-email\":\n        return \"INVALID_EMAIL\" /* INVALID_EMAIL */;\n      case \"MAGIC_LINK_EXPIRED\":\n        return \"MAGIC_LINK_EXPIRED\" /* MAGIC_LINK_EXPIRED */;\n      case \"VERIFICATION_FAILED\":\n        return \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */;\n      default:\n        return \"NETWORK_ERROR\" /* NETWORK_ERROR */;\n    }\n  }\n  /**\n   * Setup cross-tab authentication synchronization\n   */\n  setupCrossTabSync() {\n    if (!isWeb || !hasWindow()) return;\n    window.addEventListener(\"storage\", (e) => {\n      if (e.key === this.getStorageKey(\"tokens\")) {\n        const newTokens = e.newValue ? JSON.parse(e.newValue) : null;\n        if (newTokens && newTokens !== this.authState.tokens) {\n          this.setTokens(newTokens, false).catch((error) => {\n            console.error(\"Failed to sync tokens from other tab:\", error);\n          });\n        } else if (!newTokens && this.authState.tokens) {\n          this.clearTokens();\n        }\n      }\n    });\n  }\n};\n\n// src/database.ts\nfunction assertServerOnly(methodName) {\n  if (typeof window !== \"undefined\") {\n    throw new Error(`${methodName} is server-only. Use Blink CRUD methods (blink.db.<table>.*) instead.`);\n  }\n}\nfunction camelToSnake3(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction generateSecureId() {\n  if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n    const array = new Uint8Array(16);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n  } else {\n    const timestamp = Date.now().toString(36);\n    const randomPart = Math.random().toString(36).substring(2, 15);\n    const extraRandom = Math.random().toString(36).substring(2, 15);\n    return `${timestamp}_${randomPart}_${extraRandom}`;\n  }\n}\nfunction ensureRecordId(record) {\n  if (!record.id) {\n    return { ...record, id: generateSecureId() };\n  }\n  return record;\n}\nvar BlinkTable = class {\n  constructor(tableName, httpClient) {\n    this.tableName = tableName;\n    this.httpClient = httpClient;\n    this.actualTableName = camelToSnake3(tableName);\n  }\n  actualTableName;\n  /**\n   * Create a single record\n   */\n  async create(data, options = {}) {\n    const record = ensureRecordId(data);\n    const response = await this.httpClient.dbPost(\n      this.actualTableName,\n      record,\n      { returning: options.returning !== false }\n    );\n    const result = Array.isArray(response.data) ? response.data[0] : response.data;\n    if (!result) {\n      throw new Error(\"Failed to create record\");\n    }\n    return result;\n  }\n  /**\n   * Create multiple records\n   */\n  async createMany(data, options = {}) {\n    const records = data.map(ensureRecordId);\n    const response = await this.httpClient.dbPost(\n      this.actualTableName,\n      records,\n      { returning: options.returning !== false }\n    );\n    const results = Array.isArray(response.data) ? response.data : [response.data];\n    return results;\n  }\n  /**\n   * Upsert a single record (insert or update on conflict)\n   */\n  async upsert(data, options = {}) {\n    const headers = {};\n    if (options.returning !== false) {\n      headers.Prefer = \"return=representation\";\n    }\n    if (options.onConflict) {\n      headers[\"Prefer\"] = `${headers[\"Prefer\"] || \"\"} resolution=merge-duplicates`.trim();\n    }\n    const record = ensureRecordId(data);\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || \"id\"}`,\n      {\n        method: \"POST\",\n        body: record,\n        headers\n      }\n    );\n    const result = Array.isArray(response.data) ? response.data[0] : response.data;\n    if (!result) {\n      throw new Error(\"Failed to upsert record\");\n    }\n    return result;\n  }\n  /**\n   * Upsert multiple records\n   */\n  async upsertMany(data, options = {}) {\n    const records = data.map(ensureRecordId);\n    const headers = {};\n    if (options.returning !== false) {\n      headers.Prefer = \"return=representation\";\n    }\n    if (options.onConflict) {\n      headers[\"Prefer\"] = `${headers[\"Prefer\"] || \"\"} resolution=merge-duplicates`.trim();\n    }\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || \"id\"}`,\n      {\n        method: \"POST\",\n        body: records,\n        headers\n      }\n    );\n    const results = Array.isArray(response.data) ? response.data : [response.data];\n    return results;\n  }\n  /**\n   * Get a single record by ID\n   */\n  async get(id) {\n    const searchParams = {\n      id: `eq.${id}`,\n      limit: \"1\"\n    };\n    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);\n    const records = response.data;\n    if (records.length === 0) {\n      return null;\n    }\n    return records[0] || null;\n  }\n  /**\n   * List records with filtering, sorting, and pagination\n   */\n  async list(options = {}) {\n    const queryParams = buildQuery(options);\n    const searchParams = queryParams;\n    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);\n    const records = response.data;\n    return records;\n  }\n  /**\n   * Update a single record by ID\n   */\n  async update(id, data, options = {}) {\n    const searchParams = {\n      id: `eq.${id}`\n    };\n    const response = await this.httpClient.dbPatch(\n      this.actualTableName,\n      data,\n      searchParams,\n      { returning: options.returning !== false }\n    );\n    const records = response.data;\n    if (!records || records.length === 0) {\n      throw new Error(`Record with id ${id} not found`);\n    }\n    return records[0];\n  }\n  /**\n   * Update multiple records\n   */\n  async updateMany(updates, options = {}) {\n    const results = [];\n    for (const update of updates) {\n      const { id, ...data } = update;\n      const result = await this.update(id, data, options);\n      results.push(result);\n    }\n    return results;\n  }\n  /**\n   * Delete a single record by ID\n   */\n  async delete(id) {\n    const searchParams = {\n      id: `eq.${id}`\n    };\n    await this.httpClient.dbDelete(this.actualTableName, searchParams);\n  }\n  /**\n   * Delete multiple records based on filter\n   */\n  async deleteMany(options) {\n    const queryParams = buildQuery({ where: options.where });\n    const searchParams = queryParams;\n    await this.httpClient.dbDelete(this.actualTableName, searchParams);\n  }\n  /**\n   * Count records matching filter\n   */\n  async count(options = {}) {\n    const queryParams = buildQuery({\n      where: options.where,\n      select: [\"id\"]\n    });\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}`,\n      {\n        method: \"GET\",\n        searchParams: queryParams,\n        headers: {\n          \"Prefer\": \"count=exact\"\n        }\n      }\n    );\n    const contentRange = response.headers.get(\"content-range\");\n    if (contentRange) {\n      const match = contentRange.match(/\\/(\\d+)$/);\n      if (match && match[1]) {\n        return parseInt(match[1], 10);\n      }\n    }\n    const records = response.data;\n    return records.length;\n  }\n  /**\n   * Check if any records exist matching filter\n   */\n  async exists(options) {\n    const count = await this.count(options);\n    return count > 0;\n  }\n  /**\n   * Raw SQL query on this table (for advanced use cases)\n   */\n  async sql(query, params) {\n    assertServerOnly(\"blink.db.<table>.sql\");\n    const response = await this.httpClient.dbSql(query, params);\n    return response.data;\n  }\n  /**\n   * Private helper methods\n   */\n  extractCursor(record) {\n    return record.id || record._id || String(Math.random());\n  }\n};\nvar BlinkDatabase = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    const proxy = new Proxy(this, {\n      get(target, prop) {\n        if (prop === \"table\") {\n          return target.table.bind(target);\n        }\n        if (prop in target) {\n          const value = target[prop];\n          return typeof value === \"function\" ? value.bind(target) : value;\n        }\n        if (typeof prop === \"string\") {\n          return target.table(prop);\n        }\n        return void 0;\n      }\n    });\n    return proxy;\n  }\n  tables = /* @__PURE__ */ new Map();\n  /**\n   * Get a table instance for any table name\n   */\n  table(tableName) {\n    if (!this.tables.has(tableName)) {\n      this.tables.set(tableName, new BlinkTable(tableName, this.httpClient));\n    }\n    const table = this.tables.get(tableName);\n    if (!table) {\n      throw new Error(`Table ${tableName} not found`);\n    }\n    return table;\n  }\n  /**\n   * Execute raw SQL query\n   */\n  async sql(query, params) {\n    assertServerOnly(\"blink.db.sql\");\n    const response = await this.httpClient.dbSql(query, params);\n    return response.data;\n  }\n  /**\n   * Execute batch SQL operations\n   */\n  async batch(statements, mode = \"write\") {\n    assertServerOnly(\"blink.db.batch\");\n    const response = await this.httpClient.dbBatch(statements, mode);\n    return response.data;\n  }\n};\n\n// src/storage.ts\nvar BlinkStorageImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  /**\n   * Upload a file to project storage\n   * \n   * @param file - File, Blob, or Buffer to upload\n   * @param path - Destination path within project storage (extension will be auto-corrected to match file type)\n   * @param options - Upload options including upsert and progress callback\n   * @returns Promise resolving to upload response with public URL\n   * \n   * @example\n   * ```ts\n   * // Extension automatically corrected to match actual file type\n   * const { publicUrl } = await blink.storage.upload(\n   *   pngFile,\n   *   `avatars/${user.id}`, // No extension needed!\n   *   { upsert: true }\n   * );\n   * // If file is PNG, final path will be: avatars/user123.png\n   * \n   * // Or with extension (will be corrected if wrong)\n   * const { publicUrl } = await blink.storage.upload(\n   *   pngFile,\n   *   `avatars/${user.id}.jpg`, // Wrong extension\n   *   { upsert: true }\n   * );\n   * // Final path will be: avatars/user123.png (auto-corrected!)\n   * ```\n   */\n  async upload(file, path, options = {}) {\n    try {\n      if (!file) {\n        throw new BlinkStorageError(\"File is required\");\n      }\n      if (!path || typeof path !== \"string\" || !path.trim()) {\n        throw new BlinkStorageError(\"Path must be a non-empty string\");\n      }\n      const maxSize = 50 * 1024 * 1024;\n      let fileSize = 0;\n      if (file instanceof File || file instanceof Blob) {\n        fileSize = file.size;\n      } else if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n        fileSize = file.length;\n      }\n      if (fileSize > maxSize) {\n        throw new BlinkStorageError(`File size (${Math.round(fileSize / 1024 / 1024)}MB) exceeds maximum allowed size (50MB)`);\n      }\n      const { correctedPath, detectedContentType } = await this.detectFileTypeAndCorrectPath(file, path);\n      const response = await this.httpClient.uploadFile(\n        `/api/storage/${this.httpClient.projectId}/upload`,\n        file,\n        correctedPath,\n        // Use corrected path with proper extension\n        {\n          onProgress: options.onProgress,\n          contentType: detectedContentType\n          // Pass detected content type\n        }\n      );\n      if (response.data?.data?.publicUrl) {\n        return { publicUrl: response.data.data.publicUrl };\n      } else if (response.data?.publicUrl) {\n        return { publicUrl: response.data.publicUrl };\n      } else {\n        throw new BlinkStorageError(\"Invalid response format: missing publicUrl\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 409) {\n          throw new BlinkStorageError(\"File already exists.\", 409);\n        }\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Upload failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Detect file type from actual file content and correct path extension\n   * This ensures the path extension always matches the actual file type\n   */\n  async detectFileTypeAndCorrectPath(file, originalPath) {\n    try {\n      const fileSignature = await this.getFileSignature(file);\n      const detectedType = this.detectFileTypeFromSignature(fileSignature);\n      let detectedContentType = detectedType.mimeType;\n      let detectedExtension = detectedType.extension;\n      if (!detectedContentType && file instanceof File && file.type) {\n        detectedContentType = file.type;\n        detectedExtension = this.getExtensionFromMimeType(file.type);\n      }\n      if (!detectedContentType) {\n        detectedContentType = \"application/octet-stream\";\n        detectedExtension = \"bin\";\n      }\n      const pathParts = originalPath.split(\"/\");\n      const fileName = pathParts[pathParts.length - 1];\n      const directory = pathParts.slice(0, -1).join(\"/\");\n      if (!fileName) {\n        throw new Error(\"Invalid path: filename cannot be empty\");\n      }\n      const nameWithoutExt = fileName.includes(\".\") ? fileName.substring(0, fileName.lastIndexOf(\".\")) : fileName;\n      const correctedFileName = `${nameWithoutExt}.${detectedExtension}`;\n      const correctedPath = directory ? `${directory}/${correctedFileName}` : correctedFileName;\n      return {\n        correctedPath,\n        detectedContentType\n      };\n    } catch (error) {\n      return {\n        correctedPath: originalPath,\n        detectedContentType: \"application/octet-stream\"\n      };\n    }\n  }\n  /**\n   * Get the first few bytes of a file to analyze its signature\n   */\n  async getFileSignature(file) {\n    const bytesToRead = 12;\n    if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n      return new Uint8Array(file.slice(0, bytesToRead));\n    }\n    if (file instanceof File || file instanceof Blob) {\n      const slice = file.slice(0, bytesToRead);\n      const arrayBuffer = await slice.arrayBuffer();\n      return new Uint8Array(arrayBuffer);\n    }\n    throw new Error(\"Unsupported file type for signature detection\");\n  }\n  /**\n   * Detect file type from file signature (magic numbers)\n   * This is the most reliable way to detect actual file type\n   */\n  detectFileTypeFromSignature(signature) {\n    const hex = Array.from(signature).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    const signatures = {\n      // Images\n      \"ffd8ff\": { mimeType: \"image/jpeg\", extension: \"jpg\" },\n      \"89504e47\": { mimeType: \"image/png\", extension: \"png\" },\n      \"47494638\": { mimeType: \"image/gif\", extension: \"gif\" },\n      \"52494646\": { mimeType: \"image/webp\", extension: \"webp\" },\n      // RIFF (WebP container)\n      \"424d\": { mimeType: \"image/bmp\", extension: \"bmp\" },\n      \"49492a00\": { mimeType: \"image/tiff\", extension: \"tiff\" },\n      \"4d4d002a\": { mimeType: \"image/tiff\", extension: \"tiff\" },\n      // Documents\n      \"25504446\": { mimeType: \"application/pdf\", extension: \"pdf\" },\n      \"504b0304\": { mimeType: \"application/zip\", extension: \"zip\" },\n      // Also used by docx, xlsx\n      \"d0cf11e0\": { mimeType: \"application/msword\", extension: \"doc\" },\n      // Audio\n      \"494433\": { mimeType: \"audio/mpeg\", extension: \"mp3\" },\n      \"664c6143\": { mimeType: \"audio/flac\", extension: \"flac\" },\n      \"4f676753\": { mimeType: \"audio/ogg\", extension: \"ogg\" },\n      // Video\n      \"000000\": { mimeType: \"video/mp4\", extension: \"mp4\" },\n      // ftyp box\n      \"1a45dfa3\": { mimeType: \"video/webm\", extension: \"webm\" },\n      // Text\n      \"efbbbf\": { mimeType: \"text/plain\", extension: \"txt\" }\n      // UTF-8 BOM\n    };\n    for (const [sig, type] of Object.entries(signatures)) {\n      if (hex.startsWith(sig)) {\n        return type;\n      }\n    }\n    if (hex.startsWith(\"52494646\") && hex.substring(16, 24) === \"57454250\") {\n      return { mimeType: \"image/webp\", extension: \"webp\" };\n    }\n    if (hex.substring(8, 16) === \"66747970\") {\n      return { mimeType: \"video/mp4\", extension: \"mp4\" };\n    }\n    return { mimeType: \"\", extension: \"\" };\n  }\n  /**\n   * Get file extension from MIME type as fallback\n   */\n  getExtensionFromMimeType(mimeType) {\n    const mimeToExt = {\n      \"image/jpeg\": \"jpg\",\n      \"image/png\": \"png\",\n      \"image/gif\": \"gif\",\n      \"image/webp\": \"webp\",\n      \"image/bmp\": \"bmp\",\n      \"image/svg+xml\": \"svg\",\n      \"application/pdf\": \"pdf\",\n      \"text/plain\": \"txt\",\n      \"text/html\": \"html\",\n      \"text/css\": \"css\",\n      \"application/javascript\": \"js\",\n      \"application/json\": \"json\",\n      \"audio/mpeg\": \"mp3\",\n      \"audio/wav\": \"wav\",\n      \"audio/ogg\": \"ogg\",\n      \"video/mp4\": \"mp4\",\n      \"video/webm\": \"webm\",\n      \"application/zip\": \"zip\"\n    };\n    return mimeToExt[mimeType] || \"bin\";\n  }\n  /**\n   * Get a download URL for a file that triggers browser download\n   * \n   * @param path - Path to the file in project storage\n   * @param options - Download options including custom filename\n   * @returns Promise resolving to download response with download URL\n   * \n   * @example\n   * ```ts\n   * // Download with original filename\n   * const { downloadUrl, filename } = await blink.storage.download('images/photo.jpg');\n   * window.open(downloadUrl, '_blank');\n   * \n   * // Download with custom filename\n   * const { downloadUrl } = await blink.storage.download(\n   *   'images/photo.jpg',\n   *   { filename: 'my-photo.jpg' }\n   * );\n   * \n   * // Create download link in React\n   * <a href={downloadUrl} download={filename}>Download Image</a>\n   * ```\n   */\n  async download(path, options = {}) {\n    try {\n      if (!path || typeof path !== \"string\" || !path.trim()) {\n        throw new BlinkStorageError(\"Path must be a non-empty string\");\n      }\n      const response = await this.httpClient.request(\n        `/api/storage/${this.httpClient.projectId}/download`,\n        {\n          method: \"GET\",\n          searchParams: {\n            path: path.trim(),\n            ...options.filename && { filename: options.filename }\n          }\n        }\n      );\n      if (response.data?.downloadUrl) {\n        return {\n          downloadUrl: response.data.downloadUrl,\n          filename: response.data.filename || options.filename || path.split(\"/\").pop() || \"download\",\n          contentType: response.data.contentType,\n          size: response.data.size\n        };\n      } else {\n        throw new BlinkStorageError(\"Invalid response format: missing downloadUrl\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 404) {\n          throw new BlinkStorageError(\"File not found\", 404);\n        }\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Download failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Remove one or more files from project storage\n   * \n   * @param paths - File paths to remove\n   * @returns Promise that resolves when files are removed\n   * \n   * @example\n   * ```ts\n   * await blink.storage.remove('avatars/user1.png');\n   * await blink.storage.remove('file1.pdf', 'file2.pdf', 'file3.pdf');\n   * ```\n   */\n  async remove(...paths) {\n    try {\n      if (paths.length === 0) {\n        throw new BlinkStorageError(\"At least one path must be provided\");\n      }\n      for (const path of paths) {\n        if (!path || typeof path !== \"string\") {\n          throw new BlinkStorageError(\"All paths must be non-empty strings\");\n        }\n      }\n      await this.httpClient.request(\n        `/api/storage/${this.httpClient.projectId}/remove`,\n        {\n          method: \"DELETE\",\n          body: { paths },\n          headers: { \"Content-Type\": \"application/json\" }\n        }\n      );\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Failed to remove files: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n};\n\n// src/tools/core.ts\nvar webSearch = \"web_search\";\nvar fetchUrl = \"fetch_url\";\nvar runCode = \"run_code\";\nvar coreTools = [webSearch, fetchUrl, runCode];\n\n// src/tools/sandbox.ts\nvar readFile = \"read_file\";\nvar listDir = \"list_dir\";\nvar writeFile = \"write_file\";\nvar searchReplace = \"search_replace\";\nvar grep = \"grep\";\nvar globFileSearch = \"glob_file_search\";\nvar runTerminalCmd = \"run_terminal_cmd\";\nvar getHost = \"get_host\";\nvar sandboxTools = [\n  readFile,\n  listDir,\n  writeFile,\n  searchReplace,\n  grep,\n  globFileSearch,\n  runTerminalCmd,\n  getHost\n];\n\n// src/tools/db.ts\nvar dbInsert = \"db_insert\";\nvar dbList = \"db_list\";\nvar dbGet = \"db_get\";\nvar dbUpdate = \"db_update\";\nvar dbDelete = \"db_delete\";\nvar dbTools = [dbInsert, dbList, dbGet, dbUpdate, dbDelete];\n\n// src/tools/storage.ts\nvar storageUpload = \"storage_upload\";\nvar storageDownload = \"storage_download\";\nvar storageList = \"storage_list\";\nvar storageDelete = \"storage_delete\";\nvar storagePublicUrl = \"storage_public_url\";\nvar storageMove = \"storage_move\";\nvar storageCopy = \"storage_copy\";\nvar storageTools = [\n  storageUpload,\n  storageDownload,\n  storageList,\n  storageDelete,\n  storagePublicUrl,\n  storageMove,\n  storageCopy\n];\n\n// src/tools/rag.ts\nvar ragSearch = \"rag_search\";\nvar ragTools = [ragSearch];\n\n// src/tools/media.ts\nvar generateImage = \"generate_image\";\nvar editImage = \"edit_image\";\nvar generateVideo = \"generate_video\";\nvar imageToVideo = \"image_to_video\";\nvar mediaTools = [generateImage, editImage, generateVideo, imageToVideo];\n\n// src/tools/index.ts\nfunction serializeTools(tools) {\n  return tools;\n}\n\n// src/agent.ts\nfunction createStopConditions(maxSteps, stopWhen) {\n  if (stopWhen && stopWhen.length > 0) {\n    return stopWhen;\n  }\n  if (maxSteps && maxSteps > 0) {\n    return [{ type: \"step_count_is\", count: maxSteps }];\n  }\n  return void 0;\n}\nvar Agent = class {\n  httpClient = null;\n  config;\n  /**\n   * Create a new Agent instance.\n   * Auto-binds to default client if createClient() was called.\n   * \n   * @param options - Agent configuration options\n   */\n  constructor(options) {\n    if (!options.model) {\n      throw new BlinkAIError(\"Agent model is required\");\n    }\n    this.config = options;\n    try {\n      this.httpClient = _getDefaultHttpClient();\n    } catch {\n    }\n  }\n  /**\n   * Internal: Set the HTTP client (called by BlinkClient)\n   */\n  _setHttpClient(client) {\n    this.httpClient = client;\n  }\n  /**\n   * Internal: Get the agent config for API requests\n   */\n  getAgentConfig() {\n    const { model, system, instructions, tools, webhookTools, clientTools, toolChoice, stopWhen, maxSteps } = this.config;\n    const serializedTools = tools ? serializeTools(tools) : void 0;\n    const stopConditions = createStopConditions(maxSteps, stopWhen);\n    return {\n      model,\n      system: system || instructions,\n      tools: serializedTools,\n      webhook_tools: webhookTools,\n      client_tools: clientTools,\n      tool_choice: toolChoice,\n      stop_when: stopConditions\n    };\n  }\n  /**\n   * Generate a response (non-streaming)\n   * \n   * @param options - Generation options (prompt or messages)\n   * @returns Promise<AgentResponse> with text, steps, usage, and billing\n   * \n   * @example\n   * ```ts\n   * const result = await agent.generate({\n   *   prompt: 'What is the weather in San Francisco?',\n   * })\n   * console.log(result.text)\n   * console.log(result.steps)\n   * ```\n   */\n  async generate(options) {\n    if (!this.httpClient) {\n      throw new BlinkAIError(\n        \"Agent not initialized. Call createClient() first, or use useAgent() in React.\"\n      );\n    }\n    if (!options.prompt && !options.messages) {\n      throw new BlinkAIError(\"Either prompt or messages is required\");\n    }\n    if (options.prompt && options.messages) {\n      throw new BlinkAIError(\"prompt and messages are mutually exclusive\");\n    }\n    try {\n      const requestBody = {\n        stream: false,\n        agent: this.getAgentConfig()\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      } else if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      if (options.sandbox) {\n        requestBody.sandbox_id = typeof options.sandbox === \"string\" ? options.sandbox : options.sandbox.id;\n      }\n      const response = await this.httpClient.aiAgent(requestBody, options.signal);\n      return response.data;\n    } catch (error) {\n      console.error(\"[Agent] generate failed:\", error);\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Agent generate failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Stream a response (real-time)\n   * \n   * @param options - Stream options (prompt or messages)\n   * @returns Promise<Response> - AI SDK UI Message Stream for useChat compatibility\n   * \n   * @example\n   * ```ts\n   * const stream = await agent.stream({\n   *   prompt: 'Tell me a story',\n   * })\n   * \n   * // Process stream\n   * for await (const chunk of stream.body) {\n   *   // Handle chunk\n   * }\n   * ```\n   */\n  async stream(options) {\n    if (!this.httpClient) {\n      throw new BlinkAIError(\n        \"Agent not initialized. Call createClient() first, or use useAgent() in React.\"\n      );\n    }\n    if (!options.prompt && !options.messages) {\n      throw new BlinkAIError(\"Either prompt or messages is required\");\n    }\n    if (options.prompt && options.messages) {\n      throw new BlinkAIError(\"prompt and messages are mutually exclusive\");\n    }\n    try {\n      const requestBody = {\n        stream: true,\n        agent: this.getAgentConfig()\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      } else if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      if (options.sandbox) {\n        requestBody.sandbox_id = typeof options.sandbox === \"string\" ? options.sandbox : options.sandbox.id;\n      }\n      return await this.httpClient.aiAgentStream(requestBody, options.signal);\n    } catch (error) {\n      console.error(\"[Agent] stream failed:\", error);\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Agent stream failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Get the agent's model\n   */\n  get model() {\n    return this.config.model;\n  }\n  /**\n   * Get the agent's system prompt\n   */\n  get system() {\n    return this.config.system || this.config.instructions;\n  }\n  /**\n   * Get the agent's tools\n   */\n  get tools() {\n    return this.config.tools;\n  }\n};\nfunction stepCountIs(count) {\n  return { type: \"step_count_is\", count };\n}\n\n// src/ai.ts\nvar BlinkAIImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  // Supported image formats for validation\n  SUPPORTED_IMAGE_FORMATS = [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\"];\n  /**\n   * Validates if a URL is a valid HTTPS image URL\n   */\n  validateImageUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      if (parsedUrl.protocol !== \"https:\") {\n        return { isValid: false, error: \"Image URLs must use HTTPS protocol\" };\n      }\n      const pathname = parsedUrl.pathname.toLowerCase();\n      const hasValidExtension = this.SUPPORTED_IMAGE_FORMATS.some(\n        (format) => pathname.endsWith(`.${format}`)\n      );\n      if (!hasValidExtension) {\n        return {\n          isValid: false,\n          error: `Image URL must end with a supported format: ${this.SUPPORTED_IMAGE_FORMATS.join(\", \")}`\n        };\n      }\n      return { isValid: true };\n    } catch (error) {\n      return { isValid: false, error: \"Invalid URL format\" };\n    }\n  }\n  /**\n   * Validates messages for image content\n   */\n  validateMessages(messages) {\n    const errors = [];\n    messages.forEach((message, messageIndex) => {\n      if (Array.isArray(message.content)) {\n        message.content.forEach((item, contentIndex) => {\n          if (item.type === \"image\") {\n            if (!item.image || typeof item.image !== \"string\") {\n              errors.push(`Message ${messageIndex}, content ${contentIndex}: Image content must have a valid image URL`);\n            } else {\n              const validation = this.validateImageUrl(item.image);\n              if (!validation.isValid) {\n                errors.push(`Message ${messageIndex}, content ${contentIndex}: ${validation.error}`);\n              }\n            }\n          }\n        });\n      }\n    });\n    return { isValid: errors.length === 0, errors };\n  }\n  /**\n   * Get MIME type for audio format\n   */\n  getMimeTypeForFormat(format) {\n    const mimeTypes = {\n      mp3: \"audio/mpeg\",\n      opus: \"audio/opus\",\n      aac: \"audio/aac\",\n      flac: \"audio/flac\",\n      wav: \"audio/wav\",\n      pcm: \"audio/pcm\"\n    };\n    return mimeTypes[format] || \"audio/mpeg\";\n  }\n  /**\n   * Generates a text response using the Blink AI engine.\n   * \n   * @param options - An object containing either:\n   *   - `prompt`: a simple string prompt\n   *   - OR `messages`: an array of chat messages for conversation\n   *   - Plus optional model, search, maxSteps, experimental_continueSteps, maxTokens, temperature, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Simple prompt\n   * const { text } = await blink.ai.generateText({ \n   *   prompt: \"Write a poem about coding\" \n   * });\n   * \n   * // Chat messages (text only)\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { role: \"system\", content: \"You are a helpful assistant\" },\n   *     { role: \"user\", content: \"Explain quantum computing\" }\n   *   ]\n   * });\n   * \n   * // With image content\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { \n   *       role: \"user\", \n   *       content: [\n   *         { type: \"text\", text: \"What do you see in this image?\" },\n   *         { type: \"image\", image: \"https://example.com/photo.jpg\" }\n   *       ]\n   *     }\n   *   ]\n   * });\n   * \n   * // Mixed content with multiple images\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { \n   *       role: \"user\", \n   *       content: [\n   *         { type: \"text\", text: \"Compare these two images:\" },\n   *         { type: \"image\", image: \"https://example.com/image1.jpg\" },\n   *         { type: \"image\", image: \"https://example.com/image2.jpg\" }\n   *       ]\n   *     }\n   *   ]\n   * });\n   * \n   * // With options\n   * const { text, usage } = await blink.ai.generateText({\n   *   prompt: \"Summarize this article\",\n   *   model: \"gpt-4.1-mini\",\n   *   maxTokens: 150,\n   *   temperature: 0.7\n   * });\n   * \n   * // With web search (OpenAI models only)\n   * const { text, sources } = await blink.ai.generateText({\n   *   prompt: \"What are the latest developments in AI?\",\n   *   model: \"gpt-4.1-mini\",\n   *   search: true // Enables web search\n   * });\n   * \n   * // With advanced multi-step configuration\n   * const { text } = await blink.ai.generateText({\n   *   prompt: \"Research and analyze recent tech trends\",\n   *   model: \"gpt-4o\",\n   *   search: true,\n   *   maxSteps: 10, // Allow up to 10 reasoning steps\n   *   experimental_continueSteps: true // Enable continued reasoning\n   * });\n   * ```\n   * \n   * @returns Promise<TextGenerationResponse> - Object containing:\n   *   - `text`: Generated text string\n   *   - `usage`: Token usage information\n   *   - `finishReason`: Why generation stopped (\"stop\", \"length\", etc.)\n   */\n  async generateText(options) {\n    try {\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.messages) {\n        const validation = this.validateMessages(options.messages);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Message validation failed: ${validation.errors.join(\"; \")}`);\n        }\n      }\n      const requestBody = {\n        model: options.model,\n        stream: false,\n        search: options.search,\n        maxSteps: options.maxSteps,\n        experimental_continueSteps: options.experimental_continueSteps,\n        maxTokens: options.maxTokens,\n        temperature: options.temperature,\n        signal: options.signal\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      }\n      if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      const response = await this.httpClient.aiText(\n        options.prompt || \"\",\n        requestBody\n      );\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Text generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Streams text generation with real-time updates as the AI generates content.\n   * \n   * @param options - Same as generateText: either `prompt` or `messages` with optional parameters including search, maxSteps, experimental_continueSteps\n   * @param onChunk - Callback function that receives each text chunk as it's generated\n   * \n   * @example\n   * ```ts\n   * // Stream with prompt\n   * await blink.ai.streamText(\n   *   { prompt: \"Write a short story about space exploration\" },\n   *   (chunk) => {\n   *     process.stdout.write(chunk); // Real-time output\n   *   }\n   * );\n   * \n   * // Stream with messages\n   * await blink.ai.streamText(\n   *   { \n   *     messages: [\n   *       { role: \"system\", content: \"You are a creative writer\" },\n   *       { role: \"user\", content: \"Write a haiku about programming\" }\n   *     ]\n   *   },\n   *   (chunk) => updateUI(chunk)\n   * );\n   * ```\n   * \n   * @returns Promise<TextGenerationResponse> - Final complete response with full text and metadata\n   */\n  async streamText(options, onChunk) {\n    try {\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.messages) {\n        const validation = this.validateMessages(options.messages);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Message validation failed: ${validation.errors.join(\"; \")}`);\n        }\n      }\n      const result = await this.httpClient.streamAiText(\n        options.prompt || \"\",\n        {\n          model: options.model,\n          messages: options.messages,\n          search: options.search,\n          maxSteps: options.maxSteps,\n          experimental_continueSteps: options.experimental_continueSteps,\n          maxTokens: options.maxTokens,\n          temperature: options.temperature,\n          signal: options.signal\n        },\n        onChunk\n      );\n      return {\n        text: result.text || \"\",\n        finishReason: result.finishReason || \"stop\",\n        usage: result.usage,\n        toolCalls: result.toolCalls,\n        toolResults: result.toolResults,\n        sources: result.sources,\n        files: result.files,\n        reasoningDetails: result.reasoning,\n        response: result.response\n      };\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Text streaming failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates structured JSON objects using AI with schema validation.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Description of what object to generate (required)\n   *   - `schema`: JSON Schema to validate the generated object\n   *   - `output`: Type of output (\"object\", \"array\", \"enum\")\n   *   - `enum`: Array of allowed values for enum output\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Generate user profile\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"Generate a user profile for a software developer\",\n   *   schema: {\n   *     type: \"object\",\n   *     properties: {\n   *       name: { type: \"string\" },\n   *       age: { type: \"number\" },\n   *       skills: { type: \"array\", items: { type: \"string\" } },\n   *       experience: { type: \"number\" }\n   *     },\n   *     required: [\"name\", \"skills\"]\n   *   }\n   * });\n   * \n   * // Generate array of items\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"List 5 programming languages\",\n   *   output: \"array\",\n   *   schema: {\n   *     type: \"array\",\n   *     items: { type: \"string\" }\n   *   }\n   * });\n   * \n   * // Generate enum value\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"Choose the best programming language for web development\",\n   *   output: \"enum\",\n   *   enum: [\"JavaScript\", \"Python\", \"TypeScript\", \"Go\"]\n   * });\n   * ```\n   * \n   * @returns Promise<ObjectGenerationResponse> - Object containing:\n   *   - `object`: The generated and validated JSON object/array/enum\n   *   - `usage`: Token usage information\n   *   - `finishReason`: Why generation stopped\n   */\n  async generateObject(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const response = await this.httpClient.aiObject(\n        options.prompt,\n        {\n          model: options.model,\n          output: options.output,\n          schema: options.schema,\n          enum: options.enum,\n          stream: false,\n          signal: options.signal\n        }\n      );\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Object generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Streams structured object generation with real-time partial updates as the AI builds the object.\n   * \n   * @param options - Same as generateObject: prompt, schema, output type, etc.\n   * @param onPartial - Callback function that receives partial object updates as they're generated\n   * \n   * @example\n   * ```ts\n   * // Stream object generation with schema\n   * await blink.ai.streamObject(\n   *   {\n   *     prompt: \"Generate a detailed product catalog entry\",\n   *     schema: {\n   *       type: \"object\",\n   *       properties: {\n   *         name: { type: \"string\" },\n   *         price: { type: \"number\" },\n   *         description: { type: \"string\" },\n   *         features: { type: \"array\", items: { type: \"string\" } }\n   *       }\n   *     }\n   *   },\n   *   (partial) => {\n   *     console.log(\"Partial update:\", partial);\n   *     updateProductForm(partial); // Update UI in real-time\n   *   }\n   * );\n   * ```\n   * \n   * @returns Promise<ObjectGenerationResponse> - Final complete object with metadata\n   */\n  async streamObject(options, onPartial) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const result = await this.httpClient.streamAiObject(\n        options.prompt,\n        {\n          model: options.model,\n          output: options.output,\n          schema: options.schema,\n          enum: options.enum,\n          signal: options.signal\n        },\n        onPartial\n      );\n      return {\n        object: result.object || {},\n        finishReason: \"stop\",\n        usage: result.usage\n      };\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Object streaming failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates images from text descriptions using AI image models.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Text description of the desired image (required, up to 100k characters)\n   *   - `model`: AI model to use (optional). Available models:\n   *       **Fal.ai Models (Recommended):**\n   *       - `\"fal-ai/nano-banana\"` (default) - Gemini 2.5 Flash Image (Fast)\n   *       - `\"fal-ai/nano-banana-pro\"` - Gemini 3 Pro Image (High quality)\n   *       - `\"fal-ai/gemini-25-flash-image\"` - Alias for nano-banana\n   *       - `\"fal-ai/gemini-3-pro-image-preview\"` - Alias for nano-banana-pro\n   *       **Legacy Gemini Models:**\n   *       - `\"gemini-2.5-flash-image-preview\"` - Direct Gemini API\n   *       - `\"gemini-3-pro-image-preview\"` - Direct Gemini API\n   *   - `n`: Number of images to generate (default: 1)\n   *   - `size`: Image dimensions (e.g., \"1024x1024\", \"512x512\")\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Basic image generation (uses default fast model)\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A serene landscape with mountains and a lake at sunset\"\n   * });\n   * console.log(\"Image URL:\", data[0].url);\n   * \n   * // High quality generation with Pro model\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A detailed infographic about AI with charts and diagrams\",\n   *   model: \"fal-ai/nano-banana-pro\",\n   *   n: 2\n   * });\n   * \n   * // Fast generation with specific size\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A futuristic city skyline with flying cars\",\n   *   model: \"fal-ai/nano-banana\",\n   *   size: \"1024x1024\",\n   *   n: 3\n   * });\n   * data.forEach((img, i) => console.log(`Image ${i+1}:`, img.url));\n   * \n   * // Using legacy Gemini model\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A cute robot mascot for a tech company\",\n   *   model: \"gemini-2.5-flash-image-preview\"\n   * });\n   * ```\n   * \n   * @returns Promise<ImageGenerationResponse> - Object containing:\n   *   - `data`: Array of generated images with URLs\n   *   - `created`: Timestamp of generation\n   *   - `model`: The model used for generation\n   */\n  async generateImage(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const response = await this.httpClient.aiImage(\n        options.prompt,\n        {\n          model: options.model,\n          n: options.n,\n          size: options.size,\n          signal: options.signal\n        }\n      );\n      let imageResponse;\n      if (response.data?.result?.data) {\n        imageResponse = response.data.result;\n      } else if (response.data?.data) {\n        imageResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing image data\");\n      }\n      if (!Array.isArray(imageResponse.data)) {\n        throw new BlinkAIError(\"Invalid response format: data should be an array\");\n      }\n      imageResponse.data = imageResponse.data.map((item) => {\n        if (typeof item === \"string\") {\n          return { url: item };\n        } else if (item.url) {\n          return item;\n        } else {\n          throw new BlinkAIError(\"Invalid image response format\");\n        }\n      });\n      return imageResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Image generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Modifies existing images using AI image editing models with text prompts for image-to-image editing.\n   * \n   * @param options - Object containing:\n   *   - `images`: Array of public image URLs to modify (required, up to 50 images)\n   *   - `prompt`: Text description of desired modifications (required, up to 100k characters)\n   *   - `model`: AI model to use (optional). Available editing models:\n   *       **Fal.ai Editing Models (Recommended):**\n   *       - `\"fal-ai/nano-banana/edit\"` (default) - Flash editing (Fast)\n   *       - `\"fal-ai/nano-banana-pro/edit\"` - Pro editing (High quality)\n   *       - `\"fal-ai/gemini-25-flash-image/edit\"` - Alias for nano-banana/edit\n   *       - `\"fal-ai/gemini-3-pro-image-preview/edit\"` - Alias for nano-banana-pro/edit\n   *       **Legacy Gemini Models:**\n   *       - `\"gemini-2.5-flash-image-preview\"` - Direct Gemini API\n   *       - `\"gemini-3-pro-image-preview\"` - Direct Gemini API\n   *   - `n`: Number of output images to generate (default: 1)\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Fast editing with default model\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/photo.jpg\"],\n   *   prompt: \"make it green\"\n   * });\n   * \n   * // High quality editing with Pro model\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/landscape.jpg\"],\n   *   prompt: \"add a tree in the background\",\n   *   model: \"fal-ai/nano-banana-pro/edit\"\n   * });\n   * \n   * // Professional headshots from casual photos\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\n   *     \"https://storage.example.com/user-photo-1.jpg\",\n   *     \"https://storage.example.com/user-photo-2.jpg\"\n   *   ],\n   *   prompt: \"Transform into professional business headshots with studio lighting\",\n   *   model: \"fal-ai/nano-banana/edit\",\n   *   n: 4\n   * });\n   * data.forEach((img, i) => console.log(`Headshot ${i+1}:`, img.url));\n   * \n   * // Artistic style transformation\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/portrait.jpg\"],\n   *   prompt: \"Transform into oil painting style with dramatic lighting\",\n   *   model: \"fal-ai/nano-banana-pro/edit\"\n   * });\n   * \n   * // Background replacement\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/product.jpg\"],\n   *   prompt: \"Remove background and place on clean white studio background\",\n   *   n: 2\n   * });\n   * \n   * // Batch processing multiple photos\n   * const userPhotos = [\n   *   \"https://storage.example.com/photo1.jpg\",\n   *   \"https://storage.example.com/photo2.jpg\",\n   *   \"https://storage.example.com/photo3.jpg\"\n   * ];\n   * const { data } = await blink.ai.modifyImage({\n   *   images: userPhotos,\n   *   prompt: \"Convert to black and white vintage style photographs\"\n   * });\n   * \n   * //  Style Transfer - IMPORTANT: Provide all images in array\n   * //  WRONG - Don't reference other images in prompt\n   * const wrong = await blink.ai.modifyImage({\n   *   images: [userPhotoUrl],\n   *   prompt: `Apply hairstyle from ${referenceUrl}`\n   * });\n   * \n   * //  CORRECT - Provide all images in array\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [userPhotoUrl, hairstyleReferenceUrl],\n   *   prompt: \"Apply the hairstyle from the second image to the person in the first image\"\n   * });\n   * ```\n   * \n   * @returns Promise<ImageGenerationResponse> - Object containing:\n   *   - `data`: Array of modified images with URLs\n   *   - `created`: Timestamp of generation\n   *   - `model`: The model used for editing\n   */\n  async modifyImage(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      if (!options.images || !Array.isArray(options.images) || options.images.length === 0) {\n        throw new BlinkAIError(\"Images array is required and must contain at least one image URL\");\n      }\n      if (options.images.length > 50) {\n        throw new BlinkAIError(\"Maximum 50 images allowed\");\n      }\n      for (let i = 0; i < options.images.length; i++) {\n        const validation = this.validateImageUrl(options.images[i]);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Image ${i + 1}: ${validation.error}`);\n        }\n      }\n      const response = await this.httpClient.aiImage(\n        options.prompt,\n        // Non-null assertion since we validated above\n        {\n          model: options.model,\n          images: options.images,\n          n: options.n,\n          signal: options.signal\n        }\n      );\n      let imageResponse;\n      if (response.data?.result?.data) {\n        imageResponse = response.data.result;\n      } else if (response.data?.data) {\n        imageResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing image data\");\n      }\n      if (!Array.isArray(imageResponse.data)) {\n        throw new BlinkAIError(\"Invalid response format: data should be an array\");\n      }\n      imageResponse.data = imageResponse.data.map((item) => {\n        if (typeof item === \"string\") {\n          return { url: item };\n        } else if (item.url) {\n          return item;\n        } else {\n          throw new BlinkAIError(\"Invalid image response format\");\n        }\n      });\n      return imageResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Image modification failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates videos from text prompts or images using AI video generation models.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Text description of the video to generate (required)\n   *   - `model`: Video model to use (optional). Available models:\n   *       **Text-to-Video Models:**\n   *       - `\"fal-ai/veo3.1\"` - Google Veo 3.1 (best quality)\n   *       - `\"fal-ai/veo3.1/fast\"` (default) - Veo 3.1 fast mode (faster, cheaper)\n   *       - `\"fal-ai/sora-2/text-to-video/pro\"` - OpenAI Sora 2\n   *       - `\"fal-ai/kling-video/v2.6/pro/text-to-video\"` - Kling 2.6\n   *       **Image-to-Video Models:**\n   *       - `\"fal-ai/veo3.1/image-to-video\"` - Veo 3.1 I2V\n   *       - `\"fal-ai/veo3.1/fast/image-to-video\"` - Veo 3.1 fast I2V\n   *       - `\"fal-ai/sora-2/image-to-video/pro\"` - Sora 2 I2V\n   *       - `\"fal-ai/kling-video/v2.6/pro/image-to-video\"` - Kling 2.6 I2V\n   *   - `image_url`: Source image URL for image-to-video (required for I2V models)\n   *   - `duration`: Video duration (\"4s\", \"5s\", \"6s\", \"8s\", \"10s\", \"12s\")\n   *   - `aspect_ratio`: Aspect ratio (\"16:9\", \"9:16\", \"1:1\")\n   *   - `resolution`: Resolution (\"720p\", \"1080p\") - Veo/Sora only\n   *   - `negative_prompt`: What to avoid in generation - Veo/Kling only\n   *   - `generate_audio`: Generate audio with video (default: true)\n   *   - `seed`: For reproducibility - Veo only\n   *   - `cfg_scale`: Guidance scale (0-1) - Kling only\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Basic text-to-video generation (uses default fast model)\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"A serene sunset over the ocean with gentle waves\"\n   * });\n   * console.log(\"Video URL:\", result.video.url);\n   * \n   * // High quality with Veo 3.1\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"A cinematic shot of a futuristic city at night\",\n   *   model: \"fal-ai/veo3.1\",\n   *   resolution: \"1080p\",\n   *   aspect_ratio: \"16:9\"\n   * });\n   * \n   * // Image-to-video animation\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"Animate this image with gentle camera movement\",\n   *   model: \"fal-ai/veo3.1/fast/image-to-video\",\n   *   image_url: \"https://example.com/my-image.jpg\",\n   *   duration: \"5s\"\n   * });\n   * \n   * // Using Sora 2 for creative videos\n   * const { result } = await blink.ai.generateVideo({\n   *   prompt: \"A magical forest with glowing fireflies\",\n   *   model: \"fal-ai/sora-2/text-to-video/pro\",\n   *   duration: \"8s\"\n   * });\n   * \n   * // Using Kling for detailed videos\n   * const { result, usage } = await blink.ai.generateVideo({\n   *   prompt: \"A professional cooking tutorial scene\",\n   *   model: \"fal-ai/kling-video/v2.6/pro/text-to-video\",\n   *   negative_prompt: \"blur, distort, low quality\",\n   *   cfg_scale: 0.7\n   * });\n   * console.log(\"Credits charged:\", usage?.creditsCharged);\n   * ```\n   * \n   * @returns Promise<VideoGenerationResponse> - Object containing:\n   *   - `result.video.url`: URL to the generated video\n   *   - `result.video.content_type`: MIME type (video/mp4)\n   *   - `result.video.file_name`: Generated filename\n   *   - `result.video.file_size`: File size in bytes\n   *   - `metadata`: Generation metadata (projectId, timestamp, model)\n   *   - `usage`: Credits charged and cost information\n   */\n  async generateVideo(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const i2vModels = [\n        \"fal-ai/veo3.1/image-to-video\",\n        \"fal-ai/veo3.1/fast/image-to-video\",\n        \"fal-ai/sora-2/image-to-video/pro\",\n        \"fal-ai/kling-video/v2.6/pro/image-to-video\"\n      ];\n      if (options.model && i2vModels.includes(options.model) && !options.image_url) {\n        throw new BlinkAIError(\"image_url is required for image-to-video models\");\n      }\n      if (options.image_url) {\n        const validation = this.validateImageUrl(options.image_url);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Invalid image_url: ${validation.error}`);\n        }\n      }\n      const response = await this.httpClient.aiVideo(\n        options.prompt,\n        {\n          model: options.model,\n          image_url: options.image_url,\n          duration: options.duration,\n          aspect_ratio: options.aspect_ratio,\n          resolution: options.resolution,\n          negative_prompt: options.negative_prompt,\n          generate_audio: options.generate_audio,\n          seed: options.seed,\n          cfg_scale: options.cfg_scale,\n          signal: options.signal\n        }\n      );\n      if (!response.data?.result?.video?.url) {\n        throw new BlinkAIError(\"Invalid response format: missing video URL\");\n      }\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Video generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Converts text to speech using AI voice synthesis models.\n   * \n   * @param options - Object containing:\n   *   - `text`: Text content to convert to speech (required)\n   *   - `voice`: Voice to use (\"alloy\", \"echo\", \"fable\", \"onyx\", \"nova\", \"shimmer\")\n   *   - `response_format`: Audio format (\"mp3\", \"opus\", \"aac\", \"flac\", \"wav\", \"pcm\")\n   *   - `speed`: Speech speed (0.25 to 4.0, default: 1.0)\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Basic text-to-speech\n   * const { url } = await blink.ai.generateSpeech({\n   *   text: \"Hello, welcome to our AI-powered application!\"\n   * });\n   * console.log(\"Audio URL:\", url);\n   * \n   * // Custom voice and format\n   * const { url, voice, format } = await blink.ai.generateSpeech({\n   *   text: \"This is a demonstration of our speech synthesis capabilities.\",\n   *   voice: \"nova\",\n   *   response_format: \"wav\",\n   *   speed: 1.2\n   * });\n   * console.log(`Generated ${format} audio with ${voice} voice:`, url);\n   * \n   * // Slow, clear speech for accessibility\n   * const { url } = await blink.ai.generateSpeech({\n   *   text: \"Please listen carefully to these important instructions.\",\n   *   voice: \"echo\",\n   *   speed: 0.8\n   * });\n   * ```\n   * \n   * @returns Promise<SpeechGenerationResponse> - Object containing:\n   *   - `url`: URL to the generated audio file\n   *   - `voice`: Voice used for generation\n   *   - `format`: Audio format\n   *   - `mimeType`: MIME type of the audio\n   */\n  async generateSpeech(options) {\n    try {\n      if (!options.text) {\n        throw new BlinkAIError(\"Text is required\");\n      }\n      const response = await this.httpClient.aiSpeech(\n        options.text,\n        {\n          model: options.model,\n          voice: options.voice,\n          response_format: options.response_format,\n          speed: options.speed,\n          signal: options.signal\n        }\n      );\n      let speechResponse;\n      if (response.data?.result) {\n        speechResponse = response.data.result;\n      } else if (response.data?.url) {\n        speechResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing speech data\");\n      }\n      if (!speechResponse.url) {\n        if (typeof response.data === \"string\") {\n          speechResponse = {\n            url: response.data,\n            voice: options.voice || \"alloy\",\n            format: options.response_format || \"mp3\",\n            mimeType: this.getMimeTypeForFormat(options.response_format || \"mp3\")\n          };\n        } else if (response.data?.data) {\n          speechResponse = {\n            url: response.data.data,\n            voice: options.voice || \"alloy\",\n            format: options.response_format || \"mp3\",\n            mimeType: this.getMimeTypeForFormat(options.response_format || \"mp3\")\n          };\n        } else {\n          throw new BlinkAIError(\"Invalid response format: no audio URL found\");\n        }\n      }\n      if (!speechResponse.voice) {\n        speechResponse.voice = options.voice || \"alloy\";\n      }\n      if (!speechResponse.format) {\n        speechResponse.format = options.response_format || \"mp3\";\n      }\n      if (!speechResponse.mimeType) {\n        speechResponse.mimeType = this.getMimeTypeForFormat(speechResponse.format);\n      }\n      return speechResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Speech generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Transcribes audio content to text using AI speech recognition models.\n   * \n   * @param options - Object containing:\n   *   - `audio`: Audio input as URL string, base64 string, or number array buffer (required)\n   *   - `language`: Language code for transcription (e.g., \"en\", \"es\", \"fr\")\n   *   - `response_format`: Output format (\"json\", \"text\", \"srt\", \"verbose_json\", \"vtt\")\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Transcribe from URL\n   * const { text } = await blink.ai.transcribeAudio({\n   *   audio: \"https://example.com/meeting-recording.mp3\"\n   * });\n   * console.log(\"Transcription:\", text);\n   * \n   * // Transcribe with language hint\n   * const { text, language } = await blink.ai.transcribeAudio({\n   *   audio: \"https://example.com/spanish-audio.wav\",\n   *   language: \"es\"\n   * });\n   * console.log(`Transcribed ${language}:`, text);\n   * \n   * // Transcribe with timestamps (verbose format)\n   * const result = await blink.ai.transcribeAudio({\n   *   audio: audioFileUrl,\n   *   response_format: \"verbose_json\"\n   * });\n   * result.segments?.forEach(segment => {\n   *   console.log(`${segment.start}s - ${segment.end}s: ${segment.text}`);\n   * });\n   * \n   * // Transcribe from audio buffer\n   * const audioBuffer = new Array(1024).fill(0); // Your audio data\n   * const { text } = await blink.ai.transcribeAudio({\n   *   audio: audioBuffer,\n   *   language: \"en\"\n   * });\n   * ```\n   * \n   * @returns Promise<TranscriptionResponse> - Object containing:\n   *   - `text`: Transcribed text content\n   *   - `transcript`: Alias for text\n   *   - `segments`: Array of timestamped segments (if verbose format)\n   *   - `language`: Detected language\n   *   - `duration`: Audio duration in seconds\n   */\n  async transcribeAudio(options) {\n    try {\n      if (!options.audio) {\n        throw new BlinkAIError(\"Audio is required\");\n      }\n      const response = await this.httpClient.aiTranscribe(\n        options.audio,\n        {\n          model: options.model,\n          language: options.language,\n          response_format: options.response_format,\n          signal: options.signal\n        }\n      );\n      if (response.data?.result) {\n        return response.data.result;\n      } else if (response.data?.text || response.data?.transcript) {\n        return {\n          text: response.data.text || response.data.transcript,\n          transcript: response.data.transcript || response.data.text,\n          ...response.data\n        };\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing transcription text\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Audio transcription failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  async agent(options) {\n    try {\n      if (!options.agent?.model) {\n        throw new BlinkAIError(\"agent.model is required\");\n      }\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.prompt && options.messages) {\n        throw new BlinkAIError(\"prompt and messages are mutually exclusive\");\n      }\n      const serializedTools = options.agent.tools ? serializeTools(options.agent.tools) : void 0;\n      const requestBody = {\n        stream: options.stream,\n        agent: {\n          model: options.agent.model,\n          system: options.agent.system,\n          tools: serializedTools,\n          webhook_tools: options.agent.webhook_tools,\n          client_tools: options.agent.client_tools,\n          tool_choice: options.agent.tool_choice,\n          stop_when: options.agent.stop_when,\n          prepare_step: options.agent.prepare_step\n        }\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      } else if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      if (options.stream) {\n        return await this.httpClient.aiAgentStream(requestBody, options.signal);\n      } else {\n        const response = await this.httpClient.aiAgent(requestBody, options.signal);\n        return response.data;\n      }\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Agent request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  // ============================================================================\n  // Agent Factory\n  // ============================================================================\n  /**\n   * Creates a reusable Agent instance with the Vercel AI SDK pattern.\n   * \n   * The Agent can be used multiple times with different prompts:\n   * - `agent.generate({ prompt })` for non-streaming\n   * - `agent.stream({ prompt })` for streaming\n   * \n   * @param options - Agent configuration (model, tools, system, etc.)\n   * @returns Agent instance\n   * \n   * @example\n   * ```ts\n   * const weatherAgent = blink.ai.createAgent({\n   *   model: 'anthropic/claude-sonnet-4-20250514',\n   *   system: 'You are a helpful weather assistant.',\n   *   tools: [webSearch, fetchUrl],\n   *   maxSteps: 10,\n   * })\n   * \n   * // Non-streaming\n   * const result = await weatherAgent.generate({\n   *   prompt: 'What is the weather in San Francisco?',\n   * })\n   * \n   * // Streaming\n   * const stream = await weatherAgent.stream({\n   *   prompt: 'Tell me about weather patterns',\n   * })\n   * ```\n   */\n  createAgent(options) {\n    const agent = new Agent(options);\n    agent._setHttpClient(this.httpClient);\n    return agent;\n  }\n  /**\n   * Binds an existing Agent instance to this client's HTTP client.\n   * \n   * Used internally by useAgent() when an Agent instance is passed.\n   * This allows agents created with `new Agent()` to be used with the hook.\n   * \n   * @param agent - Existing Agent instance\n   * @returns The same Agent instance (with httpClient set)\n   */\n  bindAgent(agent) {\n    agent._setHttpClient(this.httpClient);\n    return agent;\n  }\n};\n\n// src/data.ts\nvar BlinkDataImpl = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  async extractFromUrl(url, options = {}) {\n    const { chunking = false, chunkSize } = options;\n    const request = { url, chunking, chunkSize };\n    const response = await this.httpClient.dataExtractFromUrl(this.projectId, request);\n    return chunking ? response.data.chunks : response.data.text;\n  }\n  async extractFromBlob(file, options = {}) {\n    const { chunking = false, chunkSize } = options;\n    const response = await this.httpClient.dataExtractFromBlob(this.projectId, file, chunking, chunkSize);\n    return chunking ? response.data.chunks : response.data.text;\n  }\n  async scrape(url) {\n    const request = {\n      url,\n      formats: [\"markdown\", \"html\", \"links\", \"extract\", \"metadata\"]\n    };\n    const response = await this.httpClient.dataScrape(this.projectId, request);\n    const data = response.data;\n    return {\n      markdown: data.markdown || \"\",\n      html: data.html || \"\",\n      metadata: {\n        title: data.metadata?.title || \"\",\n        description: data.metadata?.description || \"\",\n        url: data.metadata?.url || url,\n        domain: data.metadata?.domain || new URL(url).hostname,\n        favicon: data.metadata?.favicon,\n        image: data.metadata?.image,\n        author: data.metadata?.author,\n        publishedTime: data.metadata?.publishedTime,\n        modifiedTime: data.metadata?.modifiedTime,\n        type: data.metadata?.type,\n        siteName: data.metadata?.siteName,\n        locale: data.metadata?.locale,\n        keywords: data.metadata?.keywords || []\n      },\n      links: data.links || [],\n      extract: {\n        title: data.extract?.title || data.metadata?.title || \"\",\n        description: data.extract?.description || data.metadata?.description || \"\",\n        headings: data.extract?.headings || [],\n        text: data.extract?.text || data.markdown || \"\"\n      }\n    };\n  }\n  async screenshot(url, options = {}) {\n    const request = { url, ...options };\n    const response = await this.httpClient.dataScreenshot(this.projectId, request);\n    return response.data.url;\n  }\n  async fetch(request) {\n    const response = await this.httpClient.dataFetch(this.projectId, request);\n    if (\"status\" in response.data && \"headers\" in response.data) {\n      return response.data;\n    }\n    throw new BlinkDataError(\"Unexpected response format from fetch endpoint\");\n  }\n  async fetchAsync(request) {\n    const asyncRequest = { ...request, async: true };\n    const response = await this.httpClient.dataFetch(this.projectId, asyncRequest);\n    if (\"status\" in response.data && response.data.status === \"triggered\") {\n      return response.data;\n    }\n    throw new BlinkDataError(\"Unexpected response format from async fetch endpoint\");\n  }\n  async search(query, options) {\n    const normalizeType = (type) => {\n      switch (type) {\n        case \"news\":\n          return \"nws\";\n        case \"images\":\n        case \"image\":\n          return \"isch\";\n        case \"videos\":\n        case \"video\":\n          return \"vid\";\n        case \"shopping\":\n        case \"shop\":\n          return \"shop\";\n        default:\n          return void 0;\n      }\n    };\n    const request = {\n      q: query,\n      location: options?.location,\n      hl: options?.language || \"en\",\n      tbm: normalizeType(options?.type),\n      num: options?.limit\n    };\n    const response = await this.httpClient.dataSearch(this.projectId, request);\n    return response.data;\n  }\n};\n\n// src/realtime-connection.ts\nvar getWebSocketClass = () => {\n  if (typeof WebSocket !== \"undefined\") {\n    return WebSocket;\n  }\n  try {\n    const WS = __require(\"ws\");\n    return WS;\n  } catch (error) {\n    throw new BlinkRealtimeError('WebSocket is not available. Install \"ws\" package for Node.js environments.');\n  }\n};\nvar RealtimeConnection = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  websocket = null;\n  isConnected = false;\n  isConnecting = false;\n  reconnectTimer = null;\n  heartbeatTimer = null;\n  reconnectAttempts = 0;\n  connectionPromise = null;\n  // Channel management\n  channels = /* @__PURE__ */ new Map();\n  pendingSubscriptions = /* @__PURE__ */ new Map();\n  // Message queue for when socket not ready\n  messageQueue = [];\n  /**\n   * Check if connection is ready\n   */\n  isReady() {\n    return this.isConnected && this.websocket?.readyState === 1;\n  }\n  /**\n   * Ensure WebSocket connection is established\n   */\n  async connect() {\n    if (this.isConnected && this.websocket?.readyState === 1) {\n      return;\n    }\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n    this.connectionPromise = this.connectWebSocket();\n    try {\n      await this.connectionPromise;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n  /**\n   * Join a channel (subscribe)\n   */\n  async joinChannel(channelName, handler, options = {}) {\n    await this.connect();\n    this.channels.set(channelName, { handler, options });\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pendingSubscriptions.delete(channelName);\n        this.channels.delete(channelName);\n        reject(new BlinkRealtimeError(\"Subscription timeout - no acknowledgment from server\"));\n      }, 1e4);\n      this.pendingSubscriptions.set(channelName, { resolve, reject, timeout });\n      const subscribeMessage = {\n        type: \"subscribe\",\n        payload: {\n          channel: channelName,\n          userId: options.userId,\n          metadata: options.metadata\n        }\n      };\n      try {\n        this.sendRaw(JSON.stringify(subscribeMessage));\n      } catch (error) {\n        clearTimeout(timeout);\n        this.pendingSubscriptions.delete(channelName);\n        this.channels.delete(channelName);\n        reject(error);\n      }\n    });\n  }\n  /**\n   * Leave a channel (unsubscribe)\n   */\n  async leaveChannel(channelName) {\n    this.channels.delete(channelName);\n    const pending = this.pendingSubscriptions.get(channelName);\n    if (pending) {\n      clearTimeout(pending.timeout);\n      pending.reject(new BlinkRealtimeError(\"Subscription cancelled\"));\n      this.pendingSubscriptions.delete(channelName);\n    }\n    if (this.websocket && this.websocket.readyState === 1) {\n      const unsubscribeMessage = {\n        type: \"unsubscribe\",\n        payload: { channel: channelName }\n      };\n      this.websocket.send(JSON.stringify(unsubscribeMessage));\n    }\n    if (this.channels.size === 0) {\n      this.disconnect();\n    }\n  }\n  /**\n   * Send a message to a channel\n   */\n  async send(channelName, type, data, options = {}) {\n    await this.connect();\n    const publishMessage = {\n      type: \"publish\",\n      payload: {\n        channel: channelName,\n        type,\n        data,\n        userId: options.userId,\n        metadata: options.metadata\n      }\n    };\n    return this.sendWithResponse(JSON.stringify(publishMessage), channelName);\n  }\n  /**\n   * Disconnect and cleanup\n   */\n  disconnect() {\n    this.isConnected = false;\n    this.isConnecting = false;\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.messageQueue.forEach((q) => {\n      clearTimeout(q.timeout);\n      q.reject(new BlinkRealtimeError(\"Connection closed\"));\n    });\n    this.messageQueue = [];\n    this.pendingSubscriptions.forEach((pending, channel) => {\n      clearTimeout(pending.timeout);\n      pending.reject(new BlinkRealtimeError(\"Connection closed\"));\n    });\n    this.pendingSubscriptions.clear();\n    if (this.websocket) {\n      this.websocket.close();\n      this.websocket = null;\n    }\n  }\n  /**\n   * Get count of active channels\n   */\n  getChannelCount() {\n    return this.channels.size;\n  }\n  // Private methods\n  async connectWebSocket() {\n    if (this.websocket && this.websocket.readyState === 1) {\n      this.isConnected = true;\n      return;\n    }\n    if (this.isConnecting) {\n      return new Promise((resolve, reject) => {\n        const checkConnection = () => {\n          if (this.isConnected) {\n            resolve();\n          } else if (!this.isConnecting) {\n            reject(new BlinkRealtimeError(\"Connection failed\"));\n          } else {\n            setTimeout(checkConnection, 100);\n          }\n        };\n        checkConnection();\n      });\n    }\n    this.isConnecting = true;\n    this.isConnected = false;\n    return new Promise((resolve, reject) => {\n      try {\n        const httpClient = this.httpClient;\n        const coreUrl = httpClient.coreUrl || \"https://core.blink.new\";\n        const baseUrl = coreUrl.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\");\n        const wsUrl = `${baseUrl}?project_id=${this.projectId}`;\n        console.log(`\\u{1F517} Connecting to realtime: ${wsUrl}`);\n        const WSClass = getWebSocketClass();\n        this.websocket = new WSClass(wsUrl);\n        if (!this.websocket) {\n          this.isConnecting = false;\n          reject(new BlinkRealtimeError(\"Failed to create WebSocket instance\"));\n          return;\n        }\n        this.websocket.onopen = () => {\n          console.log(`\\u{1F517} Connected to realtime for project ${this.projectId}`);\n          this.isConnecting = false;\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n          this.startHeartbeat();\n          this.flushMessageQueue();\n          resolve();\n        };\n        this.websocket.onmessage = (event) => {\n          try {\n            const message = JSON.parse(event.data);\n            this.handleMessage(message);\n          } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n          }\n        };\n        this.websocket.onclose = () => {\n          console.log(`\\u{1F50C} Disconnected from realtime for project ${this.projectId}`);\n          this.isConnecting = false;\n          this.isConnected = false;\n          this.rejectQueuedMessages(new BlinkRealtimeError(\"WebSocket connection closed\"));\n          this.scheduleReconnect();\n        };\n        this.websocket.onerror = (error) => {\n          console.error(\"WebSocket error:\", error);\n          this.isConnecting = false;\n          this.isConnected = false;\n          reject(new BlinkRealtimeError(`WebSocket connection failed to ${wsUrl}`));\n        };\n        setTimeout(() => {\n          if (this.websocket?.readyState !== 1) {\n            this.isConnecting = false;\n            reject(new BlinkRealtimeError(\"WebSocket connection timeout\"));\n          }\n        }, 1e4);\n      } catch (error) {\n        this.isConnecting = false;\n        reject(new BlinkRealtimeError(`Failed to create WebSocket connection: ${error instanceof Error ? error.message : \"Unknown error\"}`));\n      }\n    });\n  }\n  handleMessage(message) {\n    const channelName = message.payload?.channel;\n    switch (message.type) {\n      case \"connected\":\n        console.log(`\\u2705 WebSocket connected: ${message.payload?.socketId}`);\n        break;\n      case \"subscribed\":\n        console.log(`\\u2705 Subscribed to channel: ${channelName}`);\n        const pendingSub = this.pendingSubscriptions.get(channelName);\n        if (pendingSub) {\n          clearTimeout(pendingSub.timeout);\n          pendingSub.resolve();\n          this.pendingSubscriptions.delete(channelName);\n        }\n        const subHandler = this.channels.get(channelName);\n        if (subHandler) {\n          subHandler.handler.onSubscribed();\n        }\n        break;\n      case \"message\":\n        const msgChannel = this.channels.get(message.payload?.channel);\n        if (msgChannel) {\n          msgChannel.handler.onMessage(message.payload);\n        }\n        break;\n      case \"presence\":\n        const presChannel = this.channels.get(message.payload?.channel);\n        if (presChannel) {\n          const users = message.payload?.data?.users || [];\n          presChannel.handler.onPresence(users);\n        }\n        break;\n      case \"published\":\n        break;\n      case \"pong\":\n        break;\n      case \"error\":\n        console.error(\"Realtime error:\", message.payload?.error);\n        const errChannel = this.channels.get(channelName);\n        if (errChannel) {\n          errChannel.handler.onError(message.payload?.error);\n        }\n        const pendingErr = this.pendingSubscriptions.get(channelName);\n        if (pendingErr) {\n          clearTimeout(pendingErr.timeout);\n          pendingErr.reject(new BlinkRealtimeError(`Subscription error: ${message.payload?.error}`));\n          this.pendingSubscriptions.delete(channelName);\n        }\n        break;\n      case \"unsubscribed\":\n        console.log(`\\u274C Unsubscribed from channel: ${channelName}`);\n        break;\n      default:\n        console.log(\"Unknown message type:\", message.type);\n    }\n  }\n  sendRaw(message) {\n    if (this.websocket && this.websocket.readyState === 1) {\n      this.websocket.send(message);\n    } else {\n      throw new BlinkRealtimeError(\"Cannot send message: WebSocket not connected\");\n    }\n  }\n  sendWithResponse(message, channelName) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const index = this.messageQueue.findIndex((q) => q.resolve === resolve);\n        if (index > -1) {\n          this.messageQueue.splice(index, 1);\n        }\n        reject(new BlinkRealtimeError(\"Message send timeout - no response from server\"));\n      }, 1e4);\n      if (this.websocket && this.websocket.readyState === 1) {\n        const handleResponse = (event) => {\n          try {\n            const response = JSON.parse(event.data);\n            if (response.type === \"published\" && response.payload.channel === channelName) {\n              clearTimeout(timeout);\n              this.websocket.removeEventListener(\"message\", handleResponse);\n              resolve(response.payload.messageId);\n            } else if (response.type === \"error\") {\n              clearTimeout(timeout);\n              this.websocket.removeEventListener(\"message\", handleResponse);\n              reject(new BlinkRealtimeError(`Server error: ${response.payload.error}`));\n            }\n          } catch (err) {\n          }\n        };\n        this.websocket.addEventListener(\"message\", handleResponse);\n        this.websocket.send(message);\n      } else {\n        this.messageQueue.push({ message, resolve, reject, timeout });\n      }\n    });\n  }\n  flushMessageQueue() {\n    if (!this.websocket || this.websocket.readyState !== 1) return;\n    const queue = [...this.messageQueue];\n    this.messageQueue = [];\n    queue.forEach((q) => {\n      try {\n        this.websocket.send(q.message);\n      } catch (error) {\n        clearTimeout(q.timeout);\n        q.reject(new BlinkRealtimeError(\"Failed to send queued message\"));\n      }\n    });\n  }\n  rejectQueuedMessages(error) {\n    const queue = [...this.messageQueue];\n    this.messageQueue = [];\n    queue.forEach((q) => {\n      clearTimeout(q.timeout);\n      q.reject(error);\n    });\n  }\n  startHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n    }\n    this.heartbeatTimer = globalThis.setInterval(() => {\n      if (this.websocket && this.websocket.readyState === 1) {\n        this.websocket.send(JSON.stringify({ type: \"ping\", payload: {} }));\n      }\n    }, 25e3);\n  }\n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    if (this.channels.size === 0) {\n      return;\n    }\n    this.reconnectAttempts++;\n    const baseDelay = Math.min(3e4, Math.pow(2, this.reconnectAttempts) * 1e3);\n    const jitter = Math.random() * 1e3;\n    const delay = baseDelay + jitter;\n    console.log(`\\u{1F504} Scheduling reconnect attempt ${this.reconnectAttempts} in ${Math.round(delay)}ms`);\n    this.reconnectTimer = globalThis.setTimeout(async () => {\n      if (this.channels.size === 0) return;\n      try {\n        await this.connectWebSocket();\n        await this.resubscribeAllChannels();\n      } catch (error) {\n        console.error(\"Reconnection failed:\", error);\n        this.scheduleReconnect();\n      }\n    }, delay);\n  }\n  async resubscribeAllChannels() {\n    console.log(`\\u{1F504} Resubscribing ${this.channels.size} channels...`);\n    for (const [channelName, subscription] of this.channels) {\n      try {\n        const subscribeMessage = {\n          type: \"subscribe\",\n          payload: {\n            channel: channelName,\n            userId: subscription.options.userId,\n            metadata: subscription.options.metadata\n          }\n        };\n        if (this.websocket && this.websocket.readyState === 1) {\n          this.websocket.send(JSON.stringify(subscribeMessage));\n        }\n      } catch (error) {\n        console.error(`Failed to resubscribe to ${channelName}:`, error);\n      }\n    }\n  }\n};\n\n// src/realtime.ts\nvar BlinkRealtimeChannel = class {\n  constructor(channelName, connection, httpClient, projectId) {\n    this.channelName = channelName;\n    this.connection = connection;\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  messageCallbacks = [];\n  presenceCallbacks = [];\n  isSubscribed = false;\n  subscribeOptions = {};\n  /**\n   * Check if channel is ready for publishing\n   */\n  isReady() {\n    return this.isSubscribed && this.connection.isReady();\n  }\n  async subscribe(options = {}) {\n    if (this.isSubscribed) {\n      return;\n    }\n    this.subscribeOptions = options;\n    const handler = {\n      onMessage: (message) => {\n        this.messageCallbacks.forEach((callback) => {\n          try {\n            callback(message);\n          } catch (error) {\n            console.error(\"Error in message callback:\", error);\n          }\n        });\n      },\n      onPresence: (users) => {\n        this.presenceCallbacks.forEach((callback) => {\n          try {\n            callback(users);\n          } catch (error) {\n            console.error(\"Error in presence callback:\", error);\n          }\n        });\n      },\n      onSubscribed: () => {\n        this.isSubscribed = true;\n      },\n      onError: (error) => {\n        console.error(`Channel ${this.channelName} error:`, error);\n      }\n    };\n    await this.connection.joinChannel(this.channelName, handler, options);\n    this.isSubscribed = true;\n  }\n  async unsubscribe() {\n    if (!this.isSubscribed) {\n      return;\n    }\n    await this.connection.leaveChannel(this.channelName);\n    this.cleanup();\n  }\n  async publish(type, data, options = {}) {\n    return this.connection.send(this.channelName, type, data, options);\n  }\n  onMessage(callback) {\n    this.messageCallbacks.push(callback);\n    return () => {\n      const index = this.messageCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.messageCallbacks.splice(index, 1);\n      }\n    };\n  }\n  onPresence(callback) {\n    this.presenceCallbacks.push(callback);\n    return () => {\n      const index = this.presenceCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.presenceCallbacks.splice(index, 1);\n      }\n    };\n  }\n  async getPresence() {\n    try {\n      const response = await this.httpClient.realtimeGetPresence(this.projectId, this.channelName);\n      return response.data.users || [];\n    } catch (error) {\n      throw new BlinkRealtimeError(\n        `Failed to get presence for channel ${this.channelName}: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  async getMessages(options = {}) {\n    try {\n      const response = await this.httpClient.realtimeGetMessages(this.projectId, {\n        channel: this.channelName,\n        limit: options.limit,\n        start: options.after || \"-\",\n        end: options.before || \"+\"\n      });\n      return response.data.messages || [];\n    } catch (error) {\n      throw new BlinkRealtimeError(\n        `Failed to get messages for channel ${this.channelName}: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  cleanup() {\n    this.isSubscribed = false;\n    this.subscribeOptions = {};\n    this.messageCallbacks = [];\n    this.presenceCallbacks = [];\n  }\n};\nvar BlinkRealtimeImpl = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n    this.connection = new RealtimeConnection(httpClient, projectId);\n  }\n  connection;\n  channels = /* @__PURE__ */ new Map();\n  handlers = {};\n  channel(name) {\n    if (!this.channels.has(name)) {\n      this.channels.set(name, new BlinkRealtimeChannel(name, this.connection, this.httpClient, this.projectId));\n    }\n    return this.channels.get(name);\n  }\n  async subscribe(channelName, callback, options = {}) {\n    const channel = this.channel(channelName);\n    await channel.subscribe(options);\n    const state = this.handlers[channelName] ??= {\n      msgHandlers: /* @__PURE__ */ new Set(),\n      presHandlers: /* @__PURE__ */ new Set(),\n      subscribed: true\n    };\n    state.msgHandlers.add(callback);\n    const messageUnsub = channel.onMessage(callback);\n    return () => {\n      messageUnsub();\n      state.msgHandlers.delete(callback);\n      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {\n        channel.unsubscribe();\n        delete this.handlers[channelName];\n      }\n    };\n  }\n  async publish(channelName, type, data, options = {}) {\n    const channel = this.channel(channelName);\n    return channel.publish(type, data, options);\n  }\n  async presence(channelName) {\n    const channel = this.channel(channelName);\n    return channel.getPresence();\n  }\n  onPresence(channelName, callback) {\n    const channel = this.channel(channelName);\n    const state = this.handlers[channelName] ??= {\n      msgHandlers: /* @__PURE__ */ new Set(),\n      presHandlers: /* @__PURE__ */ new Set(),\n      subscribed: false\n    };\n    state.presHandlers.add(callback);\n    const presenceUnsub = channel.onPresence(callback);\n    return () => {\n      presenceUnsub();\n      state.presHandlers.delete(callback);\n      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {\n        channel.unsubscribe();\n        delete this.handlers[channelName];\n      }\n    };\n  }\n  /**\n   * Get the number of active WebSocket connections (should always be 0 or 1)\n   */\n  getConnectionCount() {\n    return this.connection.isReady() ? 1 : 0;\n  }\n  /**\n   * Get the number of active channels\n   */\n  getChannelCount() {\n    return this.connection.getChannelCount();\n  }\n};\n\n// src/notifications.ts\nvar BlinkNotificationsImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  /**\n   * Sends an email using the Blink Notifications API.\n   *\n   * @param params - An object containing the details for the email.\n   *   - `to`: The recipient's email address or an array of addresses.\n   *   - `subject`: The subject line of the email.\n   *   - `html`: The HTML body of the email. For best results across all email\n   *             clients (like Gmail, Outlook), use inline CSS and table-based layouts.\n   *   - `text`: A plain-text version of the email body (optional).\n   *   - `from`: A custom sender name (e.g., \"Acme Inc\"). The email address will\n   *             be auto-generated by the project (e.g., \"noreply@project.blink-email.com\").\n   *   - `replyTo`: An email address for recipients to reply to (optional).\n   *   - `cc`: A CC recipient's email address or an array of addresses (optional).\n   *   - `bcc`: A BCC recipient's email address or an array of addresses (optional).\n   *   - `attachments`: An array of objects for files to attach, each with a `url`.\n   *                    The file at the URL will be fetched and attached by the server.\n   *\n   * @example\n   * ```ts\n   * // Send a simple email\n   * const { success, messageId } = await blink.notifications.email({\n   *   to: 'customer@example.com',\n   *   subject: 'Your order has shipped!',\n   *   html: '<h1>Order Confirmation</h1><p>Your order #12345 is on its way.</p>'\n   * });\n   *\n   * // Send an email with attachments and a custom from name\n   * const { success } = await blink.notifications.email({\n   *   to: ['team@example.com', 'manager@example.com'],\n   *   subject: 'New Invoice',\n   *   from: 'Blink Invoicing',\n   *   html: '<p>Please find the invoice attached.</p>',\n   *   attachments: [\n   *     { url: 'https://example.com/invoice.pdf', filename: 'invoice.pdf' }\n   *   ]\n   * });\n   * ```\n   *\n   * @returns A promise that resolves with an object containing the status of the email send.\n   *   - `success`: A boolean indicating if the email was sent successfully.\n   *   - `messageId`: The unique ID of the message from the email provider.\n   */\n  async email(params) {\n    try {\n      if (!params.to || !params.subject || !params.html && !params.text) {\n        throw new BlinkNotificationsError('The \"to\", \"subject\", and either \"html\" or \"text\" fields are required.');\n      }\n      const response = await this.httpClient.post(`/api/notifications/${this.httpClient.projectId}/email`, params);\n      if (!response.data || typeof response.data.success !== \"boolean\") {\n        throw new BlinkNotificationsError(\"Invalid response from email API\");\n      }\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkNotificationsError) {\n        throw error;\n      }\n      const errorMessage = error.response?.data?.error?.message || error.message || \"An unknown error occurred\";\n      throw new BlinkNotificationsError(`Failed to send email: ${errorMessage}`, error.response?.status, error.response?.data?.error);\n    }\n  }\n};\n\n// src/analytics.ts\nvar SESSION_DURATION = 30 * 60 * 1e3;\nvar MAX_BATCH_SIZE = 10;\nvar BATCH_TIMEOUT = 3e3;\nvar MAX_STRING_LENGTH = 256;\nvar BlinkAnalyticsImpl = class {\n  httpClient;\n  projectId;\n  queue = [];\n  timer = null;\n  enabled = true;\n  userId = null;\n  userEmail = null;\n  hasTrackedPageview = false;\n  utmParams = {};\n  persistedAttribution = {};\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n    if (!isWeb) {\n      this.enabled = false;\n      return;\n    }\n    if (navigator.doNotTrack === \"1\") {\n      this.enabled = false;\n      return;\n    }\n    this.loadPersistedAttribution();\n    this.captureUTMParams();\n    this.loadQueue();\n    this.trackPageview();\n    this.setupRouteChangeListener();\n    this.setupUnloadListener();\n  }\n  /**\n   * Generate project-scoped storage key for analytics\n   */\n  getStorageKey(suffix) {\n    return `blinkAnalytics${suffix}_${this.projectId}`;\n  }\n  /**\n   * Log a custom analytics event\n   */\n  log(eventName, data = {}) {\n    if (!this.enabled || !isWeb) {\n      return;\n    }\n    const event = this.buildEvent(eventName, data);\n    this.enqueue(event);\n  }\n  /**\n   * Disable analytics tracking\n   */\n  disable() {\n    this.enabled = false;\n    this.clearTimer();\n  }\n  /**\n   * Cleanup analytics instance (remove from global tracking)\n   */\n  destroy() {\n    this.disable();\n    if (typeof window !== \"undefined\") {\n      window.__blinkAnalyticsInstances?.delete(this);\n    }\n  }\n  /**\n   * Enable analytics tracking\n   */\n  enable() {\n    this.enabled = true;\n  }\n  /**\n   * Check if analytics is enabled\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Set the user ID for analytics events\n   */\n  setUserId(userId) {\n    this.userId = userId;\n  }\n  /**\n   * Set the user email for analytics events\n   */\n  setUserEmail(email) {\n    this.userEmail = email;\n  }\n  /**\n   * Clear persisted attribution data\n   */\n  clearAttribution() {\n    this.persistedAttribution = {};\n    try {\n      localStorage.removeItem(this.getStorageKey(\"Attribution\"));\n    } catch {\n    }\n  }\n  // Private methods\n  buildEvent(type, data = {}) {\n    const sessionId = this.getOrCreateSessionId();\n    const channel = this.detectChannel();\n    return {\n      type,\n      timestamp: (/* @__PURE__ */ new Date()).toISOString(),\n      project_id: this.projectId,\n      user_id: this.userId,\n      user_email: this.userEmail,\n      session_id: sessionId,\n      pathname: getLocationPathname(),\n      referrer: getDocumentReferrer(),\n      screen_width: getWindowInnerWidth(),\n      channel,\n      utm_source: this.utmParams.utm_source || this.persistedAttribution.utm_source || null,\n      utm_medium: this.utmParams.utm_medium || this.persistedAttribution.utm_medium || null,\n      utm_campaign: this.utmParams.utm_campaign || this.persistedAttribution.utm_campaign || null,\n      utm_content: this.utmParams.utm_content || this.persistedAttribution.utm_content || null,\n      utm_term: this.utmParams.utm_term || this.persistedAttribution.utm_term || null,\n      ...this.sanitizeData(data)\n    };\n  }\n  sanitizeData(data) {\n    if (typeof data === \"string\") {\n      return data.length > MAX_STRING_LENGTH ? data.slice(0, MAX_STRING_LENGTH - 3) + \"...\" : data;\n    }\n    if (typeof data === \"object\" && data !== null) {\n      const result = {};\n      for (const key in data) {\n        result[key] = this.sanitizeData(data[key]);\n      }\n      return result;\n    }\n    return data;\n  }\n  enqueue(event) {\n    this.queue.push(event);\n    this.persistQueue();\n    if (this.queue.length >= MAX_BATCH_SIZE) {\n      this.flush();\n    } else if (!this.timer) {\n      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n    }\n  }\n  async flush() {\n    this.clearTimer();\n    if (this.queue.length === 0) {\n      return;\n    }\n    const events = this.queue.slice(0, MAX_BATCH_SIZE);\n    this.queue = this.queue.slice(MAX_BATCH_SIZE);\n    this.persistQueue();\n    try {\n      await this.httpClient.post(`/api/analytics/${this.projectId}/log`, { events });\n    } catch (error) {\n      this.queue = [...events, ...this.queue];\n      this.persistQueue();\n    }\n    if (this.queue.length > 0) {\n      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n    }\n  }\n  clearTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n  }\n  getOrCreateSessionId() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Session\"));\n      if (stored) {\n        const session = JSON.parse(stored);\n        const now = Date.now();\n        if (now - session.lastActivityAt > SESSION_DURATION) {\n          return this.createNewSession();\n        }\n        session.lastActivityAt = now;\n        localStorage.setItem(this.getStorageKey(\"Session\"), JSON.stringify(session));\n        return session.id;\n      }\n      return this.createNewSession();\n    } catch {\n      return null;\n    }\n  }\n  createNewSession() {\n    const now = Date.now();\n    const randomId = Math.random().toString(36).substring(2, 10);\n    const session = {\n      id: `sess_${now}_${randomId}`,\n      startedAt: now,\n      lastActivityAt: now\n    };\n    try {\n      localStorage.setItem(this.getStorageKey(\"Session\"), JSON.stringify(session));\n    } catch {\n    }\n    return session.id;\n  }\n  loadQueue() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Queue\"));\n      if (stored) {\n        this.queue = JSON.parse(stored);\n        if (this.queue.length > 0) {\n          this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n        }\n      }\n    } catch {\n      this.queue = [];\n    }\n  }\n  persistQueue() {\n    try {\n      if (this.queue.length === 0) {\n        localStorage.removeItem(this.getStorageKey(\"Queue\"));\n      } else {\n        localStorage.setItem(this.getStorageKey(\"Queue\"), JSON.stringify(this.queue));\n      }\n    } catch {\n    }\n  }\n  trackPageview() {\n    if (!this.hasTrackedPageview) {\n      this.log(\"pageview\");\n      this.hasTrackedPageview = true;\n    }\n  }\n  setupRouteChangeListener() {\n    if (!isWeb) return;\n    if (!window.__blinkAnalyticsSetup) {\n      const originalPushState = history.pushState;\n      const originalReplaceState = history.replaceState;\n      const analyticsInstances = /* @__PURE__ */ new Set();\n      window.__blinkAnalyticsInstances = analyticsInstances;\n      history.pushState = (...args) => {\n        originalPushState.apply(history, args);\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      };\n      history.replaceState = (...args) => {\n        originalReplaceState.apply(history, args);\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      };\n      window.addEventListener(\"popstate\", () => {\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      });\n      window.__blinkAnalyticsSetup = true;\n    }\n    window.__blinkAnalyticsInstances?.add(this);\n  }\n  setupUnloadListener() {\n    if (!isWeb || !hasWindow()) return;\n    window.addEventListener(\"pagehide\", () => {\n      this.flush();\n    });\n    window.addEventListener(\"unload\", () => {\n      this.flush();\n    });\n  }\n  captureUTMParams() {\n    if (!isWeb) return;\n    const search = getLocationSearch();\n    if (!search) {\n      this.utmParams = {};\n      return;\n    }\n    const urlParams = new URLSearchParams(search);\n    this.utmParams = {\n      utm_source: urlParams.get(\"utm_source\"),\n      utm_medium: urlParams.get(\"utm_medium\"),\n      utm_campaign: urlParams.get(\"utm_campaign\"),\n      utm_content: urlParams.get(\"utm_content\"),\n      utm_term: urlParams.get(\"utm_term\")\n    };\n    const hasNewParams = Object.values(this.utmParams).some((v) => v !== null);\n    if (hasNewParams) {\n      this.persistAttribution();\n    }\n  }\n  loadPersistedAttribution() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Attribution\"));\n      if (stored) {\n        this.persistedAttribution = JSON.parse(stored);\n      }\n    } catch {\n      this.persistedAttribution = {};\n    }\n  }\n  persistAttribution() {\n    try {\n      const attribution = {\n        ...this.persistedAttribution,\n        ...Object.fromEntries(\n          Object.entries(this.utmParams).filter(([_, v]) => v !== null)\n        )\n      };\n      localStorage.setItem(this.getStorageKey(\"Attribution\"), JSON.stringify(attribution));\n      this.persistedAttribution = attribution;\n    } catch {\n    }\n  }\n  detectChannel() {\n    const referrer = getDocumentReferrer();\n    const utmMedium = this.utmParams.utm_medium;\n    this.utmParams.utm_source;\n    if (utmMedium) {\n      if (utmMedium === \"cpc\" || utmMedium === \"ppc\") return \"Paid Search\";\n      if (utmMedium === \"email\") return \"Email\";\n      if (utmMedium === \"social\") return \"Social\";\n      if (utmMedium === \"referral\") return \"Referral\";\n      if (utmMedium === \"display\") return \"Display\";\n      if (utmMedium === \"affiliate\") return \"Affiliate\";\n    }\n    if (!referrer) return \"Direct\";\n    try {\n      const referrerUrl = new URL(referrer);\n      const referrerDomain = referrerUrl.hostname.toLowerCase();\n      if (/google\\.|bing\\.|yahoo\\.|duckduckgo\\.|baidu\\.|yandex\\./.test(referrerDomain)) {\n        return \"Organic Search\";\n      }\n      if (/facebook\\.|twitter\\.|linkedin\\.|instagram\\.|youtube\\.|tiktok\\.|reddit\\./.test(referrerDomain)) {\n        return \"Social\";\n      }\n      if (/mail\\.|outlook\\.|gmail\\./.test(referrerDomain)) {\n        return \"Email\";\n      }\n      return \"Referral\";\n    } catch {\n      return \"Direct\";\n    }\n  }\n};\n\n// src/connectors.ts\nvar BlinkConnectorsImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  async status(provider, options) {\n    const response = await this.httpClient.connectorStatus(provider);\n    return response.data;\n  }\n  async execute(provider, request) {\n    const response = await this.httpClient.connectorExecute(provider, request);\n    return response.data;\n  }\n  async saveApiKey(provider, request) {\n    const response = await this.httpClient.connectorSaveApiKey(provider, request);\n    return response.data;\n  }\n};\n\n// src/functions.ts\nvar BlinkFunctionsImpl = class {\n  httpClient;\n  projectId;\n  constructor(httpClient, projectId, _getToken) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  /**\n   * Get the project suffix from the full project ID.\n   * Project IDs are formatted as: prj_xxxxx\n   * The suffix is the last 8 characters used in function URLs.\n   */\n  getProjectSuffix() {\n    return this.projectId.slice(-8);\n  }\n  /**\n   * Build the full function URL\n   */\n  buildFunctionUrl(functionSlug, searchParams) {\n    const suffix = this.getProjectSuffix();\n    const baseUrl = `https://${suffix}--${functionSlug}.functions.blink.new`;\n    if (!searchParams || Object.keys(searchParams).length === 0) {\n      return baseUrl;\n    }\n    const url = new URL(baseUrl);\n    Object.entries(searchParams).forEach(([key, value]) => {\n      url.searchParams.set(key, value);\n    });\n    return url.toString();\n  }\n  async invoke(functionSlug, options = {}) {\n    const { method = \"POST\", body, headers = {}, searchParams } = options;\n    const url = this.buildFunctionUrl(functionSlug, searchParams);\n    const res = await this.httpClient.request(url, { method, body, headers });\n    return { data: res.data, status: res.status, headers: res.headers };\n  }\n};\n\n// src/rag.ts\nfunction removeUndefined(obj) {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, v]) => v !== void 0)\n  );\n}\nfunction convertCollection(api) {\n  return {\n    id: api.id,\n    name: api.name,\n    description: api.description,\n    embeddingModel: api.embedding_model,\n    embeddingDimensions: api.embedding_dimensions,\n    indexMetric: api.index_metric,\n    chunkMaxTokens: api.chunk_max_tokens,\n    chunkOverlapTokens: api.chunk_overlap_tokens,\n    documentCount: api.document_count,\n    chunkCount: api.chunk_count,\n    shared: api.shared,\n    createdAt: api.created_at,\n    updatedAt: api.updated_at\n  };\n}\nfunction convertDocument(api) {\n  return {\n    id: api.id,\n    collectionId: api.collection_id,\n    filename: api.filename,\n    sourceType: api.source_type,\n    sourceUrl: api.source_url,\n    contentType: api.content_type,\n    fileSize: api.file_size,\n    status: api.status,\n    errorMessage: api.error_message,\n    processingStartedAt: api.processing_started_at,\n    processingCompletedAt: api.processing_completed_at,\n    chunkCount: api.chunk_count,\n    tokenCount: api.token_count,\n    metadata: api.metadata,\n    createdAt: api.created_at,\n    updatedAt: api.updated_at\n  };\n}\nfunction convertPartialDocument(api, options) {\n  let sourceType = \"text\";\n  if (options.url) sourceType = \"url\";\n  if (options.file) sourceType = \"file\";\n  return {\n    id: api.id || \"\",\n    collectionId: api.collection_id || options.collectionId || \"\",\n    filename: api.filename || options.filename,\n    sourceType: api.source_type || sourceType,\n    sourceUrl: api.source_url ?? options.url ?? null,\n    contentType: api.content_type ?? options.file?.contentType ?? null,\n    fileSize: api.file_size ?? null,\n    status: api.status || \"pending\",\n    errorMessage: api.error_message ?? null,\n    processingStartedAt: api.processing_started_at ?? null,\n    processingCompletedAt: api.processing_completed_at ?? null,\n    chunkCount: api.chunk_count ?? 0,\n    tokenCount: api.token_count ?? null,\n    metadata: api.metadata || options.metadata || {},\n    createdAt: api.created_at || (/* @__PURE__ */ new Date()).toISOString(),\n    updatedAt: api.updated_at || api.created_at || (/* @__PURE__ */ new Date()).toISOString()\n  };\n}\nfunction convertSearchResult(api) {\n  return {\n    chunkId: api.chunk_id,\n    documentId: api.document_id,\n    filename: api.filename,\n    content: api.content,\n    score: api.score,\n    chunkIndex: api.chunk_index,\n    metadata: api.metadata\n  };\n}\nfunction convertSearchResponse(api) {\n  return {\n    results: api.results.map(convertSearchResult),\n    query: api.query,\n    collectionId: api.collection_id,\n    totalResults: api.total_results\n  };\n}\nfunction convertAISearchSource(api) {\n  return {\n    documentId: api.document_id,\n    filename: api.filename,\n    chunkId: api.chunk_id,\n    excerpt: api.excerpt,\n    score: api.score\n  };\n}\nfunction convertAISearchResult(api) {\n  return {\n    answer: api.answer,\n    sources: api.sources.map(convertAISearchSource),\n    query: api.query,\n    model: api.model,\n    usage: {\n      inputTokens: api.usage.input_tokens,\n      outputTokens: api.usage.output_tokens\n    }\n  };\n}\nvar BlinkRAGImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    this.projectId = httpClient.projectId;\n  }\n  projectId;\n  /**\n   * Build URL with project_id prefix\n   */\n  url(path) {\n    return `/api/rag/${this.projectId}${path}`;\n  }\n  // ============================================================================\n  // Collections\n  // ============================================================================\n  /**\n   * Create a new RAG collection\n   */\n  async createCollection(options) {\n    const body = removeUndefined({\n      name: options.name,\n      description: options.description,\n      embedding_model: options.embeddingModel,\n      embedding_dimensions: options.embeddingDimensions,\n      index_metric: options.indexMetric,\n      chunk_max_tokens: options.chunkMaxTokens,\n      chunk_overlap_tokens: options.chunkOverlapTokens,\n      shared: options.shared\n    });\n    const response = await this.httpClient.post(this.url(\"/collections\"), body);\n    return convertCollection(response.data);\n  }\n  /**\n   * List all collections accessible to the current user\n   */\n  async listCollections() {\n    const response = await this.httpClient.get(this.url(\"/collections\"));\n    return response.data.collections.map(convertCollection);\n  }\n  /**\n   * Get a specific collection by ID\n   */\n  async getCollection(collectionId) {\n    const response = await this.httpClient.get(this.url(`/collections/${collectionId}`));\n    return convertCollection(response.data);\n  }\n  /**\n   * Delete a collection and all its documents\n   */\n  async deleteCollection(collectionId) {\n    await this.httpClient.delete(this.url(`/collections/${collectionId}`));\n  }\n  // ============================================================================\n  // Documents\n  // ============================================================================\n  /**\n   * Upload a document for processing\n   * \n   * @example\n   * // Upload text content\n   * const doc = await blink.rag.upload({\n   *   collectionName: 'docs',\n   *   filename: 'notes.txt',\n   *   content: 'My document content...'\n   * })\n   * \n   * @example\n   * // Upload from URL\n   * const doc = await blink.rag.upload({\n   *   collectionId: 'col_abc123',\n   *   filename: 'article.html',\n   *   url: 'https://example.com/article'\n   * })\n   * \n   * @example\n   * // Upload a file (base64)\n   * const doc = await blink.rag.upload({\n   *   collectionName: 'docs',\n   *   filename: 'report.pdf',\n   *   file: { data: base64Data, contentType: 'application/pdf' }\n   * })\n   */\n  async upload(options) {\n    if (!options.collectionId && !options.collectionName) {\n      throw new Error(\"collectionId or collectionName is required\");\n    }\n    const body = removeUndefined({\n      collection_id: options.collectionId,\n      collection_name: options.collectionName,\n      filename: options.filename,\n      content: options.content,\n      url: options.url,\n      metadata: options.metadata\n    });\n    if (options.file) {\n      body.file = {\n        data: options.file.data,\n        content_type: options.file.contentType\n      };\n    }\n    const response = await this.httpClient.post(this.url(\"/documents\"), body);\n    return convertPartialDocument(response.data, options);\n  }\n  /**\n   * Get document status and metadata\n   */\n  async getDocument(documentId) {\n    const response = await this.httpClient.get(this.url(`/documents/${documentId}`));\n    return convertDocument(response.data);\n  }\n  /**\n   * List documents, optionally filtered by collection or status\n   */\n  async listDocuments(options) {\n    const params = {};\n    if (options?.collectionId) params.collection_id = options.collectionId;\n    if (options?.status) params.status = options.status;\n    const queryString = Object.keys(params).length > 0 ? `?${new URLSearchParams(params).toString()}` : \"\";\n    const response = await this.httpClient.get(\n      this.url(`/documents${queryString}`)\n    );\n    return response.data.documents.map(convertDocument);\n  }\n  /**\n   * Delete a document and its chunks\n   */\n  async deleteDocument(documentId) {\n    await this.httpClient.delete(this.url(`/documents/${documentId}`));\n  }\n  /**\n   * Wait for a document to finish processing\n   * \n   * @example\n   * const doc = await blink.rag.upload({ ... })\n   * const readyDoc = await blink.rag.waitForReady(doc.id)\n   * console.log(`Processed ${readyDoc.chunkCount} chunks`)\n   */\n  async waitForReady(documentId, options) {\n    const { timeoutMs = 12e4, pollIntervalMs = 2e3 } = options || {};\n    const start = Date.now();\n    while (Date.now() - start < timeoutMs) {\n      const doc = await this.getDocument(documentId);\n      if (doc.status === \"ready\") {\n        return doc;\n      }\n      if (doc.status === \"error\") {\n        throw new Error(`Document processing failed: ${doc.errorMessage}`);\n      }\n      await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\n    }\n    throw new Error(`Document processing timeout after ${timeoutMs}ms`);\n  }\n  // ============================================================================\n  // Search\n  // ============================================================================\n  /**\n   * Search for similar chunks using vector similarity\n   * \n   * @example\n   * const results = await blink.rag.search({\n   *   collectionName: 'docs',\n   *   query: 'How do I configure authentication?',\n   *   maxResults: 5\n   * })\n   */\n  async search(options) {\n    if (!options.collectionId && !options.collectionName) {\n      throw new Error(\"collectionId or collectionName is required\");\n    }\n    const body = removeUndefined({\n      collection_id: options.collectionId,\n      collection_name: options.collectionName,\n      query: options.query,\n      max_results: options.maxResults,\n      score_threshold: options.scoreThreshold,\n      filters: options.filters,\n      include_content: options.includeContent\n    });\n    const response = await this.httpClient.post(this.url(\"/search\"), body);\n    return convertSearchResponse(response.data);\n  }\n  async aiSearch(options) {\n    if (!options.collectionId && !options.collectionName) {\n      throw new Error(\"collectionId or collectionName is required\");\n    }\n    const body = removeUndefined({\n      collection_id: options.collectionId,\n      collection_name: options.collectionName,\n      query: options.query,\n      model: options.model,\n      max_context_chunks: options.maxContextChunks,\n      score_threshold: options.scoreThreshold,\n      system_prompt: options.systemPrompt,\n      stream: options.stream\n    });\n    if (options.stream) {\n      const response2 = await this.httpClient.ragAiSearchStream(body, options.signal);\n      return response2.body;\n    }\n    const response = await this.httpClient.post(this.url(\"/ai-search\"), body);\n    return convertAISearchResult(response.data);\n  }\n};\n\n// src/sandbox.ts\nvar SANDBOX_TEMPLATES = [\n  \"devtools-base\",\n  // Node 22 + Bun + Python + Git + ripgrep (DEFAULT)\n  \"nextjs-app\",\n  // Next.js + Tailwind + shadcn UI (Node)\n  \"nextjs-app-bun\",\n  // Next.js + Tailwind + shadcn UI (Bun)\n  \"vite-react\",\n  // Vite + React + Tailwind + shadcn (Node)\n  \"vite-react-bun\",\n  // Vite + React + Tailwind + shadcn (Bun)\n  \"expo-app\",\n  // Expo + React Native\n  \"desktop\",\n  // Electron + Vite + React\n  \"claude-code\"\n  // Node 21 + Python + Git + ripgrep\n];\nvar SandboxConnectionError = class extends Error {\n  sandboxId;\n  constructor(sandboxId, cause) {\n    super(`Failed to connect to sandbox ${sandboxId}`);\n    this.name = \"SandboxConnectionError\";\n    this.sandboxId = sandboxId;\n    if (cause) {\n      this.cause = cause;\n    }\n  }\n};\nvar SandboxImpl = class {\n  constructor(id, template, hostPattern) {\n    this.id = id;\n    this.template = template;\n    this.hostPattern = hostPattern;\n  }\n  getHost(port) {\n    return this.hostPattern.replace(\"{port}\", String(port));\n  }\n};\nvar MAX_RETRIES = 3;\nvar INITIAL_RETRY_DELAY_MS = 250;\nvar BlinkSandboxImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    this.projectId = httpClient.projectId;\n  }\n  projectId;\n  /**\n   * Build URL with project_id prefix\n   */\n  url(path) {\n    return `/api/sandbox/${this.projectId}${path}`;\n  }\n  async create(options = {}) {\n    const body = {\n      template: options.template,\n      timeout_ms: options.timeoutMs,\n      metadata: options.metadata,\n      secrets: options.secrets\n    };\n    const response = await this.httpClient.post(this.url(\"/create\"), body);\n    const { id, template, host_pattern } = response.data;\n    return new SandboxImpl(id, template, host_pattern);\n  }\n  async connect(sandboxId, options = {}) {\n    let lastError;\n    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n      try {\n        const body = {\n          sandbox_id: sandboxId,\n          timeout_ms: options.timeoutMs\n        };\n        const response = await this.httpClient.post(this.url(\"/connect\"), body);\n        const { id, template, host_pattern } = response.data;\n        return new SandboxImpl(id, template, host_pattern);\n      } catch (error) {\n        console.error(`[Sandbox] Connect attempt ${attempt + 1} failed:`, error);\n        lastError = error instanceof Error ? error : new Error(String(error));\n        if (lastError.message.includes(\"404\") || lastError.message.includes(\"not found\") || lastError.message.includes(\"unauthorized\")) {\n          throw new SandboxConnectionError(sandboxId, lastError);\n        }\n        if (attempt < MAX_RETRIES - 1) {\n          const delay = INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n    console.error(`[Sandbox] All ${MAX_RETRIES} connection attempts failed for sandbox ${sandboxId}`);\n    throw new SandboxConnectionError(sandboxId, lastError);\n  }\n  async kill(sandboxId) {\n    await this.httpClient.post(this.url(\"/kill\"), { sandbox_id: sandboxId });\n  }\n};\n\n// src/client.ts\nvar defaultClient = null;\nfunction getDefaultClient() {\n  if (!defaultClient) {\n    throw new Error(\n      \"No Blink client initialized. Call createClient() first before using Agent or other SDK features.\"\n    );\n  }\n  return defaultClient;\n}\nfunction _getDefaultHttpClient() {\n  return getDefaultClient()._httpClient;\n}\nvar BlinkClientImpl = class {\n  auth;\n  db;\n  storage;\n  ai;\n  data;\n  realtime;\n  notifications;\n  analytics;\n  connectors;\n  functions;\n  rag;\n  sandbox;\n  /** @internal HTTP client for Agent auto-binding */\n  _httpClient;\n  constructor(config) {\n    if ((config.secretKey || config.serviceToken) && isBrowser) {\n      throw new Error(\"secretKey/serviceToken is server-only. Do not provide it in browser/React Native clients.\");\n    }\n    this.auth = new BlinkAuth(config);\n    this._httpClient = new HttpClient(\n      config,\n      () => this.auth.getToken(),\n      () => this.auth.getValidToken()\n    );\n    this.db = new BlinkDatabase(this._httpClient);\n    this.storage = new BlinkStorageImpl(this._httpClient);\n    this.ai = new BlinkAIImpl(this._httpClient);\n    this.data = new BlinkDataImpl(this._httpClient, config.projectId);\n    this.realtime = new BlinkRealtimeImpl(this._httpClient, config.projectId);\n    this.notifications = new BlinkNotificationsImpl(this._httpClient);\n    this.analytics = new BlinkAnalyticsImpl(this._httpClient, config.projectId);\n    this.connectors = new BlinkConnectorsImpl(this._httpClient);\n    this.functions = new BlinkFunctionsImpl(\n      this._httpClient,\n      config.projectId,\n      () => this.auth.getValidToken()\n    );\n    this.rag = new BlinkRAGImpl(this._httpClient);\n    this.sandbox = new BlinkSandboxImpl(this._httpClient);\n    this.auth.onAuthStateChanged((state) => {\n      if (state.isAuthenticated && state.user) {\n        this.analytics.setUserId(state.user.id);\n        this.analytics.setUserEmail(state.user.email);\n      } else {\n        this.analytics.setUserId(null);\n        this.analytics.setUserEmail(null);\n      }\n    });\n  }\n};\nfunction createClient(config) {\n  if (!config.projectId) {\n    throw new Error(\"projectId is required\");\n  }\n  const client = new BlinkClientImpl(config);\n  defaultClient = client;\n  return client;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsaW5rZG90bmV3L3Nkay9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUyxJQUFJLEtBQUssRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sR0FBRyxzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLHdGQUF3RixvQkFBb0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRix5REFBeUQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlEQUF5RDtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRix5REFBeUQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLDJCQUEyQixVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseURBQXlEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCLHFCQUFxQiwwQkFBMEI7QUFDOUc7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLFFBQVE7QUFDUix3QkFBd0IsT0FBTztBQUMvQjtBQUNBLE1BQU07QUFDTixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxnQ0FBZ0MseUNBQXlDLHdEQUF3RCxHQUFHO0FBQ2pQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJHQUEyRztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YseURBQXlEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRix5REFBeUQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlEQUF5RDtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlEQUF5RDtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlEQUF5RDtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlEQUF5RDtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRix5REFBeUQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYSxnQ0FBZ0MsMENBQTBDO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXLEdBQUcsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXLEdBQUcsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLHlGQUF5RixvQkFBb0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRix5REFBeUQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUIsS0FBSyxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixnQkFBZ0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQixRQUFRO0FBQ1Isd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QixzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQ0FBb0MsNkJBQTZCO0FBQ2pFLHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFCQUFxQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLEdBQUcsV0FBVyxHQUFHLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQixXQUFXLHFCQUFxQixlQUFlLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQixXQUFXLHFCQUFxQixlQUFlLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsR0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQiwwQkFBMEIsV0FBVyxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbUNBQW1DO0FBQ3JGO0FBQ0EsY0FBYyxxQ0FBcUM7QUFDbkQ7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseURBQXlEO0FBQ25GO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWUsR0FBRyxrQkFBa0I7QUFDdkUsMkNBQTJDLFVBQVUsR0FBRyxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBMEM7QUFDNUQsb0JBQW9CLHlDQUF5QztBQUM3RCxvQkFBb0IseUNBQXlDO0FBQzdELG9CQUFvQiwyQ0FBMkM7QUFDL0Q7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pELG9CQUFvQiwyQ0FBMkM7QUFDL0Qsb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBLG9CQUFvQiwrQ0FBK0M7QUFDbkUsb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQSxrQkFBa0IsMENBQTBDO0FBQzVELG9CQUFvQiwyQ0FBMkM7QUFDL0Qsb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBLGtCQUFrQix5Q0FBeUM7QUFDM0Q7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsVUFBVSxTQUFTO0FBQzlDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBeUQ7QUFDckY7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUF5RDtBQUM1RjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdHQUFnRztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseURBQXlEO0FBQzNGO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFD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VUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsMEJBQTBCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxHQUFHLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlLFNBQVMsUUFBUTtBQUNuRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUksR0FBRyxTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sSUFBSSxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLFlBQVksbUNBQW1DLGlCQUFpQjtBQUNoRTtBQUNBLHFEQUFxRCx1QkFBdUI7QUFDNUUsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWUsRUFBRSxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFdBQVc7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHVDQUF1QztBQUNwRztBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZSxFQUFFLEtBQUs7QUFDakQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0EsUUFBUTtBQUNSLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWEseUNBQXlDLFVBQVU7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVCQUF1QjtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXMyQjtBQUN0MkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Flc3RoZXRpYy0zZC1pbWFnZS1kZXNjcmliZXIvLi9ub2RlX21vZHVsZXMvQGJsaW5rZG90bmV3L3Nkay9kaXN0L2luZGV4Lm1qcz83NGUwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3JlcXVpcmUgPSAvKiBAX19QVVJFX18gKi8gKCh4KSA9PiB0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgUHJveHkoeCwge1xuICBnZXQ6IChhLCBiKSA9PiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlIDogYSlbYl1cbn0pIDogeCkoZnVuY3Rpb24oeCkge1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRocm93IEVycm9yKCdEeW5hbWljIHJlcXVpcmUgb2YgXCInICsgeCArICdcIiBpcyBub3Qgc3VwcG9ydGVkJyk7XG59KTtcblxuLy8gLi4vY29yZS9zcmMvcGxhdGZvcm0udHNcbmZ1bmN0aW9uIGRldGVjdFBsYXRmb3JtKCkge1xuICBpZiAodHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gXCJkZW5vXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MudmVyc2lvbnM/Lm5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gXCJyZWFjdC1uYXRpdmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwibm9kZVwiO1xuICB9XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCIpIHtcbiAgICByZXR1cm4gXCJyZWFjdC1uYXRpdmVcIjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gXCJ3ZWJcIjtcbiAgfVxuICByZXR1cm4gXCJub2RlXCI7XG59XG52YXIgcGxhdGZvcm0gPSBkZXRlY3RQbGF0Zm9ybSgpO1xudmFyIGlzV2ViID0gcGxhdGZvcm0gPT09IFwid2ViXCI7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IHBsYXRmb3JtID09PSBcInJlYWN0LW5hdGl2ZVwiO1xudmFyIGlzTm9kZSA9IHBsYXRmb3JtID09PSBcIm5vZGVcIjtcbnZhciBpc0Rlbm8gPSBwbGF0Zm9ybSA9PT0gXCJkZW5vXCI7XG52YXIgaXNCcm93c2VyID0gaXNXZWIgfHwgaXNSZWFjdE5hdGl2ZTtcbnZhciBpc1NlcnZlciA9IGlzTm9kZSB8fCBpc0Rlbm87XG5cbi8vIC4uL2NvcmUvc3JjL3N0b3JhZ2UtYWRhcHRlci50c1xudmFyIFdlYlN0b3JhZ2VBZGFwdGVyID0gY2xhc3Mge1xuICBnZXRJdGVtKGtleSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGdldCBpdGVtIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNldCBpdGVtIGluIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHJlbW92ZSBpdGVtIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgICAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjbGVhciBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQXN5bmNTdG9yYWdlQWRhcHRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXN5bmNTdG9yYWdlKSB7XG4gICAgdGhpcy5hc3luY1N0b3JhZ2UgPSBhc3luY1N0b3JhZ2U7XG4gICAgaWYgKCFhc3luY1N0b3JhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jU3RvcmFnZSBpbnN0YW5jZSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0SXRlbShrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYXN5bmNTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGdldCBpdGVtIGZyb20gQXN5bmNTdG9yYWdlOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYXN5bmNTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzZXQgaXRlbSBpbiBBc3luY1N0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5hc3luY1N0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcmVtb3ZlIGl0ZW0gZnJvbSBBc3luY1N0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY2xlYXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYXN5bmNTdG9yYWdlLmNsZWFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjbGVhciBBc3luY1N0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTm9PcFN0b3JhZ2VBZGFwdGVyID0gY2xhc3Mge1xuICBnZXRJdGVtKF9rZXkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXRJdGVtKF9rZXksIF92YWx1ZSkge1xuICB9XG4gIHJlbW92ZUl0ZW0oX2tleSkge1xuICB9XG4gIGNsZWFyKCkge1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0b3JhZ2VBZGFwdGVyKCkge1xuICBpZiAoaXNEZW5vKSB7XG4gICAgcmV0dXJuIG5ldyBOb09wU3RvcmFnZUFkYXB0ZXIoKTtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiX190ZXN0X19cIiwgXCJ0ZXN0XCIpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJfX3Rlc3RfX1wiKTtcbiAgICAgIHJldHVybiBuZXcgV2ViU3RvcmFnZUFkYXB0ZXIoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBOb09wU3RvcmFnZUFkYXB0ZXIoKTtcbn1cblxuLy8gLi4vY29yZS9zcmMvdHlwZXMudHNcbnZhciBCbGlua0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rRXJyb3JcIjtcbiAgfVxufTtcbnZhciBCbGlua0F1dGhFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxpbmtFcnJvciB7XG4gIGNvZGU7XG4gIHJldHJ5YWJsZTtcbiAgdXNlck1lc3NhZ2U7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIHVzZXJNZXNzYWdlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY29kZSwgNDAxLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rQXV0aEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnJldHJ5YWJsZSA9IFtcIk5FVFdPUktfRVJST1JcIiwgXCJSQVRFX0xJTUlURURcIl0uaW5jbHVkZXMoY29kZSk7XG4gICAgdGhpcy51c2VyTWVzc2FnZSA9IHVzZXJNZXNzYWdlIHx8IHRoaXMuZ2V0RGVmYXVsdFVzZXJNZXNzYWdlKGNvZGUpO1xuICB9XG4gIGdldERlZmF1bHRVc2VyTWVzc2FnZShjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIFwiSU5WQUxJRF9DUkVERU5USUFMU1wiIC8qIElOVkFMSURfQ1JFREVOVElBTFMgKi86XG4gICAgICAgIHJldHVybiBcIkludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQuIFBsZWFzZSB0cnkgYWdhaW4uXCI7XG4gICAgICBjYXNlIFwiRU1BSUxfTk9UX1ZFUklGSUVEXCIgLyogRU1BSUxfTk9UX1ZFUklGSUVEICovOlxuICAgICAgICByZXR1cm4gXCJQbGVhc2UgdmVyaWZ5IHlvdXIgZW1haWwgYWRkcmVzcyBiZWZvcmUgc2lnbmluZyBpbi5cIjtcbiAgICAgIGNhc2UgXCJQT1BVUF9DQU5DRUxFRFwiIC8qIFBPUFVQX0NBTkNFTEVEICovOlxuICAgICAgICByZXR1cm4gXCJTaWduLWluIHdhcyBjYW5jZWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcbiAgICAgIGNhc2UgXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLzpcbiAgICAgICAgcmV0dXJuIFwiTmV0d29yayBlcnJvci4gUGxlYXNlIGNoZWNrIHlvdXIgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluLlwiO1xuICAgICAgY2FzZSBcIlJBVEVfTElNSVRFRFwiIC8qIFJBVEVfTElNSVRFRCAqLzpcbiAgICAgICAgcmV0dXJuIFwiVG9vIG1hbnkgYXR0ZW1wdHMuIFBsZWFzZSB3YWl0IGEgbW9tZW50IGFuZCB0cnkgYWdhaW4uXCI7XG4gICAgICBjYXNlIFwiQVVUSF9USU1FT1VUXCIgLyogQVVUSF9USU1FT1VUICovOlxuICAgICAgICByZXR1cm4gXCJBdXRoZW50aWNhdGlvbiB0aW1lZCBvdXQuIFBsZWFzZSB0cnkgYWdhaW4uXCI7XG4gICAgICBjYXNlIFwiUkVESVJFQ1RfRkFJTEVEXCIgLyogUkVESVJFQ1RfRkFJTEVEICovOlxuICAgICAgICByZXR1cm4gXCJSZWRpcmVjdCBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uXCI7XG4gICAgICBjYXNlIFwiVE9LRU5fRVhQSVJFRFwiIC8qIFRPS0VOX0VYUElSRUQgKi86XG4gICAgICAgIHJldHVybiBcIlNlc3Npb24gZXhwaXJlZC4gUGxlYXNlIHNpZ24gaW4gYWdhaW4uXCI7XG4gICAgICBjYXNlIFwiVVNFUl9OT1RfRk9VTkRcIiAvKiBVU0VSX05PVF9GT1VORCAqLzpcbiAgICAgICAgcmV0dXJuIFwiVXNlciBub3QgZm91bmQuIFBsZWFzZSBjaGVjayB5b3VyIGVtYWlsIGFuZCB0cnkgYWdhaW4uXCI7XG4gICAgICBjYXNlIFwiRU1BSUxfQUxSRUFEWV9FWElTVFNcIiAvKiBFTUFJTF9BTFJFQURZX0VYSVNUUyAqLzpcbiAgICAgICAgcmV0dXJuIFwiQW4gYWNjb3VudCB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMuXCI7XG4gICAgICBjYXNlIFwiV0VBS19QQVNTV09SRFwiIC8qIFdFQUtfUEFTU1dPUkQgKi86XG4gICAgICAgIHJldHVybiBcIlBhc3N3b3JkIGlzIHRvbyB3ZWFrLiBQbGVhc2UgY2hvb3NlIGEgc3Ryb25nZXIgcGFzc3dvcmQuXCI7XG4gICAgICBjYXNlIFwiSU5WQUxJRF9FTUFJTFwiIC8qIElOVkFMSURfRU1BSUwgKi86XG4gICAgICAgIHJldHVybiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXCI7XG4gICAgICBjYXNlIFwiTUFHSUNfTElOS19FWFBJUkVEXCIgLyogTUFHSUNfTElOS19FWFBJUkVEICovOlxuICAgICAgICByZXR1cm4gXCJNYWdpYyBsaW5rIGhhcyBleHBpcmVkLiBQbGVhc2UgcmVxdWVzdCBhIG5ldyBvbmUuXCI7XG4gICAgICBjYXNlIFwiVkVSSUZJQ0FUSU9OX0ZBSUxFRFwiIC8qIFZFUklGSUNBVElPTl9GQUlMRUQgKi86XG4gICAgICAgIHJldHVybiBcIlZlcmlmaWNhdGlvbiBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJBdXRoZW50aWNhdGlvbiBlcnJvci4gUGxlYXNlIHRyeSBhZ2Fpbi5cIjtcbiAgICB9XG4gIH1cbn07XG52YXIgQmxpbmtOZXR3b3JrRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsaW5rRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBcIk5FVFdPUktfRVJST1JcIiwgc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rTmV0d29ya0Vycm9yXCI7XG4gIH1cbn07XG52YXIgQmxpbmtWYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsaW5rRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJWQUxJREFUSU9OX0VSUk9SXCIsIDQwMCwgZGV0YWlscyk7XG4gICAgdGhpcy5uYW1lID0gXCJCbGlua1ZhbGlkYXRpb25FcnJvclwiO1xuICB9XG59O1xudmFyIEJsaW5rU3RvcmFnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbGlua0Vycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJTVE9SQUdFX0VSUk9SXCIsIHN0YXR1cywgZGV0YWlscyk7XG4gICAgdGhpcy5uYW1lID0gXCJCbGlua1N0b3JhZ2VFcnJvclwiO1xuICB9XG59O1xudmFyIEJsaW5rQUlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxpbmtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIFwiQUlfRVJST1JcIiwgc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rQUlFcnJvclwiO1xuICB9XG59O1xudmFyIEJsaW5rRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbGlua0Vycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJEQVRBX0VSUk9SXCIsIHN0YXR1cywgZGV0YWlscyk7XG4gICAgdGhpcy5uYW1lID0gXCJCbGlua0RhdGFFcnJvclwiO1xuICB9XG59O1xudmFyIEJsaW5rUmVhbHRpbWVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxpbmtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIFwiUkVBTFRJTUVfRVJST1JcIiwgc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJsaW5rUmVhbHRpbWVFcnJvclwiO1xuICB9XG59O1xudmFyIEJsaW5rTm90aWZpY2F0aW9uc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCbGlua0Vycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgXCJOT1RJRklDQVRJT05TX0VSUk9SXCIsIHN0YXR1cywgZGV0YWlscyk7XG4gICAgdGhpcy5uYW1lID0gXCJCbGlua05vdGlmaWNhdGlvbnNFcnJvclwiO1xuICB9XG59O1xuXG4vLyAuLi9jb3JlL3NyYy9xdWVyeS1idWlsZGVyLnRzXG5mdW5jdGlvbiBjYW1lbFRvU25ha2Uoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW0EtWl0vZywgKGxldHRlcikgPT4gYF8ke2xldHRlci50b0xvd2VyQ2FzZSgpfWApO1xufVxuZnVuY3Rpb24gY29udmVydEZpbHRlcktleXNUb1NuYWtlQ2FzZShjb25kaXRpb24pIHtcbiAgaWYgKCFjb25kaXRpb24pIHJldHVybiBjb25kaXRpb247XG4gIGlmIChcIkFORFwiIGluIGNvbmRpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBBTkQ6IGNvbmRpdGlvbi5BTkQ/Lm1hcChjb252ZXJ0RmlsdGVyS2V5c1RvU25ha2VDYXNlKVxuICAgIH07XG4gIH1cbiAgaWYgKFwiT1JcIiBpbiBjb25kaXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgT1I6IGNvbmRpdGlvbi5PUj8ubWFwKGNvbnZlcnRGaWx0ZXJLZXlzVG9TbmFrZUNhc2UpXG4gICAgfTtcbiAgfVxuICBjb25zdCBjb252ZXJ0ZWQgPSB7fTtcbiAgZm9yIChjb25zdCBbZmllbGQsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb25kaXRpb24pKSB7XG4gICAgY29uc3Qgc25ha2VGaWVsZCA9IGNhbWVsVG9TbmFrZShmaWVsZCk7XG4gICAgY29udmVydGVkW3NuYWtlRmllbGRdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRmlsdGVyUXVlcnkoY29uZGl0aW9uKSB7XG4gIGlmICghY29uZGl0aW9uKSByZXR1cm4gXCJcIjtcbiAgaWYgKFwiQU5EXCIgaW4gY29uZGl0aW9uKSB7XG4gICAgY29uc3QgYW5kQ29uZGl0aW9ucyA9IGNvbmRpdGlvbi5BTkQ/Lm1hcChidWlsZEZpbHRlclF1ZXJ5KS5maWx0ZXIoQm9vbGVhbikgfHwgW107XG4gICAgcmV0dXJuIGFuZENvbmRpdGlvbnMubGVuZ3RoID4gMCA/IGBhbmQ9KCR7YW5kQ29uZGl0aW9ucy5qb2luKFwiLFwiKX0pYCA6IFwiXCI7XG4gIH1cbiAgaWYgKFwiT1JcIiBpbiBjb25kaXRpb24pIHtcbiAgICBjb25zdCBvckNvbmRpdGlvbnMgPSBjb25kaXRpb24uT1I/Lm1hcChidWlsZEZpbHRlclF1ZXJ5KS5maWx0ZXIoQm9vbGVhbikgfHwgW107XG4gICAgcmV0dXJuIG9yQ29uZGl0aW9ucy5sZW5ndGggPiAwID8gYG9yPSgke29yQ29uZGl0aW9ucy5qb2luKFwiLFwiKX0pYCA6IFwiXCI7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGZvciAoY29uc3QgW2ZpZWxkLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29uZGl0aW9uKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBbb3BlcmF0b3IsIG9wZXJhdG9yVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBwYXJhbSA9IGJ1aWxkT3BlcmF0b3JRdWVyeShmaWVsZCwgb3BlcmF0b3IsIG9wZXJhdG9yVmFsdWUpO1xuICAgICAgICBpZiAocGFyYW0pIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLnB1c2goYCR7ZmllbGR9PWVxLiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXMuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBidWlsZE9wZXJhdG9yUXVlcnkoZmllbGQsIG9wZXJhdG9yLCB2YWx1ZSkge1xuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgY2FzZSBcImVxXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PWVxLiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwibmVxXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PW5lcS4ke2VuY29kZVF1ZXJ5VmFsdWUodmFsdWUpfWA7XG4gICAgY2FzZSBcImd0XCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PWd0LiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwiZ3RlXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PWd0ZS4ke2VuY29kZVF1ZXJ5VmFsdWUodmFsdWUpfWA7XG4gICAgY2FzZSBcImx0XCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PWx0LiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwibHRlXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PWx0ZS4ke2VuY29kZVF1ZXJ5VmFsdWUodmFsdWUpfWA7XG4gICAgY2FzZSBcImxpa2VcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09bGlrZS4ke2VuY29kZVF1ZXJ5VmFsdWUodmFsdWUpfWA7XG4gICAgY2FzZSBcImlsaWtlXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PWlsaWtlLiR7ZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwiaXNcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZH09aXMuJHt2YWx1ZSA9PT0gbnVsbCA/IFwibnVsbFwiIDogZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSl9YDtcbiAgICBjYXNlIFwibm90XCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGR9PW5vdC4ke2VuY29kZVF1ZXJ5VmFsdWUodmFsdWUpfWA7XG4gICAgY2FzZSBcImluXCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUubWFwKGVuY29kZVF1ZXJ5VmFsdWUpLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gYCR7ZmllbGR9PWluLigke3ZhbHVlc30pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGNhc2UgXCJub3RfaW5cIjpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5tYXAoZW5jb2RlUXVlcnlWYWx1ZSkuam9pbihcIixcIik7XG4gICAgICAgIHJldHVybiBgJHtmaWVsZH09bm90LmluLigke3ZhbHVlc30pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlUXVlcnlWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBcIm51bGxcIjtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdmFsdWUgPyBcIjFcIiA6IFwiMFwiO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIGlmIChvcHRpb25zLnNlbGVjdCAmJiBvcHRpb25zLnNlbGVjdC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc25ha2VGaWVsZHMgPSBvcHRpb25zLnNlbGVjdC5tYXAoY2FtZWxUb1NuYWtlKTtcbiAgICBwYXJhbXMuc2VsZWN0ID0gc25ha2VGaWVsZHMuam9pbihcIixcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zLnNlbGVjdCA9IFwiKlwiO1xuICB9XG4gIGlmIChvcHRpb25zLndoZXJlKSB7XG4gICAgY29uc3QgY29udmVydGVkV2hlcmUgPSBjb252ZXJ0RmlsdGVyS2V5c1RvU25ha2VDYXNlKG9wdGlvbnMud2hlcmUpO1xuICAgIGNvbnN0IGZpbHRlclF1ZXJ5ID0gYnVpbGRGaWx0ZXJRdWVyeShjb252ZXJ0ZWRXaGVyZSk7XG4gICAgaWYgKGZpbHRlclF1ZXJ5KSB7XG4gICAgICBjb25zdCBmaWx0ZXJQYXJhbXMgPSBmaWx0ZXJRdWVyeS5zcGxpdChcIiZcIik7XG4gICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIGZpbHRlclBhcmFtcykge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYXJhbS5zcGxpdChcIj1cIiwgMik7XG4gICAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLm9yZGVyQnkpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMub3JkZXJCeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGFyYW1zLm9yZGVyID0gb3B0aW9ucy5vcmRlckJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmRlckNsYXVzZXMgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLm9yZGVyQnkpLm1hcCgoW2ZpZWxkLCBkaXJlY3Rpb25dKSA9PiBgJHtjYW1lbFRvU25ha2UoZmllbGQpfS4ke2RpcmVjdGlvbn1gKTtcbiAgICAgIHBhcmFtcy5vcmRlciA9IG9yZGVyQ2xhdXNlcy5qb2luKFwiLFwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMubGltaXQgIT09IHZvaWQgMCkge1xuICAgIHBhcmFtcy5saW1pdCA9IG9wdGlvbnMubGltaXQudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5vZmZzZXQgIT09IHZvaWQgMCkge1xuICAgIHBhcmFtcy5vZmZzZXQgPSBvcHRpb25zLm9mZnNldC50b1N0cmluZygpO1xuICB9XG4gIGlmIChvcHRpb25zLmN1cnNvcikge1xuICAgIHBhcmFtcy5jdXJzb3IgPSBvcHRpb25zLmN1cnNvcjtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuXG4vLyAuLi9jb3JlL3NyYy9odHRwLWNsaWVudC50c1xuZnVuY3Rpb24gY2FtZWxUb1NuYWtlMihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bQS1aXS9nLCAobGV0dGVyKSA9PiBgXyR7bGV0dGVyLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5mdW5jdGlvbiBzbmFrZVRvQ2FtZWwoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gY29udmVydEtleXNUb1NuYWtlQ2FzZShvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCkgcmV0dXJuIG9iajtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHJldHVybiBvYmo7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGNvbnZlcnRLZXlzVG9TbmFrZUNhc2UpO1xuICBjb25zdCBjb252ZXJ0ZWQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IHNuYWtlS2V5ID0gY2FtZWxUb1NuYWtlMihrZXkpO1xuICAgIGNvbnZlcnRlZFtzbmFrZUtleV0gPSBjb252ZXJ0S2V5c1RvU25ha2VDYXNlKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkO1xufVxuZnVuY3Rpb24gY29udmVydEtleXNUb0NhbWVsQ2FzZShvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCkgcmV0dXJuIG9iajtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHJldHVybiBvYmo7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGNvbnZlcnRLZXlzVG9DYW1lbENhc2UpO1xuICBjb25zdCBjb252ZXJ0ZWQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGNhbWVsS2V5ID0gc25ha2VUb0NhbWVsKGtleSk7XG4gICAgY29udmVydGVkW2NhbWVsS2V5XSA9IGNvbnZlcnRLZXlzVG9DYW1lbENhc2UodmFsdWUpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG52YXIgSHR0cENsaWVudCA9IGNsYXNzIHtcbiAgYXV0aFVybCA9IFwiaHR0cHM6Ly9ibGluay5uZXdcIjtcbiAgY29yZVVybCA9IFwiaHR0cHM6Ly9jb3JlLmJsaW5rLm5ld1wiO1xuICBwcm9qZWN0SWQ7XG4gIHB1Ymxpc2hhYmxlS2V5O1xuICBzZWNyZXRLZXk7XG4gIC8vIFBlcm1hbmVudCwgbm9uLWV4cGlyaW5nIGtleSAobGlrZSBTdHJpcGUncyBza19saXZlXy4uLilcbiAgZ2V0VG9rZW47XG4gIGdldFZhbGlkVG9rZW47XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgZ2V0VG9rZW4sIGdldFZhbGlkVG9rZW4pIHtcbiAgICB0aGlzLnByb2plY3RJZCA9IGNvbmZpZy5wcm9qZWN0SWQ7XG4gICAgdGhpcy5wdWJsaXNoYWJsZUtleSA9IGNvbmZpZy5wdWJsaXNoYWJsZUtleTtcbiAgICB0aGlzLnNlY3JldEtleSA9IGNvbmZpZy5zZWNyZXRLZXkgfHwgY29uZmlnLnNlcnZpY2VUb2tlbjtcbiAgICB0aGlzLmdldFRva2VuID0gZ2V0VG9rZW47XG4gICAgdGhpcy5nZXRWYWxpZFRva2VuID0gZ2V0VmFsaWRUb2tlbjtcbiAgfVxuICBzaG91bGRBdHRhY2hQdWJsaXNoYWJsZUtleShwYXRoLCBtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJQT1NUXCIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocGF0aC5pbmNsdWRlcyhcIi9hcGkvYW5hbHl0aWNzL1wiKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoXCIvYXBpL3N0b3JhZ2UvXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocGF0aC5pbmNsdWRlcyhcIi9hcGkvZGIvXCIpICYmIHBhdGguaW5jbHVkZXMoXCIvcmVzdC92MS9cIikpIHJldHVybiBtZXRob2QgPT09IFwiR0VUXCI7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNob3VsZFNraXBTZWNyZXRLZXkodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBVUkwodXJsKTtcbiAgICAgIHJldHVybiBwYXJzZWQuaG9zdG5hbWUuZW5kc1dpdGgoXCIuZnVuY3Rpb25zLmJsaW5rLm5ld1wiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZ2V0QXV0aG9yaXphdGlvbkhlYWRlcih1cmwsIHRva2VuKSB7XG4gICAgaWYgKHRoaXMuc2VjcmV0S2V5ICYmICF0aGlzLnNob3VsZFNraXBTZWNyZXRLZXkodXJsKSkge1xuICAgICAgcmV0dXJuIGBCZWFyZXIgJHt0aGlzLnNlY3JldEtleX1gO1xuICAgIH1cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHJldHVybiBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgYW4gYXV0aGVudGljYXRlZCByZXF1ZXN0IHRvIHRoZSBCbGluayBBUElcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChwYXRoLCBvcHRpb25zLnNlYXJjaFBhcmFtcyk7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFZhbGlkVG9rZW4gPyBhd2FpdCB0aGlzLmdldFZhbGlkVG9rZW4oKSA6IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICBjb25zdCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgIH07XG4gICAgY29uc3QgYXV0aCA9IHRoaXMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlcih1cmwsIHRva2VuKTtcbiAgICBpZiAoYXV0aCkge1xuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYXV0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHVibGlzaGFibGVLZXkgJiYgIWhlYWRlcnNbXCJ4LWJsaW5rLXB1Ymxpc2hhYmxlLWtleVwiXSAmJiB0aGlzLnNob3VsZEF0dGFjaFB1Ymxpc2hhYmxlS2V5KHBhdGgsIG1ldGhvZCkpIHtcbiAgICAgIGhlYWRlcnNbXCJ4LWJsaW5rLXB1Ymxpc2hhYmxlLWtleVwiXSA9IHRoaXMucHVibGlzaGFibGVLZXk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RJbml0ID0ge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmJvZHkgJiYgbWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuYm9keSA6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgcmVxdWVzdEluaXQpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucGFyc2VSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua05ldHdvcmtFcnJvcihcbiAgICAgICAgYE5ldHdvcmsgcmVxdWVzdCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHRVQgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgZ2V0KHBhdGgsIHNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QocGF0aCwgeyBtZXRob2Q6IFwiR0VUXCIsIHNlYXJjaFBhcmFtcyB9KTtcbiAgfVxuICAvKipcbiAgICogUE9TVCByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBwb3N0KHBhdGgsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHBhdGgsIHsgbWV0aG9kOiBcIlBPU1RcIiwgYm9keSwgaGVhZGVycyB9KTtcbiAgfVxuICAvKipcbiAgICogUEFUQ0ggcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcGF0Y2gocGF0aCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QocGF0aCwgeyBtZXRob2Q6IFwiUEFUQ0hcIiwgYm9keSwgaGVhZGVycyB9KTtcbiAgfVxuICAvKipcbiAgICogREVMRVRFIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGRlbGV0ZShwYXRoLCBzZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHBhdGgsIHsgbWV0aG9kOiBcIkRFTEVURVwiLCBzZWFyY2hQYXJhbXMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERhdGFiYXNlLXNwZWNpZmljIHJlcXVlc3RzXG4gICAqL1xuICAvLyBUYWJsZSBvcGVyYXRpb25zIChQb3N0Z1JFU1QtY29tcGF0aWJsZSlcbiAgYXN5bmMgZGJHZXQodGFibGUsIHNlYXJjaFBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXQoYC9hcGkvZGIvJHt0aGlzLnByb2plY3RJZH0vcmVzdC92MS8ke3RhYmxlfWAsIHNlYXJjaFBhcmFtcyk7XG4gICAgY29uc3QgY29udmVydGVkRGF0YSA9IGNvbnZlcnRLZXlzVG9DYW1lbENhc2UocmVzcG9uc2UuZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgZGF0YTogY29udmVydGVkRGF0YVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGJQb3N0KHRhYmxlLCBib2R5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBoZWFkZXJzLlByZWZlciA9IFwicmV0dXJuPXJlcHJlc2VudGF0aW9uXCI7XG4gICAgfVxuICAgIGNvbnN0IGNvbnZlcnRlZEJvZHkgPSBjb252ZXJ0S2V5c1RvU25ha2VDYXNlKGJvZHkpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KGAvYXBpL2RiLyR7dGhpcy5wcm9qZWN0SWR9L3Jlc3QvdjEvJHt0YWJsZX1gLCBjb252ZXJ0ZWRCb2R5LCBoZWFkZXJzKTtcbiAgICBjb25zdCBjb252ZXJ0ZWREYXRhID0gY29udmVydEtleXNUb0NhbWVsQ2FzZShyZXNwb25zZS5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBkYXRhOiBjb252ZXJ0ZWREYXRhXG4gICAgfTtcbiAgfVxuICBhc3luYyBkYlBhdGNoKHRhYmxlLCBib2R5LCBzZWFyY2hQYXJhbXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGhlYWRlcnMuUHJlZmVyID0gXCJyZXR1cm49cmVwcmVzZW50YXRpb25cIjtcbiAgICB9XG4gICAgY29uc3QgY29udmVydGVkQm9keSA9IGNvbnZlcnRLZXlzVG9TbmFrZUNhc2UoYm9keSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYC9hcGkvZGIvJHt0aGlzLnByb2plY3RJZH0vcmVzdC92MS8ke3RhYmxlfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgYm9keTogY29udmVydGVkQm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZWFyY2hQYXJhbXNcbiAgICB9KTtcbiAgICBjb25zdCBjb252ZXJ0ZWREYXRhID0gY29udmVydEtleXNUb0NhbWVsQ2FzZShyZXNwb25zZS5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBkYXRhOiBjb252ZXJ0ZWREYXRhXG4gICAgfTtcbiAgfVxuICBhc3luYyBkYkRlbGV0ZSh0YWJsZSwgc2VhcmNoUGFyYW1zLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBoZWFkZXJzLlByZWZlciA9IFwicmV0dXJuPXJlcHJlc2VudGF0aW9uXCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0KGAvYXBpL2RiLyR7dGhpcy5wcm9qZWN0SWR9L3Jlc3QvdjEvJHt0YWJsZX1gLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2VhcmNoUGFyYW1zXG4gICAgfSk7XG4gICAgY29uc3QgY29udmVydGVkRGF0YSA9IGNvbnZlcnRLZXlzVG9DYW1lbENhc2UocmVzcG9uc2UuZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgZGF0YTogY29udmVydGVkRGF0YVxuICAgIH07XG4gIH1cbiAgLy8gUmF3IFNRTCBvcGVyYXRpb25zXG4gIGFzeW5jIGRiU3FsKHF1ZXJ5LCBwYXJhbXMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdChgL2FwaS9kYi8ke3RoaXMucHJvamVjdElkfS9zcWxgLCB7IHF1ZXJ5LCBwYXJhbXMgfSk7XG4gICAgY29uc3QgY29udmVydGVkRGF0YSA9IHtcbiAgICAgIC4uLnJlc3BvbnNlLmRhdGEsXG4gICAgICByb3dzOiBjb252ZXJ0S2V5c1RvQ2FtZWxDYXNlKHJlc3BvbnNlLmRhdGEucm93cylcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGRhdGE6IGNvbnZlcnRlZERhdGFcbiAgICB9O1xuICB9XG4gIC8vIEJhdGNoIFNRTCBvcGVyYXRpb25zXG4gIGFzeW5jIGRiQmF0Y2goc3RhdGVtZW50cywgbW9kZSA9IFwid3JpdGVcIikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KGAvYXBpL2RiLyR7dGhpcy5wcm9qZWN0SWR9L2JhdGNoYCwgeyBzdGF0ZW1lbnRzLCBtb2RlIH0pO1xuICAgIGNvbnN0IGNvbnZlcnRlZERhdGEgPSB7XG4gICAgICAuLi5yZXNwb25zZS5kYXRhLFxuICAgICAgcmVzdWx0czogcmVzcG9uc2UuZGF0YS5yZXN1bHRzLm1hcCgocmVzdWx0KSA9PiAoe1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHJvd3M6IGNvbnZlcnRLZXlzVG9DYW1lbENhc2UocmVzdWx0LnJvd3MpXG4gICAgICB9KSlcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGRhdGE6IGNvbnZlcnRlZERhdGFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgZmlsZSB3aXRoIHByb2dyZXNzIHRyYWNraW5nXG4gICAqL1xuICBhc3luYyB1cGxvYWRGaWxlKHBhdGgsIGZpbGUsIGZpbGVQYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVXJsKHBhdGgpO1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5nZXRWYWxpZFRva2VuID8gYXdhaXQgdGhpcy5nZXRWYWxpZFRva2VuKCkgOiB0aGlzLmdldFRva2VuKCk7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSk7XG4gICAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgY29uc3QgYmxvYldpdGhUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZSA/IG5ldyBCbG9iKFtmaWxlXSwgeyB0eXBlOiBvcHRpb25zLmNvbnRlbnRUeXBlIH0pIDogZmlsZTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgYmxvYldpdGhUeXBlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtmaWxlXSwgeyB0eXBlOiBvcHRpb25zLmNvbnRlbnRUeXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfSk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGJsb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtWYWxpZGF0aW9uRXJyb3IoXCJVbnN1cHBvcnRlZCBmaWxlIHR5cGVcIik7XG4gICAgfVxuICAgIGZvcm1EYXRhLmFwcGVuZChcInBhdGhcIiwgZmlsZVBhdGgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBjb25zdCBhdXRoID0gdGhpcy5nZXRBdXRob3JpemF0aW9uSGVhZGVyKHVybCwgdG9rZW4pO1xuICAgIGlmIChhdXRoKSB7XG4gICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBhdXRoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wdWJsaXNoYWJsZUtleSAmJiBwYXRoLmluY2x1ZGVzKFwiL2FwaS9zdG9yYWdlL1wiKSAmJiAhaGVhZGVyc1tcIngtYmxpbmstcHVibGlzaGFibGUta2V5XCJdKSB7XG4gICAgICBoZWFkZXJzW1wieC1ibGluay1wdWJsaXNoYWJsZS1rZXlcIl0gPSB0aGlzLnB1Ymxpc2hhYmxlS2V5O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRpb25zLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkV2l0aFByb2dyZXNzKHVybCwgZm9ybURhdGEsIGhlYWRlcnMsIG9wdGlvbnMub25Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBmb3JtRGF0YVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5wYXJzZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0Vycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rTmV0d29ya0Vycm9yKFxuICAgICAgICBgRmlsZSB1cGxvYWQgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBsb2FkIHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmcgdXNpbmcgWE1MSHR0cFJlcXVlc3RcbiAgICovXG4gIHVwbG9hZFdpdGhQcm9ncmVzcyh1cmwsIGZvcm1EYXRhLCBoZWFkZXJzLCBvblByb2dyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgY29uc3QgcGVyY2VudCA9IE1hdGgucm91bmQoZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgKiAxMDApO1xuICAgICAgICAgIG9uUHJvZ3Jlc3MocGVyY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpXG4gICAgICAgICAgICAgIC8vIFhNTEh0dHBSZXF1ZXN0IGRvZXNuJ3QgcHJvdmlkZSBlYXN5IGFjY2VzcyB0byByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua05ldHdvcmtFcnJvcihcIkZhaWxlZCB0byBwYXJzZSByZXNwb25zZVwiLCB4aHIuc3RhdHVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvckRhdGEubWVzc2FnZSB8fCBgSFRUUCAke3hoci5zdGF0dXN9YDtcbiAgICAgICAgICAgIHN3aXRjaCAoeGhyLnN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEJsaW5rQXV0aEVycm9yKG1lc3NhZ2UsIGVycm9yRGF0YSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEJsaW5rVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UsIGVycm9yRGF0YSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtOZXR3b3JrRXJyb3IobWVzc2FnZSwgeGhyLnN0YXR1cywgZXJyb3JEYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZWplY3QobmV3IEJsaW5rTmV0d29ya0Vycm9yKGBIVFRQICR7eGhyLnN0YXR1c31gLCB4aHIuc3RhdHVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEJsaW5rTmV0d29ya0Vycm9yKFwiTmV0d29yayBlcnJvciBkdXJpbmcgZmlsZSB1cGxvYWRcIikpO1xuICAgICAgfSk7XG4gICAgICB4aHIub3BlbihcIlBPU1RcIiwgdXJsKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBSS1zcGVjaWZpYyByZXF1ZXN0c1xuICAgKi9cbiAgYXN5bmMgYWlUZXh0KHByb21wdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYWwsIC4uLmJvZHkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7IC4uLmJvZHkgfTtcbiAgICBpZiAocHJvbXB0KSB7XG4gICAgICByZXF1ZXN0Qm9keS5wcm9tcHQgPSBwcm9tcHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvYWkvJHt0aGlzLnByb2plY3RJZH0vdGV4dGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiByZXF1ZXN0Qm9keSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdHJlYW0gQUkgdGV4dCBnZW5lcmF0aW9uIC0gdXNlcyBWZXJjZWwgQUkgU0RLJ3MgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UgKERhdGEgU3RyZWFtIFByb3RvY29sKVxuICAgKi9cbiAgYXN5bmMgc3RyZWFtQWlUZXh0KHByb21wdCwgb3B0aW9ucyA9IHt9LCBvbkNodW5rKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS90ZXh0YCk7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFZhbGlkVG9rZW4gPyBhd2FpdCB0aGlzLmdldFZhbGlkVG9rZW4oKSA6IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9O1xuICAgIGNvbnN0IGF1dGggPSB0aGlzLmdldEF1dGhvcml6YXRpb25IZWFkZXIodXJsLCB0b2tlbik7XG4gICAgaWYgKGF1dGgpIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGF1dGg7XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIHByb21wdCxcbiAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IHsgc2lnbmFsOiBfc2lnbmFsLCAuLi5qc29uQm9keSB9ID0gYm9keTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkJvZHkpLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtOZXR3b3JrRXJyb3IoXCJObyByZXNwb25zZSBib2R5IGZvciBzdHJlYW1pbmdcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZURhdGFTdHJlYW1Qcm90b2NvbChyZXNwb25zZS5ib2R5LCBvbkNodW5rKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua05ldHdvcmtFcnJvcihcbiAgICAgICAgYFN0cmVhbWluZyByZXF1ZXN0IGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWlPYmplY3QocHJvbXB0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4uYm9keSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHsgLi4uYm9keSB9O1xuICAgIGlmIChwcm9tcHQpIHtcbiAgICAgIHJlcXVlc3RCb2R5LnByb21wdCA9IHByb21wdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS9vYmplY3RgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcmVxdWVzdEJvZHksXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RyZWFtIEFJIG9iamVjdCBnZW5lcmF0aW9uIC0gdXNlcyBWZXJjZWwgQUkgU0RLJ3MgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlXG4gICAqL1xuICBhc3luYyBzdHJlYW1BaU9iamVjdChwcm9tcHQsIG9wdGlvbnMgPSB7fSwgb25QYXJ0aWFsKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS9vYmplY3RgKTtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VmFsaWRUb2tlbiA/IGF3YWl0IHRoaXMuZ2V0VmFsaWRUb2tlbigpIDogdGhpcy5nZXRUb2tlbigpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgY29uc3QgYXV0aCA9IHRoaXMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlcih1cmwsIHRva2VuKTtcbiAgICBpZiAoYXV0aCkgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYXV0aDtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgcHJvbXB0LFxuICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgeyBzaWduYWw6IF9zaWduYWwyLCAuLi5qc29uQm9keTIgfSA9IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb25Cb2R5MiksXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua05ldHdvcmtFcnJvcihcIk5vIHJlc3BvbnNlIGJvZHkgZm9yIHN0cmVhbWluZ1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICAgIGxldCBsYXRlc3RPYmplY3QgPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgYnVmZmVyICs9IGNodW5rO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGJ1ZmZlcik7XG4gICAgICAgICAgICBsYXRlc3RPYmplY3QgPSBwYXJzZWQ7XG4gICAgICAgICAgICBpZiAob25QYXJ0aWFsKSB7XG4gICAgICAgICAgICAgIG9uUGFydGlhbChwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IEpTT04ucGFyc2UoYnVmZmVyKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgb2JqZWN0OiBsYXRlc3RPYmplY3QgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0Vycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rTmV0d29ya0Vycm9yKFxuICAgICAgICBgU3RyZWFtaW5nIHJlcXVlc3QgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBhc3luYyBhaUltYWdlKHByb21wdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYWwsIC4uLmJvZHkgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS9pbWFnZWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGFpU3BlZWNoKHRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmFsLCAuLi5ib2R5IH0gPSBvcHRpb25zO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvYWkvJHt0aGlzLnByb2plY3RJZH0vc3BlZWNoYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgdGV4dCxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGFpVHJhbnNjcmliZShhdWRpbywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYWwsIC4uLmJvZHkgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHBheWxvYWRBdWRpbztcbiAgICBpZiAodHlwZW9mIGF1ZGlvID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoYXVkaW8pKSB7XG4gICAgICBwYXlsb2FkQXVkaW8gPSBhdWRpbztcbiAgICB9IGVsc2UgaWYgKGF1ZGlvIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcGF5bG9hZEF1ZGlvID0gQXJyYXkuZnJvbShhdWRpbyk7XG4gICAgfSBlbHNlIGlmIChhdWRpbyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBwYXlsb2FkQXVkaW8gPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGF1ZGlvKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEJ1ZmZlci5pc0J1ZmZlcihhdWRpbykpIHtcbiAgICAgIHBheWxvYWRBdWRpbyA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYXVkaW8pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rVmFsaWRhdGlvbkVycm9yKFwiVW5zdXBwb3J0ZWQgYXVkaW8gaW5wdXQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9haS8ke3RoaXMucHJvamVjdElkfS90cmFuc2NyaWJlYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgYXVkaW86IHBheWxvYWRBdWRpbyxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGFpVmlkZW8ocHJvbXB0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4uYm9keSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FpLyR7dGhpcy5wcm9qZWN0SWR9L3ZpZGVvYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFJIEFnZW50IHJlcXVlc3QgKG5vbi1zdHJlYW1pbmcpXG4gICAqIFJldHVybnMgSlNPTiByZXNwb25zZSB3aXRoIHRleHQsIHN0ZXBzLCB1c2FnZSwgYW5kIGJpbGxpbmdcbiAgICovXG4gIGFzeW5jIGFpQWdlbnQocmVxdWVzdEJvZHksIHNpZ25hbCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvYWkvJHt0aGlzLnByb2plY3RJZH0vYWdlbnRgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcmVxdWVzdEJvZHksXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQUkgQWdlbnQgc3RyZWFtaW5nIHJlcXVlc3RcbiAgICogUmV0dXJucyByYXcgUmVzcG9uc2UgZm9yIFNTRSBzdHJlYW1pbmcgKGNvbXBhdGlibGUgd2l0aCBBSSBTREsgdXNlQ2hhdClcbiAgICovXG4gIGFzeW5jIGFpQWdlbnRTdHJlYW0ocmVxdWVzdEJvZHksIHNpZ25hbCkge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVcmwoYC9hcGkvYWkvJHt0aGlzLnByb2plY3RJZH0vYWdlbnRgKTtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VmFsaWRUb2tlbiA/IGF3YWl0IHRoaXMuZ2V0VmFsaWRUb2tlbigpIDogdGhpcy5nZXRUb2tlbigpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgY29uc3QgYXV0aCA9IHRoaXMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlcih1cmwsIHRva2VuKTtcbiAgICBpZiAoYXV0aCkgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYXV0aDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZUVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJBRyBBSSBTZWFyY2ggc3RyZWFtaW5nIHJlcXVlc3RcbiAgICogUmV0dXJucyByYXcgUmVzcG9uc2UgZm9yIFNTRSBzdHJlYW1pbmdcbiAgICovXG4gIGFzeW5jIHJhZ0FpU2VhcmNoU3RyZWFtKGJvZHksIHNpZ25hbCkge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVcmwoYC9hcGkvcmFnLyR7dGhpcy5wcm9qZWN0SWR9L2FpLXNlYXJjaGApO1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5nZXRWYWxpZFRva2VuID8gYXdhaXQgdGhpcy5nZXRWYWxpZFRva2VuKCkgOiB0aGlzLmdldFRva2VuKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfTtcbiAgICBjb25zdCBhdXRoID0gdGhpcy5nZXRBdXRob3JpemF0aW9uSGVhZGVyKHVybCwgdG9rZW4pO1xuICAgIGlmIChhdXRoKSBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBhdXRoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVFcnJvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBEYXRhLXNwZWNpZmljIHJlcXVlc3RzXG4gICAqL1xuICBhc3luYyBkYXRhRXh0cmFjdEZyb21VcmwocHJvamVjdElkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9kYXRhLyR7cHJvamVjdElkfS9leHRyYWN0LWZyb20tdXJsYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGF0YUV4dHJhY3RGcm9tQmxvYihwcm9qZWN0SWQsIGZpbGUsIGNodW5raW5nLCBjaHVua1NpemUpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSk7XG4gICAgaWYgKGNodW5raW5nICE9PSB2b2lkIDApIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImNodW5raW5nXCIsIFN0cmluZyhjaHVua2luZykpO1xuICAgIH1cbiAgICBpZiAoY2h1bmtTaXplICE9PSB2b2lkIDApIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImNodW5rU2l6ZVwiLCBTdHJpbmcoY2h1bmtTaXplKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvZGF0YS8ke3Byb2plY3RJZH0vZXh0cmFjdC1mcm9tLWJsb2JgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogZm9ybURhdGFcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkYXRhU2NyYXBlKHByb2plY3RJZCwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvZGF0YS8ke3Byb2plY3RJZH0vc2NyYXBlYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGF0YVNjcmVlbnNob3QocHJvamVjdElkLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9kYXRhLyR7cHJvamVjdElkfS9zY3JlZW5zaG90YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGF0YUZldGNoKHByb2plY3RJZCwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC9hcGkvZGF0YS8ke3Byb2plY3RJZH0vZmV0Y2hgLCByZXF1ZXN0KTtcbiAgfVxuICBhc3luYyBkYXRhU2VhcmNoKHByb2plY3RJZCwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnBvc3QoYC9hcGkvZGF0YS8ke3Byb2plY3RJZH0vc2VhcmNoYCwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RvciByZXF1ZXN0c1xuICAgKi9cbiAgZm9ybWF0UHJvdmlkZXJGb3JQYXRoKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHByb3ZpZGVyLnJlcGxhY2UoXCJfXCIsIFwiLVwiKTtcbiAgfVxuICBhc3luYyBjb25uZWN0b3JTdGF0dXMocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2Nvbm5lY3RvcnMvJHt0aGlzLmZvcm1hdFByb3ZpZGVyRm9yUGF0aChwcm92aWRlcil9LyR7dGhpcy5wcm9qZWN0SWR9L3N0YXR1c2AsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIlxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbm5lY3RvckV4ZWN1dGUocHJvdmlkZXIsIHJlcXVlc3QpIHtcbiAgICBjb25zdCBwYXRoID0gcmVxdWVzdC5tZXRob2Quc3RhcnRzV2l0aChcIi9cIikgPyByZXF1ZXN0Lm1ldGhvZCA6IGAvJHtyZXF1ZXN0Lm1ldGhvZH1gO1xuICAgIGNvbnN0IHVybCA9IGAvYXBpL2Nvbm5lY3RvcnMvJHt0aGlzLmZvcm1hdFByb3ZpZGVyRm9yUGF0aChwcm92aWRlcil9LyR7dGhpcy5wcm9qZWN0SWR9JHtwYXRofWA7XG4gICAgY29uc3QgbWV0aG9kID0gKHJlcXVlc3QuaHR0cF9tZXRob2QgfHwgXCJHRVRcIikudG9VcHBlckNhc2UoKTtcbiAgICBpZiAobWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIHNlYXJjaFBhcmFtczogcmVxdWVzdC5wYXJhbXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHVybCwge1xuICAgICAgbWV0aG9kLFxuICAgICAgYm9keTogcmVxdWVzdC5wYXJhbXMgfHwge31cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjb25uZWN0b3JTYXZlQXBpS2V5KHByb3ZpZGVyLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9jb25uZWN0b3JzLyR7dGhpcy5mb3JtYXRQcm92aWRlckZvclBhdGgocHJvdmlkZXIpfS8ke3RoaXMucHJvamVjdElkfS9hcGkta2V5YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVhbHRpbWUtc3BlY2lmaWMgcmVxdWVzdHNcbiAgICovXG4gIGFzeW5jIHJlYWx0aW1lUHVibGlzaChwcm9qZWN0SWQsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KGAvYXBpL3JlYWx0aW1lLyR7cHJvamVjdElkfS9wdWJsaXNoYCwgcmVxdWVzdCk7XG4gIH1cbiAgYXN5bmMgcmVhbHRpbWVHZXRQcmVzZW5jZShwcm9qZWN0SWQsIGNoYW5uZWwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYC9hcGkvcmVhbHRpbWUvJHtwcm9qZWN0SWR9L3ByZXNlbmNlYCwgeyBjaGFubmVsIH0pO1xuICB9XG4gIGFzeW5jIHJlYWx0aW1lR2V0TWVzc2FnZXMocHJvamVjdElkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGFubmVsLCAuLi5zZWFyY2hQYXJhbXMgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAvYXBpL3JlYWx0aW1lLyR7cHJvamVjdElkfS9tZXNzYWdlc2AsIHtcbiAgICAgIGNoYW5uZWwsXG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHNlYXJjaFBhcmFtcykuZmlsdGVyKChbaywgdl0pID0+IHYgIT09IHZvaWQgMCkubWFwKChbaywgdl0pID0+IFtrLCBTdHJpbmcodildKVxuICAgICAgKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcml2YXRlIGhlbHBlciBtZXRob2RzXG4gICAqL1xuICBidWlsZFVybChwYXRoLCBzZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBiYXNlVXJsID0gcGF0aC5pbmNsdWRlcyhcIi9hcGkvYXV0aC9cIikgPyB0aGlzLmF1dGhVcmwgOiB0aGlzLmNvcmVVcmw7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgICBpZiAoc2VhcmNoUGFyYW1zKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhzZWFyY2hQYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cbiAgYXN5bmMgcGFyc2VSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKGNvbnRlbnRUeXBlPy5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGlmIChjb250ZW50VHlwZT8uaW5jbHVkZXMoXCJ0ZXh0L1wiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgfVxuICBhc3luYyBoYW5kbGVFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgbGV0IGVycm9yRGF0YTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgIGlmIChjb250ZW50VHlwZT8uaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogYXdhaXQgcmVzcG9uc2UudGV4dCgpIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IFwiVW5rbm93biBlcnJvciBvY2N1cnJlZFwiIH07XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YDtcbiAgICBlcnJvckRhdGEuZXJyb3I/LmNvZGUgfHwgZXJyb3JEYXRhLmNvZGU7XG4gICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgIGNhc2UgNDAxOlxuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IobWVzc2FnZSwgZXJyb3JEYXRhKTtcbiAgICAgIGNhc2UgNDAwOlxuICAgICAgICB0aHJvdyBuZXcgQmxpbmtWYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZXJyb3JEYXRhKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBCbGlua05ldHdvcmtFcnJvcihtZXNzYWdlLCByZXNwb25zZS5zdGF0dXMsIGVycm9yRGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBWZXJjZWwgQUkgU0RLIHY1IERhdGEgU3RyZWFtIFByb3RvY29sIChTZXJ2ZXItU2VudCBFdmVudHMpXG4gICAqIFN1cHBvcnRzIGFsbCBldmVudCB0eXBlcyBmcm9tIHRoZSBVSSBNZXNzYWdlIFN0cmVhbSBwcm90b2NvbFxuICAgKi9cbiAgYXN5bmMgcGFyc2VEYXRhU3RyZWFtUHJvdG9jb2woYm9keSwgb25DaHVuaykge1xuICAgIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIGNvbnN0IGZpbmFsUmVzdWx0ID0ge1xuICAgICAgdGV4dDogXCJcIixcbiAgICAgIHRvb2xDYWxsczogW10sXG4gICAgICB0b29sUmVzdWx0czogW10sXG4gICAgICBzb3VyY2VzOiBbXSxcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIHJlYXNvbmluZzogW11cbiAgICB9O1xuICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCBcIlwiO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICBpZiAoIWxpbmUudHJpbSgpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAobGluZSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKFwiZGF0YTogXCIpKSBjb250aW51ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvblN0ciA9IGxpbmUuc2xpY2UoNik7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gSlNPTi5wYXJzZShqc29uU3RyKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LnRleHQgKz0gcGFydC5kZWx0YTtcbiAgICAgICAgICAgICAgICAgIGlmIChvbkNodW5rKSBvbkNodW5rKHBhcnQuZGVsdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydC50ZXh0RGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LnRleHQgKz0gcGFydC50ZXh0RGVsdGE7XG4gICAgICAgICAgICAgICAgICBpZiAob25DaHVuaykgb25DaHVuayhwYXJ0LnRleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOlxuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LnRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgYXJnczogcGFydC5hcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LnRvb2xSZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2UtdXJsXCI6XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQuc291cmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgdXJsOiBwYXJ0LnVybCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0LnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQuZmlsZXMucHVzaChwYXJ0LmZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQucmVhc29uaW5nLnB1c2gocGFydC5jb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LmZpbmlzaFJlYXNvbiA9IHBhcnQuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LnVzYWdlID0gcGFydC51c2FnZTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5yZXNwb25zZSkgZmluYWxSZXN1bHQucmVzcG9uc2UgPSBwYXJ0LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5lcnJvciA9IHBhcnQuZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnQuZXJyb3IpO1xuICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgIGlmICghZmluYWxSZXN1bHQuY3VzdG9tRGF0YSkgZmluYWxSZXN1bHQuY3VzdG9tRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0LmN1c3RvbURhdGEucHVzaChwYXJ0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2Jyb3dzZXItZW52LnRzXG5mdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaGFzV2luZG93TG9jYXRpb24oKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cubG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBoYXNEb2N1bWVudCgpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUyKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93TG9jYXRpb24oKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYXRpb247XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbkhyZWYoKSB7XG4gIGNvbnN0IGxvYyA9IGdldFdpbmRvd0xvY2F0aW9uKCk7XG4gIGlmICghbG9jKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgbG9jID0gZ2V0V2luZG93TG9jYXRpb24oKTtcbiAgaWYgKCFsb2MpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBsb2Mub3JpZ2luO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb25Ib3N0bmFtZSgpIHtcbiAgY29uc3QgbG9jID0gZ2V0V2luZG93TG9jYXRpb24oKTtcbiAgaWYgKCFsb2MpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBsb2MuaG9zdG5hbWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvblBhdGhuYW1lKCkge1xuICBjb25zdCBsb2MgPSBnZXRXaW5kb3dMb2NhdGlvbigpO1xuICBpZiAoIWxvYykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvYy5wYXRobmFtZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uU2VhcmNoKCkge1xuICBjb25zdCBsb2MgPSBnZXRXaW5kb3dMb2NhdGlvbigpO1xuICBpZiAoIWxvYykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvYy5zZWFyY2g7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbkhhc2goKSB7XG4gIGNvbnN0IGxvYyA9IGdldFdpbmRvd0xvY2F0aW9uKCk7XG4gIGlmICghbG9jKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jLmhhc2g7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvblByb3RvY29sKCkge1xuICBjb25zdCBsb2MgPSBnZXRXaW5kb3dMb2NhdGlvbigpO1xuICBpZiAoIWxvYykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvYy5wcm90b2NvbDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvY2F0aW9uSG9zdCgpIHtcbiAgY29uc3QgbG9jID0gZ2V0V2luZG93TG9jYXRpb24oKTtcbiAgaWYgKCFsb2MpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBsb2MuaG9zdDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdEZ1bGxVcmwoKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHJldHVybiBudWxsO1xuICBjb25zdCBwcm90b2NvbCA9IGdldExvY2F0aW9uUHJvdG9jb2woKTtcbiAgY29uc3QgaG9zdCA9IGdldExvY2F0aW9uSG9zdCgpO1xuICBjb25zdCBwYXRobmFtZSA9IGdldExvY2F0aW9uUGF0aG5hbWUoKTtcbiAgY29uc3Qgc2VhcmNoID0gZ2V0TG9jYXRpb25TZWFyY2goKTtcbiAgY29uc3QgaGFzaCA9IGdldExvY2F0aW9uSGFzaCgpO1xuICBpZiAoIXByb3RvY29sIHx8ICFob3N0KSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0fSR7cGF0aG5hbWUgfHwgXCJcIn0ke3NlYXJjaCB8fCBcIlwifSR7aGFzaCB8fCBcIlwifWA7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudFJlZmVycmVyKCkge1xuICBpZiAoIWhhc0RvY3VtZW50KCkpIHJldHVybiBudWxsO1xuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5yZWZlcnJlciB8fCBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0V2luZG93SW5uZXJXaWR0aCgpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaXNJZnJhbWUoKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LnNlbGYgIT09IHdpbmRvdy50b3A7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTZXNzaW9uU3RvcmFnZSgpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gc3JjL2F1dGgudHNcbnZhciBCbGlua0F1dGggPSBjbGFzcyB7XG4gIGNvbmZpZztcbiAgYXV0aENvbmZpZztcbiAgYXV0aFN0YXRlO1xuICBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBhdXRoVXJsO1xuICBjb3JlVXJsO1xuICBwYXJlbnRXaW5kb3dUb2tlbnMgPSBudWxsO1xuICBpc0lmcmFtZSA9IGZhbHNlO1xuICBpbml0aWFsaXphdGlvblByb21pc2UgPSBudWxsO1xuICBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIHN0b3JhZ2U7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIGlmICghY29uZmlnLnByb2plY3RJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvamVjdElkIGlzIHJlcXVpcmVkIGZvciBhdXRoZW50aWNhdGlvblwiKTtcbiAgICB9XG4gICAgdGhpcy5hdXRoQ29uZmlnID0ge1xuICAgICAgbW9kZTogXCJtYW5hZ2VkXCIsXG4gICAgICAvLyBEZWZhdWx0IG1vZGVcbiAgICAgIGF1dGhVcmw6IFwiaHR0cHM6Ly9ibGluay5uZXdcIixcbiAgICAgIGNvcmVVcmw6IFwiaHR0cHM6Ly9jb3JlLmJsaW5rLm5ld1wiLFxuICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgICAgLy8gRGVmYXVsdCB0byB0cnVlIGZvciB3ZWIgY29tcGF0aWJpbGl0eVxuICAgICAgLi4uY29uZmlnLmF1dGhcbiAgICB9O1xuICAgIHRoaXMuYXV0aFVybCA9IHRoaXMuYXV0aENvbmZpZy5hdXRoVXJsIHx8IFwiaHR0cHM6Ly9ibGluay5uZXdcIjtcbiAgICB0aGlzLmNvcmVVcmwgPSB0aGlzLmF1dGhDb25maWcuY29yZVVybCB8fCBcImh0dHBzOi8vY29yZS5ibGluay5uZXdcIjtcbiAgICBjb25zdCBob3N0bmFtZSA9IGdldExvY2F0aW9uSG9zdG5hbWUoKTtcbiAgICBpZiAoaG9zdG5hbWUgJiYgdGhpcy5hdXRoVXJsID09PSBcImh0dHBzOi8vYmxpbmsubmV3XCIgJiYgKGhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiIHx8IGhvc3RuYW1lID09PSBcIjEyNy4wLjAuMVwiKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiXFx1MjZBMFxcdUZFMEYgVXNpbmcgZGVmYXVsdCBhdXRoVXJsIGluIGRldmVsb3BtZW50LiBTZXQgYXV0aC5hdXRoVXJsIHRvIHlvdXIgYXBwIG9yaWdpbiBmb3IgaGVhZGxlc3MgYXV0aCBlbmRwb2ludHMgdG8gd29yay5cIik7XG4gICAgfVxuICAgIGlmIChjb25maWcuYXV0aFJlcXVpcmVkICE9PSB2b2lkIDAgJiYgIWNvbmZpZy5hdXRoPy5tb2RlKSB7XG4gICAgICB0aGlzLmF1dGhDb25maWcubW9kZSA9IGNvbmZpZy5hdXRoUmVxdWlyZWQgPyBcIm1hbmFnZWRcIiA6IFwiaGVhZGxlc3NcIjtcbiAgICB9XG4gICAgdGhpcy5hdXRoU3RhdGUgPSB7XG4gICAgICB1c2VyOiBudWxsLFxuICAgICAgdG9rZW5zOiBudWxsLFxuICAgICAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuc3RvcmFnZSA9IGNvbmZpZy5hdXRoPy5zdG9yYWdlIHx8IGNvbmZpZy5zdG9yYWdlIHx8IGdldERlZmF1bHRTdG9yYWdlQWRhcHRlcigpO1xuICAgIGlmIChpc1dlYikge1xuICAgICAgdGhpcy5pc0lmcmFtZSA9IGlzSWZyYW1lKCk7XG4gICAgICB0aGlzLnNldHVwUGFyZW50V2luZG93TGlzdGVuZXIoKTtcbiAgICAgIHRoaXMuc2V0dXBDcm9zc1RhYlN5bmMoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBwcm9qZWN0LXNjb3BlZCBzdG9yYWdlIGtleVxuICAgKi9cbiAgZ2V0U3RvcmFnZUtleShzdWZmaXgpIHtcbiAgICByZXR1cm4gYGJsaW5rXyR7c3VmZml4fV8ke3RoaXMuY29uZmlnLnByb2plY3RJZH1gO1xuICB9XG4gIC8qKlxuICAgKiBNaWdyYXRlIGV4aXN0aW5nIGdsb2JhbCB0b2tlbnMgdG8gcHJvamVjdC1zY29wZWQgc3RvcmFnZVxuICAgKiBESVNBQkxFRDogV2UgZG9uJ3QgbWlncmF0ZSBnbG9iYWwgYmxpbmtfdG9rZW5zIGFueW1vcmUgYmVjYXVzZTpcbiAgICogMS4gUGxhdGZvcm0gdXNlcyBibGlua190b2tlbnMgZm9yIHBsYXRmb3JtIGF1dGggKGRpZmZlcmVudCB1c2VyKVxuICAgKiAyLiBNaWdyYXRpbmcgcGxhdGZvcm0gdG9rZW5zIHdvdWxkIGNhdXNlIHByb2plY3QgdG8gc2hvdyB3cm9uZyB1c2VyXG4gICAqIDMuIFByb2plY3RzIHNob3VsZCBhbHdheXMgYXV0aGVudGljYXRlIGZyZXNoIHZpYSB0aGVpciBvd24gZmxvd1xuICAgKi9cbiAgbWlncmF0ZUV4aXN0aW5nVG9rZW5zKCkge1xuICB9XG4gIC8qKlxuICAgKiBXYWl0IGZvciBhdXRoZW50aWNhdGlvbiBpbml0aWFsaXphdGlvbiB0byBjb21wbGV0ZVxuICAgKi9cbiAgYXN5bmMgd2FpdEZvckluaXRpYWxpemF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5pbml0aWFsaXphdGlvblByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0dXAgbGlzdGVuZXIgZm9yIHRva2VucyBmcm9tIHBhcmVudCB3aW5kb3dcbiAgICovXG4gIHNldHVwUGFyZW50V2luZG93TGlzdGVuZXIoKSB7XG4gICAgaWYgKCFpc1dlYiB8fCAhdGhpcy5pc0lmcmFtZSB8fCAhaGFzV2luZG93KCkpIHJldHVybjtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBcImh0dHBzOi8vYmxpbmsubmV3XCIgJiYgZXZlbnQub3JpZ2luICE9PSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiICYmIGV2ZW50Lm9yaWdpbiAhPT0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDFcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJCTElOS19BVVRIX1RPS0VOU1wiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEU1fSBSZWNlaXZlZCBhdXRoIHRva2VucyBmcm9tIHBhcmVudCB3aW5kb3dcIik7XG4gICAgICAgIGNvbnN0IHsgdG9rZW5zIH0gPSBldmVudC5kYXRhO1xuICAgICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnRXaW5kb3dUb2tlbnMgPSB0b2tlbnM7XG4gICAgICAgICAgdGhpcy5zZXRUb2tlbnModG9rZW5zLCBmYWxzZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3MDUgVG9rZW5zIGZyb20gcGFyZW50IHdpbmRvdyBhcHBsaWVkXCIpO1xuICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBhcHBseSBwYXJlbnQgd2luZG93IHRva2VuczpcIiwgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJCTElOS19BVVRIX0xPR09VVFwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEU0fSBSZWNlaXZlZCBsb2dvdXQgY29tbWFuZCBmcm9tIHBhcmVudCB3aW5kb3dcIik7XG4gICAgICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaGFzV2luZG93KCkgJiYgd2luZG93LnBhcmVudCAhPT0gd2luZG93KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUwNH0gUmVxdWVzdGluZyBhdXRoIHRva2VucyBmcm9tIHBhcmVudCB3aW5kb3dcIik7XG4gICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJCTElOS19SRVFVRVNUX0FVVEhfVE9LRU5TXCIsXG4gICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcucHJvamVjdElkXG4gICAgICB9LCBcIipcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGF1dGhlbnRpY2F0aW9uIGZyb20gc3RvcmVkIHRva2VucyBvciBVUkwgZnJhZ21lbnRzXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNjgwfSBJbml0aWFsaXppbmcgQmxpbmsgQXV0aC4uLlwiKTtcbiAgICB0aGlzLnNldExvYWRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubWlncmF0ZUV4aXN0aW5nVG9rZW5zKCk7XG4gICAgICBpZiAodGhpcy5pc0lmcmFtZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUwRH0gRGV0ZWN0ZWQgaWZyYW1lIGVudmlyb25tZW50LCB3YWl0aW5nIGZvciBwYXJlbnQgdG9rZW5zLi4uXCIpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50V2luZG93VG9rZW5zKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IFVzaW5nIHRva2VucyBmcm9tIHBhcmVudCB3aW5kb3dcIik7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXRUb2tlbnModGhpcy5wYXJlbnRXaW5kb3dUb2tlbnMsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmF1dGhDb25maWcuZGV0ZWN0U2Vzc2lvbkluVXJsICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCB0b2tlbnNGcm9tVXJsID0gdGhpcy5leHRyYWN0VG9rZW5zRnJvbVVybCgpO1xuICAgICAgICBpZiAodG9rZW5zRnJvbVVybCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEU1fSBGb3VuZCB0b2tlbnMgaW4gVVJMLCBzZXR0aW5nIHRoZW0uLi5cIik7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXRUb2tlbnModG9rZW5zRnJvbVVybCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5jbGVhclVybFRva2VucygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBBdXRoIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlIChmcm9tIFVSTClcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yZWRUb2tlbnMgPSBhd2FpdCB0aGlzLmdldFN0b3JlZFRva2VucygpO1xuICAgICAgaWYgKHN0b3JlZFRva2Vucykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjRCRX0gRm91bmQgc3RvcmVkIHRva2VucywgdmFsaWRhdGluZy4uLlwiLCB7XG4gICAgICAgICAgaGFzQWNjZXNzVG9rZW46ICEhc3RvcmVkVG9rZW5zLmFjY2Vzc190b2tlbixcbiAgICAgICAgICBoYXNSZWZyZXNoVG9rZW46ICEhc3RvcmVkVG9rZW5zLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgaXNzdWVkQXQ6IHN0b3JlZFRva2Vucy5pc3N1ZWRfYXQsXG4gICAgICAgICAgZXhwaXJlc0luOiBzdG9yZWRUb2tlbnMuZXhwaXJlc19pbixcbiAgICAgICAgICByZWZyZXNoRXhwaXJlc0luOiBzdG9yZWRUb2tlbnMucmVmcmVzaF9leHBpcmVzX2luLFxuICAgICAgICAgIGN1cnJlbnRUaW1lOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS50b2tlbnMgPSBzdG9yZWRUb2tlbnM7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTI3fSBUb2tlbnMgc2V0IGluIGF1dGggc3RhdGUsIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlOlwiLCAhIXRoaXMuYXV0aFN0YXRlLnRva2Vucz8ucmVmcmVzaF90b2tlbik7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlU3RvcmVkVG9rZW5zKHN0b3JlZFRva2Vucyk7XG4gICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IEF1dGggaW5pdGlhbGl6YXRpb24gY29tcGxldGUgKGZyb20gc3RvcmFnZSlcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTA0fSBTdG9yZWQgdG9rZW5zIGludmFsaWQsIGNsZWFyaW5nLi4uXCIpO1xuICAgICAgICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIE5vIHRva2VucyBmb3VuZFwiKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoUmVxdWlyZWQgJiYgaGFzV2luZG93TG9jYXRpb24oKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUwNH0gQXV0aCByZXF1aXJlZCwgcmVkaXJlY3RpbmcgdG8gYXV0aCBwYWdlLi4uXCIpO1xuICAgICAgICB0aGlzLnJlZGlyZWN0VG9BdXRoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI2QTBcXHVGRTBGIEF1dGggbm90IHJlcXVpcmVkIG9yIG5vIHdpbmRvdy5sb2NhdGlvbiwgY29udGludWluZyB3aXRob3V0IGF1dGhlbnRpY2F0aW9uXCIpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZGlyZWN0IHRvIEJsaW5rIGF1dGggcGFnZVxuICAgKi9cbiAgbG9naW4obmV4dFVybCkge1xuICAgIGlmICghaGFzV2luZG93TG9jYXRpb24oKSkge1xuICAgICAgY29uc29sZS53YXJuKFwibG9naW4oKSBjYWxsZWQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgKG5vIHdpbmRvdy5sb2NhdGlvbiBhdmFpbGFibGUpXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmVkaXJlY3RVcmwgPSBuZXh0VXJsIHx8IHRoaXMuYXV0aENvbmZpZy5yZWRpcmVjdFVybDtcbiAgICBpZiAoIXJlZGlyZWN0VXJsKSB7XG4gICAgICBjb25zdCBocmVmID0gZ2V0TG9jYXRpb25IcmVmKCk7XG4gICAgICBpZiAoaHJlZiAmJiBocmVmLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgIHJlZGlyZWN0VXJsID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZGlyZWN0VXJsID0gY29uc3RydWN0RnVsbFVybCgpIHx8IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGlyZWN0VXJsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlZGlyZWN0VXJsKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJyZWRpcmVjdF91cmxcIik7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwicmVkaXJlY3RcIik7XG4gICAgICAgIHJlZGlyZWN0VXJsID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBwYXJzZSByZWRpcmVjdCBVUkw6XCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhdXRoVXJsID0gbmV3IFVSTChcIi9hdXRoXCIsIHRoaXMuYXV0aFVybCk7XG4gICAgYXV0aFVybC5zZWFyY2hQYXJhbXMuc2V0KFwicmVkaXJlY3RfdXJsXCIsIHJlZGlyZWN0VXJsIHx8IFwiXCIpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcm9qZWN0SWQpIHtcbiAgICAgIGF1dGhVcmwuc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RfaWRcIiwgdGhpcy5jb25maWcucHJvamVjdElkKTtcbiAgICB9XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhdXRoVXJsLnRvU3RyaW5nKCk7XG4gIH1cbiAgLyoqXG4gICAqIExvZ291dCBhbmQgY2xlYXIgc3RvcmVkIHRva2Vuc1xuICAgKi9cbiAgbG9nb3V0KHJlZGlyZWN0VXJsKSB7XG4gICAgdGhpcy5jbGVhclRva2VucygpO1xuICAgIGlmIChyZWRpcmVjdFVybCAmJiBoYXNXaW5kb3dMb2NhdGlvbigpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJlZGlyZWN0VXJsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAqL1xuICBpc0F1dGhlbnRpY2F0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aFN0YXRlLmlzQXV0aGVudGljYXRlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdXNlciAoc3luYylcbiAgICovXG4gIGN1cnJlbnRVc2VyKCkge1xuICAgIHJldHVybiB0aGlzLmF1dGhTdGF0ZS51c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBhY2Nlc3MgdG9rZW5cbiAgICovXG4gIGdldFRva2VuKCkge1xuICAgIHJldHVybiB0aGlzLmF1dGhTdGF0ZS50b2tlbnM/LmFjY2Vzc190b2tlbiB8fCBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhY2Nlc3MgdG9rZW4gaXMgZXhwaXJlZCBiYXNlZCBvbiB0aW1lc3RhbXBcbiAgICovXG4gIGlzQWNjZXNzVG9rZW5FeHBpcmVkKCkge1xuICAgIGNvbnN0IHRva2VucyA9IHRoaXMuYXV0aFN0YXRlLnRva2VucztcbiAgICBpZiAoIXRva2VucyB8fCAhdG9rZW5zLmlzc3VlZF9hdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgY29uc3QgZXhwaXJlc0F0ID0gdG9rZW5zLmlzc3VlZF9hdCArIHRva2Vucy5leHBpcmVzX2luO1xuICAgIGNvbnN0IGJ1ZmZlclRpbWUgPSAzMDtcbiAgICByZXR1cm4gbm93ID49IGV4cGlyZXNBdCAtIGJ1ZmZlclRpbWU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlZnJlc2ggdG9rZW4gaXMgZXhwaXJlZCBiYXNlZCBvbiB0aW1lc3RhbXBcbiAgICovXG4gIGlzUmVmcmVzaFRva2VuRXhwaXJlZCgpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmF1dGhTdGF0ZS50b2tlbnM7XG4gICAgaWYgKCF0b2tlbnMgfHwgIXRva2Vucy5yZWZyZXNoX3Rva2VuIHx8ICF0b2tlbnMuaXNzdWVkX2F0IHx8ICF0b2tlbnMucmVmcmVzaF9leHBpcmVzX2luKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBjb25zdCBleHBpcmVzQXQgPSB0b2tlbnMuaXNzdWVkX2F0ICsgdG9rZW5zLnJlZnJlc2hfZXhwaXJlc19pbjtcbiAgICByZXR1cm4gbm93ID49IGV4cGlyZXNBdDtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgdmFsaWQgYWNjZXNzIHRva2VuLCByZWZyZXNoaW5nIGlmIG5lY2Vzc2FyeVxuICAgKi9cbiAgYXN5bmMgZ2V0VmFsaWRUb2tlbigpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmF1dGhTdGF0ZS50b2tlbnM7XG4gICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBY2Nlc3NUb2tlbkV4cGlyZWQoKSkge1xuICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IEFjY2VzcyB0b2tlbiBpcyBzdGlsbCB2YWxpZFwiKTtcbiAgICAgIHJldHVybiB0b2tlbnMuYWNjZXNzX3Rva2VuO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIlxcdTIzRjAgQWNjZXNzIHRva2VuIGV4cGlyZWQsIGF0dGVtcHRpbmcgcmVmcmVzaC4uLlwiKTtcbiAgICBpZiAodGhpcy5pc1JlZnJlc2hUb2tlbkV4cGlyZWQoKSkge1xuICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIFJlZnJlc2ggdG9rZW4gYWxzbyBleHBpcmVkLCBjbGVhcmluZyB0b2tlbnNcIik7XG4gICAgICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gICAgICBpZiAodGhpcy5jb25maWcuYXV0aFJlcXVpcmVkKSB7XG4gICAgICAgIHRoaXMucmVkaXJlY3RUb0F1dGgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWZyZXNoZWQgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgIGlmIChyZWZyZXNoZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBUb2tlbiByZWZyZXNoZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgcmV0dXJuIHRoaXMuYXV0aFN0YXRlLnRva2Vucz8uYWNjZXNzX3Rva2VuIHx8IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1Mjc0QyBUb2tlbiByZWZyZXNoIGZhaWxlZFwiKTtcbiAgICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoUmVxdWlyZWQpIHtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFRvQXV0aCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBjdXJyZW50IHVzZXIgcHJvZmlsZSBmcm9tIEFQSVxuICAgKiBHcmFjZWZ1bGx5IHdhaXRzIGZvciBhdXRoIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlIGJlZm9yZSB0aHJvd2luZyBlcnJvcnNcbiAgICovXG4gIGFzeW5jIG1lKCkge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckluaXRpYWxpemF0aW9uKCk7XG4gICAgaWYgKHRoaXMuYXV0aFN0YXRlLmlzQXV0aGVudGljYXRlZCAmJiB0aGlzLmF1dGhTdGF0ZS51c2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdXRoU3RhdGUudXNlcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmF1dGhTdGF0ZS5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmF1dGhTdGF0ZS51c2VyKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmF1dGhTdGF0ZS51c2VyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBCbGlua0F1dGhFcnJvcihcIkFVVEhfVElNRU9VVFwiIC8qIEFVVEhfVElNRU9VVCAqLywgXCJBdXRoZW50aWNhdGlvbiB0aW1lb3V0IC0gbm8gdXNlciBhdmFpbGFibGVcIikpO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25BdXRoU3RhdGVDaGFuZ2VkKChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0ZS51c2VyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZS51c2VyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5pc0xvYWRpbmcgJiYgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtBdXRoRXJyb3IoXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLywgXCJOb3QgYXV0aGVudGljYXRlZFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgdG9rZW4gPSB0aGlzLmdldFRva2VuKCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiVE9LRU5fRVhQSVJFRFwiIC8qIFRPS0VOX0VYUElSRUQgKi8sIFwiTm8gYWNjZXNzIHRva2VuIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9tZWAsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgY29uc3QgcmVmcmVzaGVkID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgICBpZiAocmVmcmVzaGVkKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICBjb25zdCByZXRyeVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9tZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAocmV0cnlSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5RGF0YSA9IGF3YWl0IHJldHJ5UmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIyID0gcmV0cnlEYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdXRoU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgLi4udGhpcy5hdXRoU3RhdGUsXG4gICAgICAgICAgICAgICAgICB1c2VyOiB1c2VyMlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGhSZXF1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdFRvQXV0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gZmV0Y2ggdXNlcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICB0aGlzLnVwZGF0ZUF1dGhTdGF0ZSh7XG4gICAgICAgIC4uLnRoaXMuYXV0aFN0YXRlLFxuICAgICAgICB1c2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLCBgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2lnbiB1cCB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCAoaGVhZGxlc3MgbW9kZSlcbiAgICovXG4gIGFzeW5jIHNpZ25VcChkYXRhKSB7XG4gICAgaWYgKHRoaXMuYXV0aENvbmZpZy5tb2RlICE9PSBcImhlYWRsZXNzXCIpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLCBcInNpZ25VcCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBoZWFkbGVzcyBtb2RlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3NpZ251cGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcucHJvamVjdElkXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShlcnJvckRhdGEuY29kZSk7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihlcnJvckNvZGUsIGVycm9yRGF0YS5lcnJvciB8fCBcIlNpZ24gdXAgZmFpbGVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgYXdhaXQgdGhpcy5zZXRUb2tlbnMoe1xuICAgICAgICBhY2Nlc3NfdG9rZW46IHJlc3VsdC5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHJlc3VsdC5yZWZyZXNoX3Rva2VuLFxuICAgICAgICB0b2tlbl90eXBlOiByZXN1bHQudG9rZW5fdHlwZSxcbiAgICAgICAgZXhwaXJlc19pbjogcmVzdWx0LmV4cGlyZXNfaW4sXG4gICAgICAgIHJlZnJlc2hfZXhwaXJlc19pbjogcmVzdWx0LnJlZnJlc2hfZXhwaXJlc19pblxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnVzZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sIGBOZXR3b3JrIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTaWduIGluIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIChoZWFkbGVzcyBtb2RlKVxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aEVtYWlsKGVtYWlsLCBwYXNzd29yZCkge1xuICAgIGlmICh0aGlzLmF1dGhDb25maWcubW9kZSAhPT0gXCJoZWFkbGVzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLywgXCJzaWduSW5XaXRoRW1haWwgaXMgb25seSBhdmFpbGFibGUgaW4gaGVhZGxlc3MgbW9kZVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9zaWduaW4vZW1haWxgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5wcm9qZWN0SWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiU2lnbiBpbiBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh7XG4gICAgICAgIGFjY2Vzc190b2tlbjogcmVzdWx0LmFjY2Vzc190b2tlbixcbiAgICAgICAgcmVmcmVzaF90b2tlbjogcmVzdWx0LnJlZnJlc2hfdG9rZW4sXG4gICAgICAgIHRva2VuX3R5cGU6IHJlc3VsdC50b2tlbl90eXBlLFxuICAgICAgICBleHBpcmVzX2luOiByZXN1bHQuZXhwaXJlc19pbixcbiAgICAgICAgcmVmcmVzaF9leHBpcmVzX2luOiByZXN1bHQucmVmcmVzaF9leHBpcmVzX2luXG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHJldHVybiByZXN1bHQudXNlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gaW4gd2l0aCBHb29nbGUgKGhlYWRsZXNzIG1vZGUpXG4gICAqIFxuICAgKiAqKlVuaXZlcnNhbCBPQXV0aCoqIC0gV29ya3Mgb24gYm90aCBXZWIgYW5kIFJlYWN0IE5hdGl2ZSFcbiAgICogXG4gICAqIE9uIFJlYWN0IE5hdGl2ZSwgcmVxdWlyZXMgYHdlYkJyb3dzZXJgIHRvIGJlIGNvbmZpZ3VyZWQgaW4gY2xpZW50OlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGJsaW5rID0gY3JlYXRlQ2xpZW50KHtcbiAgICogICBhdXRoOiB7IG1vZGU6ICdoZWFkbGVzcycsIHdlYkJyb3dzZXI6IFdlYkJyb3dzZXIgfVxuICAgKiB9KVxuICAgKiBhd2FpdCBibGluay5hdXRoLnNpZ25JbldpdGhHb29nbGUoKSAvLyBXb3JrcyBvbiBib3RoIHBsYXRmb3JtcyFcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoR29vZ2xlKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5hdXRoQ29uZmlnLm1vZGUgIT09IFwiaGVhZGxlc3NcIikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiSU5WQUxJRF9DUkVERU5USUFMU1wiIC8qIElOVkFMSURfQ1JFREVOVElBTFMgKi8sIFwic2lnbkluV2l0aEdvb2dsZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBoZWFkbGVzcyBtb2RlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduSW5XaXRoUHJvdmlkZXIoXCJnb29nbGVcIiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gaW4gd2l0aCBHaXRIdWIgKGhlYWRsZXNzIG1vZGUpXG4gICAqIFxuICAgKiAqKlVuaXZlcnNhbCBPQXV0aCoqIC0gV29ya3Mgb24gYm90aCBXZWIgYW5kIFJlYWN0IE5hdGl2ZSFcbiAgICogU2VlIHNpZ25JbldpdGhHb29nbGUoKSBmb3Igc2V0dXAgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aEdpdEh1YihvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuYXV0aENvbmZpZy5tb2RlICE9PSBcImhlYWRsZXNzXCIpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLCBcInNpZ25JbldpdGhHaXRIdWIgaXMgb25seSBhdmFpbGFibGUgaW4gaGVhZGxlc3MgbW9kZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnbkluV2l0aFByb3ZpZGVyKFwiZ2l0aHViXCIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIGluIHdpdGggQXBwbGUgKGhlYWRsZXNzIG1vZGUpXG4gICAqIFxuICAgKiAqKlVuaXZlcnNhbCBPQXV0aCoqIC0gV29ya3Mgb24gYm90aCBXZWIgYW5kIFJlYWN0IE5hdGl2ZSFcbiAgICogU2VlIHNpZ25JbldpdGhHb29nbGUoKSBmb3Igc2V0dXAgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgYXN5bmMgc2lnbkluV2l0aEFwcGxlKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5hdXRoQ29uZmlnLm1vZGUgIT09IFwiaGVhZGxlc3NcIikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiSU5WQUxJRF9DUkVERU5USUFMU1wiIC8qIElOVkFMSURfQ1JFREVOVElBTFMgKi8sIFwic2lnbkluV2l0aEFwcGxlIGlzIG9ubHkgYXZhaWxhYmxlIGluIGhlYWRsZXNzIG1vZGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25JbldpdGhQcm92aWRlcihcImFwcGxlXCIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIGluIHdpdGggTWljcm9zb2Z0IChoZWFkbGVzcyBtb2RlKVxuICAgKiBcbiAgICogKipVbml2ZXJzYWwgT0F1dGgqKiAtIFdvcmtzIG9uIGJvdGggV2ViIGFuZCBSZWFjdCBOYXRpdmUhXG4gICAqIFNlZSBzaWduSW5XaXRoR29vZ2xlKCkgZm9yIHNldHVwIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhNaWNyb3NvZnQob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmF1dGhDb25maWcubW9kZSAhPT0gXCJoZWFkbGVzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLywgXCJzaWduSW5XaXRoTWljcm9zb2Z0IGlzIG9ubHkgYXZhaWxhYmxlIGluIGhlYWRsZXNzIG1vZGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25JbldpdGhQcm92aWRlcihcIm1pY3Jvc29mdFwiLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgT0F1dGggZm9yIG1vYmlsZSB3aXRob3V0IGRlZXAgbGlua2luZyAoZXhwby13ZWItYnJvd3NlciBwYXR0ZXJuKVxuICAgKiBcbiAgICogVGhpcyBtZXRob2Q6XG4gICAqIDEuIEdlbmVyYXRlcyBhIHVuaXF1ZSBzZXNzaW9uIElEXG4gICAqIDIuIFJldHVybnMgT0F1dGggVVJMIHdpdGggc2Vzc2lvbiBwYXJhbWV0ZXJcbiAgICogMy4gQXBwIG9wZW5zIFVSTCBpbiBleHBvLXdlYi1icm93c2VyXG4gICAqIDQuIEFwcCBwb2xscyBjaGVja01vYmlsZU9BdXRoU2Vzc2lvbigpIHVudGlsIGNvbXBsZXRlXG4gICAqIFxuICAgKiBAcGFyYW0gcHJvdmlkZXIgLSBPQXV0aCBwcm92aWRlciAoZ29vZ2xlLCBnaXRodWIsIGFwcGxlLCBldGMuKVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIG1ldGFkYXRhXG4gICAqIEByZXR1cm5zIFNlc3Npb24gSUQgYW5kIE9BdXRoIFVSTFxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUmVhY3QgTmF0aXZlIHdpdGggZXhwby13ZWItYnJvd3NlclxuICAgKiBpbXBvcnQgKiBhcyBXZWJCcm93c2VyIGZyb20gJ2V4cG8td2ViLWJyb3dzZXInO1xuICAgKiBcbiAgICogY29uc3QgeyBzZXNzaW9uSWQsIGF1dGhVcmwgfSA9IGF3YWl0IGJsaW5rLmF1dGguaW5pdGlhdGVNb2JpbGVPQXV0aCgnZ29vZ2xlJyk7XG4gICAqIFxuICAgKiAvLyBPcGVuIGJyb3dzZXJcbiAgICogYXdhaXQgV2ViQnJvd3Nlci5vcGVuQXV0aFNlc3Npb25Bc3luYyhhdXRoVXJsKTtcbiAgICogXG4gICAqIC8vIFBvbGwgZm9yIGNvbXBsZXRpb25cbiAgICogY29uc3QgdXNlciA9IGF3YWl0IGJsaW5rLmF1dGgucG9sbE1vYmlsZU9BdXRoU2Vzc2lvbihzZXNzaW9uSWQpO1xuICAgKiBjb25zb2xlLmxvZygnQXV0aGVudGljYXRlZDonLCB1c2VyLmVtYWlsKTtcbiAgICovXG4gIGFzeW5jIGluaXRpYXRlTW9iaWxlT0F1dGgocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5hdXRoQ29uZmlnLm1vZGUgIT09IFwiaGVhZGxlc3NcIikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICBcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovLFxuICAgICAgICBcImluaXRpYXRlTW9iaWxlT0F1dGggaXMgb25seSBhdmFpbGFibGUgaW4gaGVhZGxlc3MgbW9kZVwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBzZXNzaW9uSWQgPSB0aGlzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgY29uc3QgYXV0aFVybCA9IG5ldyBVUkwoXCIvYXV0aFwiLCB0aGlzLmF1dGhVcmwpO1xuICAgIGF1dGhVcmwuc2VhcmNoUGFyYW1zLnNldChcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICBhdXRoVXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJwcm9qZWN0X2lkXCIsIHRoaXMuY29uZmlnLnByb2plY3RJZCk7XG4gICAgYXV0aFVybC5zZWFyY2hQYXJhbXMuc2V0KFwibW9kZVwiLCBcIm1vYmlsZS1zZXNzaW9uXCIpO1xuICAgIGF1dGhVcmwuc2VhcmNoUGFyYW1zLnNldChcInNlc3Npb25faWRcIiwgc2Vzc2lvbklkKTtcbiAgICBpZiAob3B0aW9ucz8ubWV0YWRhdGEpIHtcbiAgICAgIGF1dGhVcmwuc2VhcmNoUGFyYW1zLnNldChcIm1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMubWV0YWRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIGF1dGhVcmw6IGF1dGhVcmwudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIG1vYmlsZSBPQXV0aCBzZXNzaW9uIHN0YXR1cyAoc2luZ2xlIGNoZWNrKVxuICAgKiBcbiAgICogQHBhcmFtIHNlc3Npb25JZCAtIFNlc3Npb24gSUQgZnJvbSBpbml0aWF0ZU1vYmlsZU9BdXRoXG4gICAqIEByZXR1cm5zIFRva2VucyBpZiBzZXNzaW9uIGlzIGNvbXBsZXRlLCBudWxsIGlmIHN0aWxsIHBlbmRpbmdcbiAgICovXG4gIGFzeW5jIGNoZWNrTW9iaWxlT0F1dGhTZXNzaW9uKHNlc3Npb25JZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvbW9iaWxlLXNlc3Npb24vJHtzZXNzaW9uSWR9YCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShlcnJvckRhdGEuY29kZSk7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcbiAgICAgICAgICBlcnJvckNvZGUsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIGNoZWNrIE9BdXRoIHNlc3Npb25cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjY2Vzc190b2tlbjogZGF0YS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IGRhdGEucmVmcmVzaF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZTogZGF0YS50b2tlbl90eXBlIHx8IFwiQmVhcmVyXCIsXG4gICAgICAgIGV4cGlyZXNfaW46IGRhdGEuZXhwaXJlc19pbiB8fCAzNjAwLFxuICAgICAgICByZWZyZXNoX2V4cGlyZXNfaW46IGRhdGEucmVmcmVzaF9leHBpcmVzX2luXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcbiAgICAgICAgXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLyxcbiAgICAgICAgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUG9sbCBtb2JpbGUgT0F1dGggc2Vzc2lvbiB1bnRpbCBjb21wbGV0ZSAoY29udmVuaWVuY2UgbWV0aG9kKVxuICAgKiBcbiAgICogQHBhcmFtIHNlc3Npb25JZCAtIFNlc3Npb24gSUQgZnJvbSBpbml0aWF0ZU1vYmlsZU9BdXRoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUG9sbGluZyBvcHRpb25zXG4gICAqIEByZXR1cm5zIEF1dGhlbnRpY2F0ZWQgdXNlclxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgeyBzZXNzaW9uSWQsIGF1dGhVcmwgfSA9IGF3YWl0IGJsaW5rLmF1dGguaW5pdGlhdGVNb2JpbGVPQXV0aCgnZ29vZ2xlJyk7XG4gICAqIGF3YWl0IFdlYkJyb3dzZXIub3BlbkF1dGhTZXNzaW9uQXN5bmMoYXV0aFVybCk7XG4gICAqIGNvbnN0IHVzZXIgPSBhd2FpdCBibGluay5hdXRoLnBvbGxNb2JpbGVPQXV0aFNlc3Npb24oc2Vzc2lvbklkLCB7XG4gICAqICAgbWF4QXR0ZW1wdHM6IDYwLFxuICAgKiAgIGludGVydmFsTXM6IDEwMDBcbiAgICogfSk7XG4gICAqL1xuICBhc3luYyBwb2xsTW9iaWxlT0F1dGhTZXNzaW9uKHNlc3Npb25JZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gb3B0aW9ucz8ubWF4QXR0ZW1wdHMgfHwgNjA7XG4gICAgY29uc3QgaW50ZXJ2YWxNcyA9IG9wdGlvbnM/LmludGVydmFsTXMgfHwgMWUzO1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgdGhpcy5jaGVja01vYmlsZU9BdXRoU2Vzc2lvbihzZXNzaW9uSWQpO1xuICAgICAgaWYgKHRva2Vucykge1xuICAgICAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh0b2tlbnMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoU3RhdGUudXNlcjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsTXMpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgXCJBVVRIX1RJTUVPVVRcIiAvKiBBVVRIX1RJTUVPVVQgKi8sXG4gICAgICBcIk1vYmlsZSBPQXV0aCBzZXNzaW9uIHRpbWVkIG91dFwiXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiBpbiB3aXRoIE9BdXRoIHByb3ZpZGVyIHVzaW5nIGV4cG8td2ViLWJyb3dzZXIgKFJlYWN0IE5hdGl2ZSlcbiAgICogXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCBoYW5kbGVzIHRoZSBlbnRpcmUgZmxvdzpcbiAgICogMS4gSW5pdGlhdGVzIG1vYmlsZSBPQXV0aCBzZXNzaW9uXG4gICAqIDIuIFJldHVybnMgYXV0aCBVUkwgdG8gb3BlbiBpbiBXZWJCcm93c2VyXG4gICAqIDMuIFByb3ZpZGVzIHBvbGxpbmcgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBicm93c2VyIG9wZW5zXG4gICAqIFxuICAgKiBAcGFyYW0gcHJvdmlkZXIgLSBPQXV0aCBwcm92aWRlclxuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBhdXRoVXJsIGFuZCBhdXRoZW50aWNhdGUgZnVuY3Rpb25cbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIFdlYkJyb3dzZXIgZnJvbSAnZXhwby13ZWItYnJvd3Nlcic7XG4gICAqIFxuICAgKiBjb25zdCB7IGF1dGhVcmwsIGF1dGhlbnRpY2F0ZSB9ID0gYXdhaXQgYmxpbmsuYXV0aC5zaWduSW5XaXRoUHJvdmlkZXJNb2JpbGUoJ2dvb2dsZScpO1xuICAgKiBcbiAgICogLy8gT3BlbiBicm93c2VyXG4gICAqIGF3YWl0IFdlYkJyb3dzZXIub3BlbkF1dGhTZXNzaW9uQXN5bmMoYXV0aFVybCk7XG4gICAqIFxuICAgKiAvLyBXYWl0IGZvciBhdXRoZW50aWNhdGlvblxuICAgKiBjb25zdCB1c2VyID0gYXdhaXQgYXV0aGVudGljYXRlKCk7XG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoUHJvdmlkZXJNb2JpbGUocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNlc3Npb25JZCwgYXV0aFVybCB9ID0gYXdhaXQgdGhpcy5pbml0aWF0ZU1vYmlsZU9BdXRoKHByb3ZpZGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXV0aFVybCxcbiAgICAgIGF1dGhlbnRpY2F0ZTogKCkgPT4gdGhpcy5wb2xsTW9iaWxlT0F1dGhTZXNzaW9uKHNlc3Npb25JZCwge1xuICAgICAgICBtYXhBdHRlbXB0czogNjAsXG4gICAgICAgIGludGVydmFsTXM6IDFlM1xuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVbml2ZXJzYWwgT0F1dGggZmxvdyB1c2luZyBzZXNzaW9uLWJhc2VkIGF1dGhlbnRpY2F0aW9uIChpbnRlcm5hbClcbiAgICogV29ya3Mgb24gQUxMIHBsYXRmb3JtczogV2ViLCBpT1MsIEFuZHJvaWRcbiAgICogVXNlcyBleHBvLXdlYi1icm93c2VyIHRvIG9wZW4gYXV0aCBVUkwgYW5kIHBvbGxzIGZvciBjb21wbGV0aW9uXG4gICAqL1xuICBhc3luYyBzaWduSW5XaXRoUHJvdmlkZXJVbml2ZXJzYWwocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3ZWJCcm93c2VyID0gdGhpcy5hdXRoQ29uZmlnLndlYkJyb3dzZXI7XG4gICAgaWYgKCF3ZWJCcm93c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgIFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sXG4gICAgICAgIFwid2ViQnJvd3NlciBtb2R1bGUgaXMgcmVxdWlyZWQgZm9yIHVuaXZlcnNhbCBPQXV0aCBmbG93XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBhdXRoVXJsIH0gPSBhd2FpdCB0aGlzLmluaXRpYXRlTW9iaWxlT0F1dGgocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTEwfSBPcGVuaW5nIE9BdXRoIGJyb3dzZXIgZm9yXCIsIHByb3ZpZGVyKTtcbiAgICBjb25zdCBicm93c2VyUHJvbWlzZSA9IHdlYkJyb3dzZXIub3BlbkF1dGhTZXNzaW9uQXN5bmMoYXV0aFVybCk7XG4gICAgY29uc3QgcmFjZVJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICBicm93c2VyUHJvbWlzZS50aGVuKChyZXN1bHQpID0+ICh7IGNsb3NlZDogdHJ1ZSwgcmVzdWx0IH0pKS5jYXRjaCgoZXJyKSA9PiAoeyBjbG9zZWQ6IHRydWUsIGVycm9yOiBlcnIgfSkpLFxuICAgICAgbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoeyBjbG9zZWQ6IGZhbHNlIH0pLCA1ZTMpXG4gICAgICApXG4gICAgXSk7XG4gICAgaWYgKHJhY2VSZXN1bHQuY2xvc2VkKSB7XG4gICAgICBpZiAoXCJyZXN1bHRcIiBpbiByYWNlUmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTEwfSBCcm93c2VyIGNsb3NlZCB3aXRoIHJlc3VsdDpcIiwgcmFjZVJlc3VsdC5yZXN1bHQudHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUxMH0gQnJvd3NlciBjbG9zZWQgd2l0aCBlcnJvclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY1MTB9IEJyb3dzZXIgc3RpbGwgb3BlbiAobmV3IHRhYi9zdHVjayBwb3B1cCksIHN0YXJ0aW5nIHRvIHBvbGwuLi5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnBvbGxNb2JpbGVPQXV0aFNlc3Npb24oc2Vzc2lvbklkLCB7XG4gICAgICBtYXhBdHRlbXB0czogMTIwLFxuICAgICAgLy8gNjAgc2Vjb25kcyAoZ2l2ZSB1c2VyIHRpbWUgdG8gY29tcGxldGUgYXV0aClcbiAgICAgIGludGVydmFsTXM6IDUwMFxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBPQXV0aCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmljIHByb3ZpZGVyIHNpZ24taW4gbWV0aG9kIChoZWFkbGVzcyBtb2RlKVxuICAgKiBcbiAgICogKipVbml2ZXJzYWwgT0F1dGgqKiAtIFdvcmtzIHNlYW1sZXNzbHkgb24gYm90aCBXZWIgYW5kIFJlYWN0IE5hdGl2ZSFcbiAgICogXG4gICAqIFdoZW4gYHdlYkJyb3dzZXJgIGlzIGNvbmZpZ3VyZWQgaW4gdGhlIGNsaWVudCwgdGhpcyBtZXRob2QgYXV0b21hdGljYWxseVxuICAgKiB1c2VzIHRoZSBzZXNzaW9uLWJhc2VkIE9BdXRoIGZsb3cgdGhhdCB3b3JrcyBvbiBBTEwgcGxhdGZvcm1zLlxuICAgKiBcbiAgICogKipVbml2ZXJzYWwgU2V0dXAgKGNvbmZpZ3VyZSBvbmNlLCB3b3JrcyBldmVyeXdoZXJlKToqKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGltcG9ydCAqIGFzIFdlYkJyb3dzZXIgZnJvbSAnZXhwby13ZWItYnJvd3NlcidcbiAgICogaW1wb3J0IEFzeW5jU3RvcmFnZSBmcm9tICdAcmVhY3QtbmF0aXZlLWFzeW5jLXN0b3JhZ2UvYXN5bmMtc3RvcmFnZSdcbiAgICogXG4gICAqIGNvbnN0IGJsaW5rID0gY3JlYXRlQ2xpZW50KHtcbiAgICogICBwcm9qZWN0SWQ6ICd5b3VyLXByb2plY3QnLFxuICAgKiAgIGF1dGg6IHtcbiAgICogICAgIG1vZGU6ICdoZWFkbGVzcycsXG4gICAqICAgICB3ZWJCcm93c2VyOiBXZWJCcm93c2VyICAvLyBQYXNzIHRoZSBtb2R1bGUgaGVyZVxuICAgKiAgIH0sXG4gICAqICAgc3RvcmFnZTogbmV3IEFzeW5jU3RvcmFnZUFkYXB0ZXIoQXN5bmNTdG9yYWdlKVxuICAgKiB9KVxuICAgKiBcbiAgICogLy8gTm93IHRoaXMgd29ya3Mgb24gQUxMIHBsYXRmb3JtcyAtIG5vIHBsYXRmb3JtIGNoZWNrcyBuZWVkZWQhXG4gICAqIGNvbnN0IHVzZXIgPSBhd2FpdCBibGluay5hdXRoLnNpZ25JbldpdGhHb29nbGUoKVxuICAgKiBgYGBcbiAgICogXG4gICAqIEBwYXJhbSBwcm92aWRlciAtIE9BdXRoIHByb3ZpZGVyIChnb29nbGUsIGdpdGh1YiwgYXBwbGUsIGV0Yy4pXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgcmVkaXJlY3QgVVJMIGFuZCBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhdXRoZW50aWNhdGVkIHVzZXJcbiAgICovXG4gIGFzeW5jIHNpZ25JbldpdGhQcm92aWRlcihwcm92aWRlciwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLmF1dGhDb25maWcubW9kZSAhPT0gXCJoZWFkbGVzc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLywgXCJzaWduSW5XaXRoUHJvdmlkZXIgaXMgb25seSBhdmFpbGFibGUgaW4gaGVhZGxlc3MgbW9kZVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0aENvbmZpZy53ZWJCcm93c2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduSW5XaXRoUHJvdmlkZXJVbml2ZXJzYWwocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZTIoKSkge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICBcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLFxuICAgICAgICAnUmVhY3QgTmF0aXZlIE9BdXRoIHJlcXVpcmVzIHdlYkJyb3dzZXIgaW4gY29uZmlnIVxcblxcbmltcG9ydCAqIGFzIFdlYkJyb3dzZXIgZnJvbSBcImV4cG8td2ViLWJyb3dzZXJcIjtcXG5cXG5jb25zdCBibGluayA9IGNyZWF0ZUNsaWVudCh7XFxuICBwcm9qZWN0SWQ6IFwieW91ci1wcm9qZWN0XCIsXFxuICBhdXRoOiB7XFxuICAgIG1vZGU6IFwiaGVhZGxlc3NcIixcXG4gICAgd2ViQnJvd3NlcjogV2ViQnJvd3NlclxcbiAgfVxcbn0pXFxuXFxuYXdhaXQgYmxpbmsuYXV0aC5zaWduSW5XaXRoR29vZ2xlKCkgLy8gV29ya3Mgb24gYWxsIHBsYXRmb3JtcyEnXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgXCJzaWduSW5XaXRoUHJvdmlkZXIgcmVxdWlyZXMgYSBicm93c2VyIGVudmlyb25tZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRQcmVmZXJSZWRpcmVjdCA9IGlzV2ViICYmIHRoaXMuaXNJZnJhbWUgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY3Jvc3NPcmlnaW5Jc29sYXRlZCA9PT0gdHJ1ZTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2VuZXJhdGVTdGF0ZSgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXNzaW9uU3RvcmFnZSA9IGdldFNlc3Npb25TdG9yYWdlKCk7XG4gICAgICBpZiAoc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcImJsaW5rX29hdXRoX3N0YXRlXCIsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RVcmwgPSBvcHRpb25zPy5yZWRpcmVjdFVybCB8fCBnZXRMb2NhdGlvbk9yaWdpbigpIHx8IFwiXCI7XG4gICAgY29uc3QgYnVpbGRBdXRoVXJsID0gKG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXCIvYXV0aFwiLCB0aGlzLmF1dGhVcmwpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RfaWRcIiwgdGhpcy5jb25maWcucHJvamVjdElkKTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic3RhdGVcIiwgc3RhdGUpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJtb2RlXCIsIG1vZGUpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJyZWRpcmVjdF91cmxcIiwgcmVkaXJlY3RVcmwpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJvcGVuZXJfb3JpZ2luXCIsIGdldExvY2F0aW9uT3JpZ2luKCkgfHwgXCJcIik7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgaWYgKHNob3VsZFByZWZlclJlZGlyZWN0KSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGJ1aWxkQXV0aFVybChcInJlZGlyZWN0XCIpLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwb3B1cFVybCA9IGJ1aWxkQXV0aFVybChcInBvcHVwXCIpO1xuICAgICAgY29uc3QgcG9wdXAgPSB3aW5kb3cub3BlbihcbiAgICAgICAgcG9wdXBVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgXCJibGluay1hdXRoXCIsXG4gICAgICAgIFwid2lkdGg9NTAwLGhlaWdodD02MDAsc2Nyb2xsYmFycz15ZXMscmVzaXphYmxlPXllc1wiXG4gICAgICApO1xuICAgICAgaWYgKCFwb3B1cCkge1xuICAgICAgICByZWplY3QobmV3IEJsaW5rQXV0aEVycm9yKFwiUE9QVVBfQ0FOQ0VMRURcIiAvKiBQT1BVUF9DQU5DRUxFRCAqLywgXCJQb3B1cCB3YXMgYmxvY2tlZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICBsZXQgY2xvc2VkSW50ZXJ2YWxJZDtcbiAgICAgIGxldCBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjbGVhbmVkVXApIHJldHVybjtcbiAgICAgICAgY2xlYW5lZFVwID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGlmIChjbG9zZWRJbnRlcnZhbElkKSBjbGVhckludGVydmFsKGNsb3NlZEludGVydmFsSWQpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbWVzc2FnZUxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBtZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhdXRoT3JpZ2luID0gbmV3IFVSTCh0aGlzLmF1dGhVcmwpLm9yaWdpbjtcbiAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luID09PSBhdXRoT3JpZ2luKSBhbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiA9PT0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIiB8fCBldmVudC5vcmlnaW4gPT09IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCIpIGFsbG93ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWFsbG93ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiQkxJTktfQVVUSF9UT0tFTlNcIikge1xuICAgICAgICAgIGNvbnN0IHsgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuLCB0b2tlbl90eXBlLCBleHBpcmVzX2luLCByZWZyZXNoX2V4cGlyZXNfaW4sIHByb2plY3RJZCwgc3RhdGU6IHJldHVybmVkU3RhdGUgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25TdG9yYWdlID0gZ2V0U2Vzc2lvblN0b3JhZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gc2Vzc2lvblN0b3JhZ2U/LmdldEl0ZW0oXCJibGlua19vYXV0aF9zdGF0ZVwiKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZFN0YXRlICYmIGV4cGVjdGVkICYmIHJldHVybmVkU3RhdGUgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtBdXRoRXJyb3IoXCJWRVJJRklDQVRJT05fRkFJTEVEXCIgLyogVkVSSUZJQ0FUSU9OX0ZBSUxFRCAqLywgXCJTdGF0ZSBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbWVzc2FnZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvamVjdElkICE9PSB0aGlzLmNvbmZpZy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtBdXRoRXJyb3IoXCJJTlZBTElEX0NSRURFTlRJQUxTXCIgLyogSU5WQUxJRF9DUkVERU5USUFMUyAqLywgXCJQcm9qZWN0IElEIG1pc21hdGNoXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRUb2tlbnMoe1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgIHRva2VuX3R5cGUsXG4gICAgICAgICAgICBleHBpcmVzX2luLFxuICAgICAgICAgICAgcmVmcmVzaF9leHBpcmVzX2luXG4gICAgICAgICAgfSwgdHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuYXV0aFN0YXRlLnVzZXIpO1xuICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIHBvcHVwLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJCTElOS19BVVRIX0VSUk9SXCIpIHtcbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShldmVudC5kYXRhLmNvZGUpO1xuICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtBdXRoRXJyb3IoZXJyb3JDb2RlLCBldmVudC5kYXRhLm1lc3NhZ2UgfHwgXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICBwb3B1cC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHBvcHVwLm9wZW5lciA9PT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBvcHVwLmNsb3NlKCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBidWlsZEF1dGhVcmwoXCJyZWRpcmVjdFwiKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBpZiAoIXBvcHVwLmNsb3NlZCkge1xuICAgICAgICAgIHBvcHVwLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KG5ldyBCbGlua0F1dGhFcnJvcihcIkFVVEhfVElNRU9VVFwiIC8qIEFVVEhfVElNRU9VVCAqLywgXCJBdXRoZW50aWNhdGlvbiB0aW1lZCBvdXRcIikpO1xuICAgICAgfSwgM2U1KTtcbiAgICAgIGNsb3NlZEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmIChwb3B1cC5jbG9zZWQpIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBCbGlua0F1dGhFcnJvcihcIlBPUFVQX0NBTkNFTEVEXCIgLyogUE9QVVBfQ0FOQ0VMRUQgKi8sIFwiQXV0aGVudGljYXRpb24gd2FzIGNhbmNlbGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSwgMWUzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtZXNzYWdlTGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBwYXNzd29yZCByZXNldCB0b2tlbiAoZm9yIGN1c3RvbSBlbWFpbCBkZWxpdmVyeSlcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlUGFzc3dvcmRSZXNldFRva2VuKGVtYWlsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9wYXNzd29yZC9yZXNldC9nZW5lcmF0ZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuY29uZmlnLnByb2plY3RJZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgICAgZXJyb3JDb2RlLFxuICAgICAgICAgIGVycm9yRGF0YS5lcnJvciB8fCBcIkZhaWxlZCB0byBnZW5lcmF0ZSBwYXNzd29yZCByZXNldCB0b2tlblwiLFxuICAgICAgICAgIGVycm9yRGF0YS5lcnJvclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcbiAgICAgICAgXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLyxcbiAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcGFzc3dvcmQgcmVzZXQgdG9rZW5cIixcbiAgICAgICAgXCJOZXR3b3JrIGVycm9yIG9jY3VycmVkXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kIHBhc3N3b3JkIHJlc2V0IGVtYWlsICh1c2luZyBCbGluayBkZWZhdWx0IGVtYWlsIHNlcnZpY2UpXG4gICAqL1xuICBhc3luYyBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGVtYWlsLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9wYXNzd29yZC9yZXNldGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuY29uZmlnLnByb2plY3RJZCxcbiAgICAgICAgICByZWRpcmVjdFVybDogb3B0aW9ucz8ucmVkaXJlY3RVcmxcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIHNlbmQgcGFzc3dvcmQgcmVzZXQgZW1haWxcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sIGBOZXR3b3JrIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25maXJtIHBhc3N3b3JkIHJlc2V0IHdpdGggdG9rZW5cbiAgICovXG4gIGFzeW5jIGNvbmZpcm1QYXNzd29yZFJlc2V0KHRva2VuLCBuZXdQYXNzd29yZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvcGFzc3dvcmQvcmVzZXQvY29uZmlybWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0b2tlbixcbiAgICAgICAgICBwYXNzd29yZDogbmV3UGFzc3dvcmQsXG4gICAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5wcm9qZWN0SWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIHJlc2V0IHBhc3N3b3JkXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0F1dGhFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLCBgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIHBhc3N3b3JkIChyZXF1aXJlcyBjdXJyZW50IGF1dGhlbnRpY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgY2hhbmdlUGFzc3dvcmQob2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkKSB7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFZhbGlkVG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJUT0tFTl9FWFBJUkVEXCIgLyogVE9LRU5fRVhQSVJFRCAqLywgXCJObyBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3Bhc3N3b3JkL2NoYW5nZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgb2xkUGFzc3dvcmQsXG4gICAgICAgICAgbmV3UGFzc3dvcmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIGNoYW5nZSBwYXNzd29yZFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGVtYWlsIHZlcmlmaWNhdGlvbiB0b2tlbiAoZm9yIGN1c3RvbSBlbWFpbCBkZWxpdmVyeSlcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlRW1haWxWZXJpZmljYXRpb25Ub2tlbigpIHtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuZ2V0VmFsaWRUb2tlbigpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihcIlRPS0VOX0VYUElSRURcIiAvKiBUT0tFTl9FWFBJUkVEICovLCBcIk5vIGFjY2VzcyB0b2tlbiBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvZW1haWwvdmVyaWZ5L2dlbmVyYXRlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICAgIGVycm9yQ29kZSxcbiAgICAgICAgICBlcnJvckRhdGEuZXJyb3IgfHwgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgZW1haWwgdmVyaWZpY2F0aW9uIHRva2VuXCIsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICBcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLFxuICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSBlbWFpbCB2ZXJpZmljYXRpb24gdG9rZW5cIixcbiAgICAgICAgXCJOZXR3b3JrIGVycm9yIG9jY3VycmVkXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kIGVtYWlsIHZlcmlmaWNhdGlvbiAodXNpbmcgQmxpbmsgZGVmYXVsdCBlbWFpbCBzZXJ2aWNlKVxuICAgKi9cbiAgYXN5bmMgc2VuZEVtYWlsVmVyaWZpY2F0aW9uKCkge1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5nZXRWYWxpZFRva2VuKCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiVE9LRU5fRVhQSVJFRFwiIC8qIFRPS0VOX0VYUElSRUQgKi8sIFwiTm8gYWNjZXNzIHRva2VuIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9lbWFpbC92ZXJpZnkvc2VuZGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShlcnJvckRhdGEuY29kZSk7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihlcnJvckNvZGUsIGVycm9yRGF0YS5lcnJvciB8fCBcIkZhaWxlZCB0byBzZW5kIHZlcmlmaWNhdGlvbiBlbWFpbFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmeSBlbWFpbCB3aXRoIHRva2VuXG4gICAqL1xuICBhc3luYyB2ZXJpZnlFbWFpbCh0b2tlbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvZW1haWwvdmVyaWZ5YCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcucHJvamVjdElkXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShlcnJvckRhdGEuY29kZSk7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihlcnJvckNvZGUsIGVycm9yRGF0YS5lcnJvciB8fCBcIkZhaWxlZCB0byB2ZXJpZnkgZW1haWxcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sIGBOZXR3b3JrIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBtYWdpYyBsaW5rIHRva2VuIChmb3IgY3VzdG9tIGVtYWlsIGRlbGl2ZXJ5KVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVNYWdpY0xpbmtUb2tlbihlbWFpbCwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvc2lnbmluL21hZ2ljL2dlbmVyYXRlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgIHJlZGlyZWN0VXJsOiBvcHRpb25zPy5yZWRpcmVjdFVybCxcbiAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuY29uZmlnLnByb2plY3RJZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5tYXBFcnJvckNvZGVGcm9tUmVzcG9uc2UoZXJyb3JEYXRhLmNvZGUpO1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXG4gICAgICAgICAgZXJyb3JDb2RlLFxuICAgICAgICAgIGVycm9yRGF0YS5lcnJvciB8fCBcIkZhaWxlZCB0byBnZW5lcmF0ZSBtYWdpYyBsaW5rIHRva2VuXCIsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFxuICAgICAgICBcIk5FVFdPUktfRVJST1JcIiAvKiBORVRXT1JLX0VSUk9SICovLFxuICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSBtYWdpYyBsaW5rIHRva2VuXCIsXG4gICAgICAgIFwiTmV0d29yayBlcnJvciBvY2N1cnJlZFwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VuZCBtYWdpYyBsaW5rICh1c2luZyBCbGluayBkZWZhdWx0IGVtYWlsIHNlcnZpY2UpXG4gICAqL1xuICBhc3luYyBzZW5kTWFnaWNMaW5rKGVtYWlsLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9zaWduaW4vbWFnaWNgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgcmVkaXJlY3RVcmw6IG9wdGlvbnM/LnJlZGlyZWN0VXJsLFxuICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcucHJvamVjdElkXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLm1hcEVycm9yQ29kZUZyb21SZXNwb25zZShlcnJvckRhdGEuY29kZSk7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0F1dGhFcnJvcihlcnJvckNvZGUsIGVycm9yRGF0YS5lcnJvciB8fCBcIkZhaWxlZCB0byBzZW5kIG1hZ2ljIGxpbmtcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sIGBOZXR3b3JrIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWZXJpZnkgbWFnaWMgbGluayAoYXV0b21hdGljIG9uIHJlZGlyZWN0KVxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5TWFnaWNMaW5rKHRva2VuKSB7XG4gICAgY29uc3QgbWFnaWNUb2tlbiA9IHRva2VuIHx8IHRoaXMuZXh0cmFjdE1hZ2ljVG9rZW5Gcm9tVXJsKCk7XG4gICAgaWYgKCFtYWdpY1Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJWRVJJRklDQVRJT05fRkFJTEVEXCIgLyogVkVSSUZJQ0FUSU9OX0ZBSUxFRCAqLywgXCJObyBtYWdpYyBsaW5rIHRva2VuIGZvdW5kXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL3NpZ25pbi9tYWdpYy92ZXJpZnlgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdG9rZW46IG1hZ2ljVG9rZW4sXG4gICAgICAgICAgcHJvamVjdElkOiB0aGlzLmNvbmZpZy5wcm9qZWN0SWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IFwiTWFnaWMgbGluayB2ZXJpZmljYXRpb24gZmFpbGVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgYXdhaXQgdGhpcy5zZXRUb2tlbnMoe1xuICAgICAgICBhY2Nlc3NfdG9rZW46IHJlc3VsdC5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHJlc3VsdC5yZWZyZXNoX3Rva2VuLFxuICAgICAgICB0b2tlbl90eXBlOiByZXN1bHQudG9rZW5fdHlwZSxcbiAgICAgICAgZXhwaXJlc19pbjogcmVzdWx0LmV4cGlyZXNfaW4sXG4gICAgICAgIHJlZnJlc2hfZXhwaXJlc19pbjogcmVzdWx0LnJlZnJlc2hfZXhwaXJlc19pblxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnVzZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQXV0aEVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi8sIGBOZXR3b3JrIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgYXZhaWxhYmxlIHByb3ZpZGVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgKi9cbiAgYXN5bmMgZ2V0QXZhaWxhYmxlUHJvdmlkZXJzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXV0aFVybH0vYXBpL2F1dGgvcHJvdmlkZXJzP3Byb2plY3RJZD0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLmNvbmZpZy5wcm9qZWN0SWQpfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4gW1wiZW1haWxcIiwgXCJnb29nbGVcIl07XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIGRhdGEucHJvdmlkZXJzIHx8IFtcImVtYWlsXCIsIFwiZ29vZ2xlXCJdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gW1wiZW1haWxcIiwgXCJnb29nbGVcIl07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGhhcyBhIHNwZWNpZmljIHJvbGVcbiAgICovXG4gIGhhc1JvbGUocm9sZSkge1xuICAgIGNvbnN0IHVzZXIgPSB0aGlzLmF1dGhTdGF0ZS51c2VyO1xuICAgIGlmICghdXNlciB8fCAhdXNlci5yb2xlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvbGUpKSB7XG4gICAgICByZXR1cm4gcm9sZS5pbmNsdWRlcyh1c2VyLnJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlci5yb2xlID09PSByb2xlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGNhbiBwZXJmb3JtIGEgc3BlY2lmaWMgYWN0aW9uXG4gICAqL1xuICBjYW4ocGVybWlzc2lvbiwgcmVzb3VyY2UpIHtcbiAgICBjb25zdCB1c2VyID0gdGhpcy5hdXRoU3RhdGUudXNlcjtcbiAgICBpZiAoIXVzZXIgfHwgIXVzZXIucm9sZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByb2xlcyA9IHRoaXMuYXV0aENvbmZpZy5yb2xlcztcbiAgICBpZiAoIXJvbGVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJvbGVDb25maWcgPSByb2xlc1t1c2VyLnJvbGVdO1xuICAgIGlmICghcm9sZUNvbmZpZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocm9sZUNvbmZpZy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhcIipcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBmdWxsUGVybWlzc2lvbiA9IHJlc291cmNlID8gYCR7cGVybWlzc2lvbn0uJHtyZXNvdXJjZX1gIDogcGVybWlzc2lvbjtcbiAgICBpZiAocm9sZUNvbmZpZy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhmdWxsUGVybWlzc2lvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocm9sZUNvbmZpZy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGhhc1Blcm1pc3Npb25JblJvbGUgPSAocm9sZU5hbWUpID0+IHtcbiAgICAgIGlmICh2aXNpdGVkLmhhcyhyb2xlTmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHZpc2l0ZWQuYWRkKHJvbGVOYW1lKTtcbiAgICAgIGNvbnN0IHJjID0gcm9sZXNbcm9sZU5hbWVdO1xuICAgICAgaWYgKCFyYykgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHJjLnBlcm1pc3Npb25zLmluY2x1ZGVzKFwiKlwiKSkgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBmdWxsUGVybWlzc2lvbjIgPSByZXNvdXJjZSA/IGAke3Blcm1pc3Npb259LiR7cmVzb3VyY2V9YCA6IHBlcm1pc3Npb247XG4gICAgICBpZiAocmMucGVybWlzc2lvbnMuaW5jbHVkZXMoZnVsbFBlcm1pc3Npb24yKSB8fCByYy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAocmMuaW5oZXJpdCkge1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiByYy5pbmhlcml0KSB7XG4gICAgICAgICAgaWYgKGhhc1Blcm1pc3Npb25JblJvbGUocGFyZW50KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChoYXNQZXJtaXNzaW9uSW5Sb2xlKHVzZXIucm9sZSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogU2lnbiBvdXQgKGNsZWFyIGxvY2FsIHRva2VucylcbiAgICogTm90ZTogV2l0aCBzdGF0ZWxlc3MgdG9rZW5zLCB0aGlzIG9ubHkgY2xlYXJzIGxvY2FsIHN0b3JhZ2VcbiAgICovXG4gIGFzeW5jIHNpZ25PdXQoKSB7XG4gICAgdGhpcy5jbGVhclRva2VucygpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2lnbk91dCgpIGluc3RlYWQuIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAqL1xuICBhc3luYyByZXZva2VBbGxTZXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduT3V0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY292ZXIgYXV0aCBzdGF0ZSAoY2xlYXIgY29ycnVwdGVkIHRva2VucyBhbmQgcmUtaW5pdGlhbGl6ZSlcbiAgICovXG4gIGFzeW5jIHJlY292ZXJBdXRoU3RhdGUoKSB7XG4gICAgY29uc29sZS5sb2coXCJcXHV7MUY1MDR9IFJlY292ZXJpbmcgYXV0aCBzdGF0ZS4uLlwiKTtcbiAgICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UgPSBudWxsO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZSA9IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBBdXRoIHN0YXRlIHJlY292ZXJ5IGNvbXBsZXRlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdXNlciBwcm9maWxlXG4gICAqL1xuICBhc3luYyB1cGRhdGVNZSh1cGRhdGVzKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFRva2VuKCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKFwiVE9LRU5fRVhQSVJFRFwiIC8qIFRPS0VOX0VYUElSRUQgKi8sIFwiTm8gYWNjZXNzIHRva2VuIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9tZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlcylcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMubWFwRXJyb3JDb2RlRnJvbVJlc3BvbnNlKGVycm9yRGF0YS5jb2RlKTtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQXV0aEVycm9yKGVycm9yQ29kZSwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gdXBkYXRlIHVzZXI6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgdGhpcy51cGRhdGVBdXRoU3RhdGUoe1xuICAgICAgICAuLi50aGlzLmF1dGhTdGF0ZSxcbiAgICAgICAgdXNlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBdXRoRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBdXRoRXJyb3IoXCJORVRXT1JLX0VSUk9SXCIgLyogTkVUV09SS19FUlJPUiAqLywgYE5ldHdvcmsgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHNldCB0b2tlbnMgKGZvciBzZXJ2ZXItc2lkZSB1c2FnZSlcbiAgICovXG4gIGFzeW5jIHNldFRva2VuKGp3dCwgcGVyc2lzdCA9IGZhbHNlKSB7XG4gICAgY29uc3QgdG9rZW5zID0ge1xuICAgICAgYWNjZXNzX3Rva2VuOiBqd3QsXG4gICAgICB0b2tlbl90eXBlOiBcIkJlYXJlclwiLFxuICAgICAgZXhwaXJlc19pbjogMTUgKiA2MFxuICAgICAgLy8gRGVmYXVsdCAxNSBtaW51dGVzXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh0b2tlbnMsIHBlcnNpc3QpO1xuICB9XG4gIC8qKlxuICAgKiBNYW51YWxseSBzZXQgYXV0aCBzZXNzaW9uIGZyb20gdG9rZW5zIChSZWFjdCBOYXRpdmUgZGVlcCBsaW5rIE9BdXRoKVxuICAgKiBcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgdXNlciBzZXNzaW9uIGFmdGVyIHJlY2VpdmluZyB0b2tlbnMgZnJvbSBhIGRlZXAgbGluayBjYWxsYmFjay5cbiAgICogVGhpcyBpcyB0aGUgUmVhY3QgTmF0aXZlIGVxdWl2YWxlbnQgb2YgYXV0b21hdGljIFVSTCB0b2tlbiBkZXRlY3Rpb24gb24gd2ViLlxuICAgKiBcbiAgICogQHBhcmFtIHRva2VucyAtIEF1dGggdG9rZW5zIHJlY2VpdmVkIGZyb20gZGVlcCBsaW5rIG9yIE9BdXRoIGNhbGxiYWNrXG4gICAqIEBwYXJhbSBwZXJzaXN0IC0gV2hldGhlciB0byBwZXJzaXN0IHRva2VucyB0byBzdG9yYWdlIChkZWZhdWx0OiB0cnVlKVxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUmVhY3QgTmF0aXZlOiBIYW5kbGUgZGVlcCBsaW5rIE9BdXRoIGNhbGxiYWNrXG4gICAqIGltcG9ydCAqIGFzIExpbmtpbmcgZnJvbSAnZXhwby1saW5raW5nJ1xuICAgKiBcbiAgICogTGlua2luZy5hZGRFdmVudExpc3RlbmVyKCd1cmwnLCBhc3luYyAoeyB1cmwgfSkgPT4ge1xuICAgKiAgIGNvbnN0IHsgcXVlcnlQYXJhbXMgfSA9IExpbmtpbmcucGFyc2UodXJsKVxuICAgKiAgIFxuICAgKiAgIGlmIChxdWVyeVBhcmFtcy5hY2Nlc3NfdG9rZW4pIHtcbiAgICogICAgIGF3YWl0IGJsaW5rLmF1dGguc2V0U2Vzc2lvbih7XG4gICAqICAgICAgIGFjY2Vzc190b2tlbjogcXVlcnlQYXJhbXMuYWNjZXNzX3Rva2VuLFxuICAgKiAgICAgICByZWZyZXNoX3Rva2VuOiBxdWVyeVBhcmFtcy5yZWZyZXNoX3Rva2VuLFxuICAgKiAgICAgICBleHBpcmVzX2luOiBwYXJzZUludChxdWVyeVBhcmFtcy5leHBpcmVzX2luKSB8fCAzNjAwLFxuICAgKiAgICAgICByZWZyZXNoX2V4cGlyZXNfaW46IHBhcnNlSW50KHF1ZXJ5UGFyYW1zLnJlZnJlc2hfZXhwaXJlc19pbilcbiAgICogICAgIH0pXG4gICAqICAgICBcbiAgICogICAgIGNvbnNvbGUubG9nKCdVc2VyIGF1dGhlbnRpY2F0ZWQ6JywgYmxpbmsuYXV0aC5jdXJyZW50VXNlcigpKVxuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIGFzeW5jIHNldFNlc3Npb24odG9rZW5zLCBwZXJzaXN0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGF1dGhUb2tlbnMgPSB7XG4gICAgICBhY2Nlc3NfdG9rZW46IHRva2Vucy5hY2Nlc3NfdG9rZW4sXG4gICAgICByZWZyZXNoX3Rva2VuOiB0b2tlbnMucmVmcmVzaF90b2tlbixcbiAgICAgIHRva2VuX3R5cGU6IFwiQmVhcmVyXCIsXG4gICAgICBleHBpcmVzX2luOiB0b2tlbnMuZXhwaXJlc19pbiB8fCAzNjAwLFxuICAgICAgLy8gRGVmYXVsdCAxIGhvdXJcbiAgICAgIHJlZnJlc2hfZXhwaXJlc19pbjogdG9rZW5zLnJlZnJlc2hfZXhwaXJlc19pbixcbiAgICAgIGlzc3VlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKVxuICAgIH07XG4gICAgYXdhaXQgdGhpcy5zZXRUb2tlbnMoYXV0aFRva2VucywgcGVyc2lzdCk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubWUoKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogVmVyaWZ5IGEgQmxpbmsgQXV0aCB0b2tlbiB1c2luZyB0aGUgaW50cm9zcGVjdGlvbiBlbmRwb2ludC5cbiAgICogXG4gICAqICoqU2VydmVyLXNpZGUgLyBFZGdlIEZ1bmN0aW9uIHVzZSBvbmx5LioqXG4gICAqIFxuICAgKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gdmVyaWZ5IHVzZXIgdG9rZW5zIGluIERlbm8gRWRnZSBGdW5jdGlvbnNcbiAgICogYW5kIG90aGVyIHNlcnZlci1zaWRlIGNvbnRleHRzLiBJdCBjYWxscyB0aGUgQmxpbmsgQVBJIGludHJvc3BlY3Rpb24gXG4gICAqIGVuZHBvaW50IHdoaWNoIHZhbGlkYXRlcyB0aGUgdG9rZW4gd2l0aG91dCBleHBvc2luZyB0aGUgSldUIHNlY3JldC5cbiAgICogXG4gICAqIEBwYXJhbSB0b2tlbiAtIFRoZSByYXcgSldUIHRva2VuICh3aXRob3V0IFwiQmVhcmVyIFwiIHByZWZpeCkgb3IgZnVsbCBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiBAcmV0dXJucyBUb2tlbiBpbnRyb3NwZWN0aW9uIHJlc3VsdCB3aXRoIHZhbGlkaXR5IGFuZCBjbGFpbXNcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIERlbm8gRWRnZSBGdW5jdGlvbiB1c2FnZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tIFwibnBtOkBibGlua2RvdG5ldy9zZGtcIjtcbiAgICogXG4gICAqIGNvbnN0IGJsaW5rID0gY3JlYXRlQ2xpZW50KHtcbiAgICogICBwcm9qZWN0SWQ6IERlbm8uZW52LmdldChcIkJMSU5LX1BST0pFQ1RfSURcIikhLFxuICAgKiAgIHNlY3JldEtleTogRGVuby5lbnYuZ2V0KFwiQkxJTktfU0VDUkVUX0tFWVwiKSxcbiAgICogfSk7XG4gICAqIFxuICAgKiBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcTogUmVxdWVzdCk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICogICBjb25zdCBhdXRoSGVhZGVyID0gcmVxLmhlYWRlcnMuZ2V0KFwiQXV0aG9yaXphdGlvblwiKTtcbiAgICogICBjb25zdCByZXN1bHQgPSBhd2FpdCBibGluay5hdXRoLnZlcmlmeVRva2VuKGF1dGhIZWFkZXIpO1xuICAgKiAgIFxuICAgKiAgIGlmICghcmVzdWx0LnZhbGlkKSB7XG4gICAqICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICogICB9XG4gICAqICAgXG4gICAqICAgLy8gVXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAqICAgY29uc29sZS5sb2coXCJVc2VyIElEOlwiLCByZXN1bHQudXNlcklkKTtcbiAgICogICBjb25zb2xlLmxvZyhcIkVtYWlsOlwiLCByZXN1bHQuZW1haWwpO1xuICAgKiAgIGNvbnNvbGUubG9nKFwiUHJvamVjdDpcIiwgcmVzdWx0LnByb2plY3RJZCk7XG4gICAqICAgXG4gICAqICAgLy8gQ29udGludWUgd2l0aCB5b3VyIGxvZ2ljLi4uXG4gICAqIH1cbiAgICovXG4gIGFzeW5jIHZlcmlmeVRva2VuKHRva2VuKSB7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogXCJUb2tlbiByZXF1aXJlZFwiIH07XG4gICAgfVxuICAgIGxldCBjbGVhblRva2VuID0gdG9rZW4udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiYmVhcmVyIFwiKSA/IHRva2VuLnNsaWNlKDcpIDogdG9rZW47XG4gICAgY2xlYW5Ub2tlbiA9IGNsZWFuVG9rZW4udHJpbSgpO1xuICAgIGlmICghY2xlYW5Ub2tlbikge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogXCJUb2tlbiByZXF1aXJlZFwiIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29yZVVybH0vYXBpL2F1dGgvaW50cm9zcGVjdGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7Y2xlYW5Ub2tlbn1gLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKT8udG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghY29udGVudFR5cGUgfHwgIWNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoIXJlc3VsdCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByZXN1bHQudmFsaWQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQgJiYgKHJlc3VsdC5lcnJvciB8fCByZXN1bHQubWVzc2FnZSkgfHwgYFJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0JsaW5rQXV0aF0gVG9rZW4gdmVyaWZpY2F0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlRva2VuIHZlcmlmaWNhdGlvbiBmYWlsZWRcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZnJlc2ggYWNjZXNzIHRva2VuIHVzaW5nIHJlZnJlc2ggdG9rZW5cbiAgICovXG4gIGFzeW5jIHJlZnJlc2hUb2tlbigpIHtcbiAgICBjb25zdCByZWZyZXNoVG9rZW4gPSB0aGlzLmF1dGhTdGF0ZS50b2tlbnM/LnJlZnJlc2hfdG9rZW47XG4gICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hdXRoVXJsfS9hcGkvYXV0aC9yZWZyZXNoYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlblxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0aFJlcXVpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0VG9BdXRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBhd2FpdCB0aGlzLnNldFRva2Vucyh7XG4gICAgICAgIGFjY2Vzc190b2tlbjogZGF0YS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IGRhdGEucmVmcmVzaF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZTogZGF0YS50b2tlbl90eXBlLFxuICAgICAgICBleHBpcmVzX2luOiBkYXRhLmV4cGlyZXNfaW4sXG4gICAgICAgIHJlZnJlc2hfZXhwaXJlc19pbjogZGF0YS5yZWZyZXNoX2V4cGlyZXNfaW5cbiAgICAgIH0sIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUb2tlbiByZWZyZXNoIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGF1dGggc3RhdGUgY2hhbmdlIGxpc3RlbmVyXG4gICAqL1xuICBvbkF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2spIHtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMuYXV0aFN0YXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBhdXRoIHN0YXRlIGNoYW5nZSBjYWxsYmFjazpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZHNcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlU3RvcmVkVG9rZW5zKHRva2Vucykge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUwRH0gVmFsaWRhdGluZyBzdG9yZWQgdG9rZW5zLi4uXCIpO1xuICAgICAgaWYgKHRoaXMuaXNBY2Nlc3NUb2tlbkV4cGlyZWQoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTIzRjAgQWNjZXNzIHRva2VuIGV4cGlyZWQgYmFzZWQgb24gdGltZXN0YW1wLCBhdHRlbXB0aW5nIHJlZnJlc2guLi5cIik7XG4gICAgICAgIGlmICghdG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3NEMgTm8gcmVmcmVzaCB0b2tlbiBhdmFpbGFibGVcIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUmVmcmVzaFRva2VuRXhwaXJlZCgpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIFJlZnJlc2ggdG9rZW4gYWxzbyBleHBpcmVkXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZyZXNoZWQgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgICAgICBpZiAocmVmcmVzaGVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IFRva2VuIHJlZnJlc2hlZCBzdWNjZXNzZnVsbHkgZHVyaW5nIHZhbGlkYXRpb25cIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIFRva2VuIHJlZnJlc2ggZmFpbGVkIGR1cmluZyB2YWxpZGF0aW9uXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL21lYCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbnMuYWNjZXNzX3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgdGhpcy51cGRhdGVBdXRoU3RhdGUoe1xuICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdTI3MDUgU3RvcmVkIHRva2VucyBhcmUgdmFsaWQsIHVzZXIgYXV0aGVudGljYXRlZFwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIHRva2Vucy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNTA0fSBBY2Nlc3MgdG9rZW4gZXhwaXJlZCAoc2VydmVyIHZhbGlkYXRpb24pLCBhdHRlbXB0aW5nIHJlZnJlc2guLi5cIik7XG4gICAgICAgIGlmICh0aGlzLmlzUmVmcmVzaFRva2VuRXhwaXJlZCgpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIFJlZnJlc2ggdG9rZW4gZXhwaXJlZFwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmcmVzaGVkID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgaWYgKHJlZnJlc2hlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBUb2tlbiByZWZyZXNoZWQgc3VjY2Vzc2Z1bGx5IGFmdGVyIHNlcnZlciB2YWxpZGF0aW9uXCIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1Mjc0QyBUb2tlbiByZWZyZXNoIGZhaWxlZCBhZnRlciBzZXJ2ZXIgdmFsaWRhdGlvblwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1Mjc0QyBUb2tlbiB2YWxpZGF0aW9uIGZhaWxlZDpcIiwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjRBNX0gRXJyb3IgdmFsaWRhdGluZyB0b2tlbnM6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0VG9rZW5zKHRva2VucywgcGVyc2lzdCkge1xuICAgIGNvbnN0IHRva2Vuc1dpdGhUaW1lc3RhbXAgPSB7XG4gICAgICAuLi50b2tlbnMsXG4gICAgICBpc3N1ZWRfYXQ6IHRva2Vucy5pc3N1ZWRfYXQgfHwgTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKVxuICAgIH07XG4gICAgY29uc29sZS5sb2coXCJcXHV7MUY1MTB9IFNldHRpbmcgdG9rZW5zOlwiLCB7XG4gICAgICBwZXJzaXN0LFxuICAgICAgaGFzQWNjZXNzVG9rZW46ICEhdG9rZW5zV2l0aFRpbWVzdGFtcC5hY2Nlc3NfdG9rZW4sXG4gICAgICBoYXNSZWZyZXNoVG9rZW46ICEhdG9rZW5zV2l0aFRpbWVzdGFtcC5yZWZyZXNoX3Rva2VuLFxuICAgICAgZXhwaXJlc0luOiB0b2tlbnNXaXRoVGltZXN0YW1wLmV4cGlyZXNfaW4sXG4gICAgICBpc3N1ZWRBdDogdG9rZW5zV2l0aFRpbWVzdGFtcC5pc3N1ZWRfYXRcbiAgICB9KTtcbiAgICBpZiAocGVyc2lzdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgdGhpcy5nZXRTdG9yYWdlS2V5KFwidG9rZW5zXCIpLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRva2Vuc1dpdGhUaW1lc3RhbXApXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEJFfSBUb2tlbnMgcGVyc2lzdGVkIHRvIHN0b3JhZ2VcIik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjRBNX0gRXJyb3IgcGVyc2lzdGluZyB0b2tlbnM6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHVzZXIgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjQ2NH0gRmV0Y2hpbmcgdXNlciBkYXRhLi4uXCIpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmF1dGhVcmx9L2FwaS9hdXRoL21lYCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbnNXaXRoVGltZXN0YW1wLmFjY2Vzc190b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0RTF9IFVzZXIgZmV0Y2ggcmVzcG9uc2U6XCIsIHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIG9rOiByZXNwb25zZS5va1xuICAgICAgfSk7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzA1IFVzZXIgZGF0YSBmZXRjaGVkIHN1Y2Nlc3NmdWxseTpcIiwge1xuICAgICAgICAgIGlkOiB1c2VyPy5pZCxcbiAgICAgICAgICBlbWFpbDogdXNlcj8uZW1haWwsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IHVzZXI/LmRpc3BsYXlOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHUyNzRDIEZhaWxlZCB0byBmZXRjaCB1c2VyIGRhdGE6XCIsIGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEE1fSBFcnJvciBmZXRjaGluZyB1c2VyIGRhdGE6XCIsIGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVBdXRoU3RhdGUoe1xuICAgICAgdXNlcixcbiAgICAgIHRva2VuczogdG9rZW5zV2l0aFRpbWVzdGFtcCxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGM0FGfSBBdXRoIHN0YXRlIHVwZGF0ZWQ6XCIsIHtcbiAgICAgIGhhc1VzZXI6ICEhdXNlcixcbiAgICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNsZWFyVG9rZW5zKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJ0b2tlbnNcIikpO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmVzdWx0LmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx1ezFGNEE1fSBFcnJvciBjbGVhcmluZyB0b2tlbnMgZnJvbSBzdG9yYWdlOlwiLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjRBNX0gRXJyb3IgY2xlYXJpbmcgdG9rZW5zOlwiLCBlcnJvcik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQXV0aFN0YXRlKHtcbiAgICAgIHVzZXI6IG51bGwsXG4gICAgICB0b2tlbnM6IG51bGwsXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFN0b3JlZFRva2VucygpIHtcbiAgICBpZiAoaXNXZWIgJiYgdGhpcy5pc0lmcmFtZSAmJiB0aGlzLnBhcmVudFdpbmRvd1Rva2Vucykge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50V2luZG93VG9rZW5zO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwidG9rZW5zXCIpKTtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyBhd2FpdCByZXN1bHQgOiByZXN1bHQ7XG4gICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjUwRH0gQ2hlY2tpbmcgc3RvcmFnZSBmb3IgdG9rZW5zOlwiLCB7XG4gICAgICAgIGhhc1N0b3JlZERhdGE6ICEhc3RvcmVkLFxuICAgICAgICBzdG9yZWRMZW5ndGg6IHN0b3JlZD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgIGlzSWZyYW1lOiBpc1dlYiAmJiB0aGlzLmlzSWZyYW1lXG4gICAgICB9KTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjRFNn0gUGFyc2VkIHN0b3JlZCB0b2tlbnM6XCIsIHtcbiAgICAgICAgICBoYXNBY2Nlc3NUb2tlbjogISF0b2tlbnMuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIGhhc1JlZnJlc2hUb2tlbjogISF0b2tlbnMucmVmcmVzaF90b2tlbixcbiAgICAgICAgICB0b2tlblR5cGU6IHRva2Vucy50b2tlbl90eXBlLFxuICAgICAgICAgIGV4cGlyZXNJbjogdG9rZW5zLmV4cGlyZXNfaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJcXHV7MUY0QTV9IEVycm9yIHJlYWRpbmcgdG9rZW5zIGZyb20gc3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGV4dHJhY3RUb2tlbnNGcm9tVXJsKCkge1xuICAgIGNvbnN0IHNlYXJjaCA9IGdldExvY2F0aW9uU2VhcmNoKCk7XG4gICAgaWYgKCFzZWFyY2gpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHBhcmFtcy5nZXQoXCJhY2Nlc3NfdG9rZW5cIik7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gcGFyYW1zLmdldChcInJlZnJlc2hfdG9rZW5cIik7XG4gICAgY29uc29sZS5sb2coXCJcXHV7MUY1MER9IEV4dHJhY3RpbmcgdG9rZW5zIGZyb20gVVJMOlwiLCB7XG4gICAgICB1cmw6IGdldExvY2F0aW9uSHJlZigpLFxuICAgICAgYWNjZXNzVG9rZW46IGFjY2Vzc1Rva2VuID8gYCR7YWNjZXNzVG9rZW4uc3Vic3RyaW5nKDAsIDIwKX0uLi5gIDogbnVsbCxcbiAgICAgIHJlZnJlc2hUb2tlbjogcmVmcmVzaFRva2VuID8gYCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCAyMCl9Li4uYCA6IG51bGwsXG4gICAgICBhbGxQYXJhbXM6IE9iamVjdC5mcm9tRW50cmllcyhwYXJhbXMuZW50cmllcygpKVxuICAgIH0pO1xuICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgY29uc3QgdG9rZW5zID0ge1xuICAgICAgICBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfHwgdm9pZCAwLFxuICAgICAgICB0b2tlbl90eXBlOiBcIkJlYXJlclwiLFxuICAgICAgICBleHBpcmVzX2luOiAxNSAqIDYwLFxuICAgICAgICAvLyAxNSBtaW51dGVzIGRlZmF1bHRcbiAgICAgICAgcmVmcmVzaF9leHBpcmVzX2luOiByZWZyZXNoVG9rZW4gPyAzMCAqIDI0ICogNjAgKiA2MCA6IHZvaWQgMCxcbiAgICAgICAgLy8gMzAgZGF5cyBkZWZhdWx0XG4gICAgICAgIGlzc3VlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKVxuICAgICAgICAvLyBDdXJyZW50IHRpbWVzdGFtcFxuICAgICAgfTtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFx1MjcwNSBUb2tlbnMgZXh0cmFjdGVkIHN1Y2Nlc3NmdWxseTpcIiwge1xuICAgICAgICBoYXNBY2Nlc3NUb2tlbjogISF0b2tlbnMuYWNjZXNzX3Rva2VuLFxuICAgICAgICBoYXNSZWZyZXNoVG9rZW46ICEhdG9rZW5zLnJlZnJlc2hfdG9rZW5cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJcXHUyNzRDIE5vIGFjY2VzcyB0b2tlbiBmb3VuZCBpbiBVUkxcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2xlYXJVcmxUb2tlbnMoKSB7XG4gICAgY29uc3QgaHJlZiA9IGdldExvY2F0aW9uSHJlZigpO1xuICAgIGlmICghaHJlZiB8fCAhaGFzV2luZG93TG9jYXRpb24oKSkgcmV0dXJuO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJhY2Nlc3NfdG9rZW5cIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJyZWZyZXNoX3Rva2VuXCIpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwidG9rZW5fdHlwZVwiKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcInByb2plY3RfaWRcIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJleHBpcmVzX2luXCIpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwicmVmcmVzaF9leHBpcmVzX2luXCIpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwic3RhdGVcIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJjb2RlXCIpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiZXJyb3JcIik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJlcnJvcl9kZXNjcmlwdGlvblwiKTtcbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIFwiXCIsIHVybC50b1N0cmluZygpKTtcbiAgICBjb25zb2xlLmxvZyhcIlxcdXsxRjlGOX0gVVJMIGNsZWFuZWQgdXAsIHJlbW92ZWQgYXV0aCBwYXJhbWV0ZXJzXCIpO1xuICB9XG4gIHJlZGlyZWN0VG9BdXRoKCkge1xuICAgIGlmIChoYXNXaW5kb3dMb2NhdGlvbigpKSB7XG4gICAgICB0aGlzLmxvZ2luKCk7XG4gICAgfVxuICB9XG4gIHNldExvYWRpbmcobG9hZGluZykge1xuICAgIHRoaXMudXBkYXRlQXV0aFN0YXRlKHtcbiAgICAgIC4uLnRoaXMuYXV0aFN0YXRlLFxuICAgICAgaXNMb2FkaW5nOiBsb2FkaW5nXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQXV0aFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgdGhpcy5hdXRoU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobmV3U3RhdGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGF1dGggc3RhdGUgY2hhbmdlIGNhbGxiYWNrOlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHNlY3VyZSByYW5kb20gc3RhdGUgZm9yIE9BdXRoIGZsb3dzXG4gICAqL1xuICBnZW5lcmF0ZVN0YXRlKCkge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgKGJ5dGUpID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgdW5pcXVlIHNlc3Npb24gSUQgZm9yIG1vYmlsZSBPQXV0aFxuICAgKi9cbiAgZ2VuZXJhdGVTZXNzaW9uSWQoKSB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGFycmF5LCAoYnl0ZSkgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IG1hZ2ljIGxpbmsgdG9rZW4gZnJvbSBVUkxcbiAgICovXG4gIGV4dHJhY3RNYWdpY1Rva2VuRnJvbVVybCgpIHtcbiAgICBjb25zdCBzZWFyY2ggPSBnZXRMb2NhdGlvblNlYXJjaCgpO1xuICAgIGlmICghc2VhcmNoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCk7XG4gICAgcmV0dXJuIHBhcmFtcy5nZXQoXCJtYWdpY190b2tlblwiKSB8fCBwYXJhbXMuZ2V0KFwidG9rZW5cIik7XG4gIH1cbiAgLyoqXG4gICAqIE1hcCBzZXJ2ZXIgZXJyb3IgY29kZXMgdG8gQmxpbmtBdXRoRXJyb3JDb2RlXG4gICAqL1xuICBtYXBFcnJvckNvZGVGcm9tUmVzcG9uc2Uoc2VydmVyQ29kZSkge1xuICAgIHN3aXRjaCAoc2VydmVyQ29kZSkge1xuICAgICAgY2FzZSBcIklOVkFMSURfQ1JFREVOVElBTFNcIjpcbiAgICAgIGNhc2UgXCJhdXRoL2ludmFsaWQtY3JlZGVudGlhbFwiOlxuICAgICAgY2FzZSBcImF1dGgvd3JvbmctcGFzc3dvcmRcIjpcbiAgICAgIGNhc2UgXCJhdXRoL3VzZXItbm90LWZvdW5kXCI6XG4gICAgICAgIHJldHVybiBcIklOVkFMSURfQ1JFREVOVElBTFNcIiAvKiBJTlZBTElEX0NSRURFTlRJQUxTICovO1xuICAgICAgY2FzZSBcIkVNQUlMX05PVF9WRVJJRklFRFwiOlxuICAgICAgY2FzZSBcImF1dGgvZW1haWwtbm90LXZlcmlmaWVkXCI6XG4gICAgICAgIHJldHVybiBcIkVNQUlMX05PVF9WRVJJRklFRFwiIC8qIEVNQUlMX05PVF9WRVJJRklFRCAqLztcbiAgICAgIGNhc2UgXCJFTUFJTF9BTFJFQURZX1ZFUklGSUVEXCI6XG4gICAgICAgIHJldHVybiBcIlZFUklGSUNBVElPTl9GQUlMRURcIiAvKiBWRVJJRklDQVRJT05fRkFJTEVEICovO1xuICAgICAgY2FzZSBcIlBPUFVQX0NBTkNFTEVEXCI6XG4gICAgICBjYXNlIFwiYXV0aC9wb3B1cC1jbG9zZWQtYnktdXNlclwiOlxuICAgICAgICByZXR1cm4gXCJQT1BVUF9DQU5DRUxFRFwiIC8qIFBPUFVQX0NBTkNFTEVEICovO1xuICAgICAgY2FzZSBcIk5FVFdPUktfRVJST1JcIjpcbiAgICAgICAgcmV0dXJuIFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi87XG4gICAgICBjYXNlIFwiUkFURV9MSU1JVEVEXCI6XG4gICAgICBjYXNlIFwiYXV0aC90b28tbWFueS1yZXF1ZXN0c1wiOlxuICAgICAgICByZXR1cm4gXCJSQVRFX0xJTUlURURcIiAvKiBSQVRFX0xJTUlURUQgKi87XG4gICAgICBjYXNlIFwiQVVUSF9USU1FT1VUXCI6XG4gICAgICAgIHJldHVybiBcIkFVVEhfVElNRU9VVFwiIC8qIEFVVEhfVElNRU9VVCAqLztcbiAgICAgIGNhc2UgXCJSRURJUkVDVF9GQUlMRURcIjpcbiAgICAgICAgcmV0dXJuIFwiUkVESVJFQ1RfRkFJTEVEXCIgLyogUkVESVJFQ1RfRkFJTEVEICovO1xuICAgICAgY2FzZSBcIlRPS0VOX0VYUElSRURcIjpcbiAgICAgIGNhc2UgXCJhdXRoL2lkLXRva2VuLWV4cGlyZWRcIjpcbiAgICAgICAgcmV0dXJuIFwiVE9LRU5fRVhQSVJFRFwiIC8qIFRPS0VOX0VYUElSRUQgKi87XG4gICAgICBjYXNlIFwiVVNFUl9OT1RfRk9VTkRcIjpcbiAgICAgICAgcmV0dXJuIFwiVVNFUl9OT1RfRk9VTkRcIiAvKiBVU0VSX05PVF9GT1VORCAqLztcbiAgICAgIGNhc2UgXCJFTUFJTF9BTFJFQURZX0VYSVNUU1wiOlxuICAgICAgY2FzZSBcImF1dGgvZW1haWwtYWxyZWFkeS1pbi11c2VcIjpcbiAgICAgICAgcmV0dXJuIFwiRU1BSUxfQUxSRUFEWV9FWElTVFNcIiAvKiBFTUFJTF9BTFJFQURZX0VYSVNUUyAqLztcbiAgICAgIGNhc2UgXCJXRUFLX1BBU1NXT1JEXCI6XG4gICAgICBjYXNlIFwiYXV0aC93ZWFrLXBhc3N3b3JkXCI6XG4gICAgICAgIHJldHVybiBcIldFQUtfUEFTU1dPUkRcIiAvKiBXRUFLX1BBU1NXT1JEICovO1xuICAgICAgY2FzZSBcIklOVkFMSURfRU1BSUxcIjpcbiAgICAgIGNhc2UgXCJhdXRoL2ludmFsaWQtZW1haWxcIjpcbiAgICAgICAgcmV0dXJuIFwiSU5WQUxJRF9FTUFJTFwiIC8qIElOVkFMSURfRU1BSUwgKi87XG4gICAgICBjYXNlIFwiTUFHSUNfTElOS19FWFBJUkVEXCI6XG4gICAgICAgIHJldHVybiBcIk1BR0lDX0xJTktfRVhQSVJFRFwiIC8qIE1BR0lDX0xJTktfRVhQSVJFRCAqLztcbiAgICAgIGNhc2UgXCJWRVJJRklDQVRJT05fRkFJTEVEXCI6XG4gICAgICAgIHJldHVybiBcIlZFUklGSUNBVElPTl9GQUlMRURcIiAvKiBWRVJJRklDQVRJT05fRkFJTEVEICovO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiTkVUV09SS19FUlJPUlwiIC8qIE5FVFdPUktfRVJST1IgKi87XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXR1cCBjcm9zcy10YWIgYXV0aGVudGljYXRpb24gc3luY2hyb25pemF0aW9uXG4gICAqL1xuICBzZXR1cENyb3NzVGFiU3luYygpIHtcbiAgICBpZiAoIWlzV2ViIHx8ICFoYXNXaW5kb3coKSkgcmV0dXJuO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSB0aGlzLmdldFN0b3JhZ2VLZXkoXCJ0b2tlbnNcIikpIHtcbiAgICAgICAgY29uc3QgbmV3VG9rZW5zID0gZS5uZXdWYWx1ZSA/IEpTT04ucGFyc2UoZS5uZXdWYWx1ZSkgOiBudWxsO1xuICAgICAgICBpZiAobmV3VG9rZW5zICYmIG5ld1Rva2VucyAhPT0gdGhpcy5hdXRoU3RhdGUudG9rZW5zKSB7XG4gICAgICAgICAgdGhpcy5zZXRUb2tlbnMobmV3VG9rZW5zLCBmYWxzZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHN5bmMgdG9rZW5zIGZyb20gb3RoZXIgdGFiOlwiLCBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld1Rva2VucyAmJiB0aGlzLmF1dGhTdGF0ZS50b2tlbnMpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2RhdGFiYXNlLnRzXG5mdW5jdGlvbiBhc3NlcnRTZXJ2ZXJPbmx5KG1ldGhvZE5hbWUpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kTmFtZX0gaXMgc2VydmVyLW9ubHkuIFVzZSBCbGluayBDUlVEIG1ldGhvZHMgKGJsaW5rLmRiLjx0YWJsZT4uKikgaW5zdGVhZC5gKTtcbiAgfVxufVxuZnVuY3Rpb24gY2FtZWxUb1NuYWtlMyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bQS1aXS9nLCAobGV0dGVyKSA9PiBgXyR7bGV0dGVyLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNlY3VyZUlkKCkge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIChieXRlKSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygzNik7XG4gICAgY29uc3QgcmFuZG9tUGFydCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgY29uc3QgZXh0cmFSYW5kb20gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpO1xuICAgIHJldHVybiBgJHt0aW1lc3RhbXB9XyR7cmFuZG9tUGFydH1fJHtleHRyYVJhbmRvbX1gO1xuICB9XG59XG5mdW5jdGlvbiBlbnN1cmVSZWNvcmRJZChyZWNvcmQpIHtcbiAgaWYgKCFyZWNvcmQuaWQpIHtcbiAgICByZXR1cm4geyAuLi5yZWNvcmQsIGlkOiBnZW5lcmF0ZVNlY3VyZUlkKCkgfTtcbiAgfVxuICByZXR1cm4gcmVjb3JkO1xufVxudmFyIEJsaW5rVGFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRhYmxlTmFtZSwgaHR0cENsaWVudCkge1xuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgdGhpcy5hY3R1YWxUYWJsZU5hbWUgPSBjYW1lbFRvU25ha2UzKHRhYmxlTmFtZSk7XG4gIH1cbiAgYWN0dWFsVGFibGVOYW1lO1xuICAvKipcbiAgICogQ3JlYXRlIGEgc2luZ2xlIHJlY29yZFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlY29yZCA9IGVuc3VyZVJlY29yZElkKGRhdGEpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRiUG9zdChcbiAgICAgIHRoaXMuYWN0dWFsVGFibGVOYW1lLFxuICAgICAgcmVjb3JkLFxuICAgICAgeyByZXR1cm5pbmc6IG9wdGlvbnMucmV0dXJuaW5nICE9PSBmYWxzZSB9XG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmRhdGEpID8gcmVzcG9uc2UuZGF0YVswXSA6IHJlc3BvbnNlLmRhdGE7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgcmVjb3JkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgbXVsdGlwbGUgcmVjb3Jkc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlTWFueShkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZWNvcmRzID0gZGF0YS5tYXAoZW5zdXJlUmVjb3JkSWQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRiUG9zdChcbiAgICAgIHRoaXMuYWN0dWFsVGFibGVOYW1lLFxuICAgICAgcmVjb3JkcyxcbiAgICAgIHsgcmV0dXJuaW5nOiBvcHRpb25zLnJldHVybmluZyAhPT0gZmFsc2UgfVxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0cyA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkgPyByZXNwb25zZS5kYXRhIDogW3Jlc3BvbnNlLmRhdGFdO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIC8qKlxuICAgKiBVcHNlcnQgYSBzaW5nbGUgcmVjb3JkIChpbnNlcnQgb3IgdXBkYXRlIG9uIGNvbmZsaWN0KVxuICAgKi9cbiAgYXN5bmMgdXBzZXJ0KGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcgIT09IGZhbHNlKSB7XG4gICAgICBoZWFkZXJzLlByZWZlciA9IFwicmV0dXJuPXJlcHJlc2VudGF0aW9uXCI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9uQ29uZmxpY3QpIHtcbiAgICAgIGhlYWRlcnNbXCJQcmVmZXJcIl0gPSBgJHtoZWFkZXJzW1wiUHJlZmVyXCJdIHx8IFwiXCJ9IHJlc29sdXRpb249bWVyZ2UtZHVwbGljYXRlc2AudHJpbSgpO1xuICAgIH1cbiAgICBjb25zdCByZWNvcmQgPSBlbnN1cmVSZWNvcmRJZChkYXRhKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5yZXF1ZXN0KFxuICAgICAgYC9hcGkvZGIvJHt0aGlzLmh0dHBDbGllbnQucHJvamVjdElkfS9yZXN0L3YxLyR7dGhpcy5hY3R1YWxUYWJsZU5hbWV9P29uX2NvbmZsaWN0PSR7b3B0aW9ucy5vbkNvbmZsaWN0IHx8IFwiaWRcIn1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiByZWNvcmQsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkgPyByZXNwb25zZS5kYXRhWzBdIDogcmVzcG9uc2UuZGF0YTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHVwc2VydCByZWNvcmRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFVwc2VydCBtdWx0aXBsZSByZWNvcmRzXG4gICAqL1xuICBhc3luYyB1cHNlcnRNYW55KGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlY29yZHMgPSBkYXRhLm1hcChlbnN1cmVSZWNvcmRJZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmIChvcHRpb25zLnJldHVybmluZyAhPT0gZmFsc2UpIHtcbiAgICAgIGhlYWRlcnMuUHJlZmVyID0gXCJyZXR1cm49cmVwcmVzZW50YXRpb25cIjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub25Db25mbGljdCkge1xuICAgICAgaGVhZGVyc1tcIlByZWZlclwiXSA9IGAke2hlYWRlcnNbXCJQcmVmZXJcIl0gfHwgXCJcIn0gcmVzb2x1dGlvbj1tZXJnZS1kdXBsaWNhdGVzYC50cmltKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJlcXVlc3QoXG4gICAgICBgL2FwaS9kYi8ke3RoaXMuaHR0cENsaWVudC5wcm9qZWN0SWR9L3Jlc3QvdjEvJHt0aGlzLmFjdHVhbFRhYmxlTmFtZX0/b25fY29uZmxpY3Q9JHtvcHRpb25zLm9uQ29uZmxpY3QgfHwgXCJpZFwifWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IHJlY29yZHMsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmRhdGEpID8gcmVzcG9uc2UuZGF0YSA6IFtyZXNwb25zZS5kYXRhXTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIHJlY29yZCBieSBJRFxuICAgKi9cbiAgYXN5bmMgZ2V0KGlkKSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0ge1xuICAgICAgaWQ6IGBlcS4ke2lkfWAsXG4gICAgICBsaW1pdDogXCIxXCJcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRiR2V0KHRoaXMuYWN0dWFsVGFibGVOYW1lLCBzZWFyY2hQYXJhbXMpO1xuICAgIGNvbnN0IHJlY29yZHMgPSByZXNwb25zZS5kYXRhO1xuICAgIGlmIChyZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzWzBdIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIExpc3QgcmVjb3JkcyB3aXRoIGZpbHRlcmluZywgc29ydGluZywgYW5kIHBhZ2luYXRpb25cbiAgICovXG4gIGFzeW5jIGxpc3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBidWlsZFF1ZXJ5KG9wdGlvbnMpO1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRiR2V0KHRoaXMuYWN0dWFsVGFibGVOYW1lLCBzZWFyY2hQYXJhbXMpO1xuICAgIGNvbnN0IHJlY29yZHMgPSByZXNwb25zZS5kYXRhO1xuICAgIHJldHVybiByZWNvcmRzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgYSBzaW5nbGUgcmVjb3JkIGJ5IElEXG4gICAqL1xuICBhc3luYyB1cGRhdGUoaWQsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHtcbiAgICAgIGlkOiBgZXEuJHtpZH1gXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYlBhdGNoKFxuICAgICAgdGhpcy5hY3R1YWxUYWJsZU5hbWUsXG4gICAgICBkYXRhLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgeyByZXR1cm5pbmc6IG9wdGlvbnMucmV0dXJuaW5nICE9PSBmYWxzZSB9XG4gICAgKTtcbiAgICBjb25zdCByZWNvcmRzID0gcmVzcG9uc2UuZGF0YTtcbiAgICBpZiAoIXJlY29yZHMgfHwgcmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjb3JkIHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzWzBdO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgbXVsdGlwbGUgcmVjb3Jkc1xuICAgKi9cbiAgYXN5bmMgdXBkYXRlTWFueSh1cGRhdGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgY29uc3QgeyBpZCwgLi4uZGF0YSB9ID0gdXBkYXRlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy51cGRhdGUoaWQsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBzaW5nbGUgcmVjb3JkIGJ5IElEXG4gICAqL1xuICBhc3luYyBkZWxldGUoaWQpIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSB7XG4gICAgICBpZDogYGVxLiR7aWR9YFxuICAgIH07XG4gICAgYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRiRGVsZXRlKHRoaXMuYWN0dWFsVGFibGVOYW1lLCBzZWFyY2hQYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgbXVsdGlwbGUgcmVjb3JkcyBiYXNlZCBvbiBmaWx0ZXJcbiAgICovXG4gIGFzeW5jIGRlbGV0ZU1hbnkob3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gYnVpbGRRdWVyeSh7IHdoZXJlOiBvcHRpb25zLndoZXJlIH0pO1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgIGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYkRlbGV0ZSh0aGlzLmFjdHVhbFRhYmxlTmFtZSwgc2VhcmNoUGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogQ291bnQgcmVjb3JkcyBtYXRjaGluZyBmaWx0ZXJcbiAgICovXG4gIGFzeW5jIGNvdW50KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gYnVpbGRRdWVyeSh7XG4gICAgICB3aGVyZTogb3B0aW9ucy53aGVyZSxcbiAgICAgIHNlbGVjdDogW1wiaWRcIl1cbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5yZXF1ZXN0KFxuICAgICAgYC9hcGkvZGIvJHt0aGlzLmh0dHBDbGllbnQucHJvamVjdElkfS9yZXN0L3YxLyR7dGhpcy5hY3R1YWxUYWJsZU5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBzZWFyY2hQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJQcmVmZXJcIjogXCJjb3VudD1leGFjdFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC1yYW5nZVwiKTtcbiAgICBpZiAoY29udGVudFJhbmdlKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNvbnRlbnRSYW5nZS5tYXRjaCgvXFwvKFxcZCspJC8pO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWNvcmRzID0gcmVzcG9uc2UuZGF0YTtcbiAgICByZXR1cm4gcmVjb3Jkcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFueSByZWNvcmRzIGV4aXN0IG1hdGNoaW5nIGZpbHRlclxuICAgKi9cbiAgYXN5bmMgZXhpc3RzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IGF3YWl0IHRoaXMuY291bnQob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvdW50ID4gMDtcbiAgfVxuICAvKipcbiAgICogUmF3IFNRTCBxdWVyeSBvbiB0aGlzIHRhYmxlIChmb3IgYWR2YW5jZWQgdXNlIGNhc2VzKVxuICAgKi9cbiAgYXN5bmMgc3FsKHF1ZXJ5LCBwYXJhbXMpIHtcbiAgICBhc3NlcnRTZXJ2ZXJPbmx5KFwiYmxpbmsuZGIuPHRhYmxlPi5zcWxcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJTcWwocXVlcnksIHBhcmFtcyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZHNcbiAgICovXG4gIGV4dHJhY3RDdXJzb3IocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZC5pZCB8fCByZWNvcmQuX2lkIHx8IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgfVxufTtcbnZhciBCbGlua0RhdGFiYXNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50KSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSBcInRhYmxlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LnRhYmxlLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZS5iaW5kKHRhcmdldCkgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LnRhYmxlKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9XG4gIHRhYmxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBHZXQgYSB0YWJsZSBpbnN0YW5jZSBmb3IgYW55IHRhYmxlIG5hbWVcbiAgICovXG4gIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgIGlmICghdGhpcy50YWJsZXMuaGFzKHRhYmxlTmFtZSkpIHtcbiAgICAgIHRoaXMudGFibGVzLnNldCh0YWJsZU5hbWUsIG5ldyBCbGlua1RhYmxlKHRhYmxlTmFtZSwgdGhpcy5odHRwQ2xpZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gdGhpcy50YWJsZXMuZ2V0KHRhYmxlTmFtZSk7XG4gICAgaWYgKCF0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAke3RhYmxlTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSByYXcgU1FMIHF1ZXJ5XG4gICAqL1xuICBhc3luYyBzcWwocXVlcnksIHBhcmFtcykge1xuICAgIGFzc2VydFNlcnZlck9ubHkoXCJibGluay5kYi5zcWxcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJTcWwocXVlcnksIHBhcmFtcyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYmF0Y2ggU1FMIG9wZXJhdGlvbnNcbiAgICovXG4gIGFzeW5jIGJhdGNoKHN0YXRlbWVudHMsIG1vZGUgPSBcIndyaXRlXCIpIHtcbiAgICBhc3NlcnRTZXJ2ZXJPbmx5KFwiYmxpbmsuZGIuYmF0Y2hcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGJCYXRjaChzdGF0ZW1lbnRzLCBtb2RlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxufTtcblxuLy8gc3JjL3N0b3JhZ2UudHNcbnZhciBCbGlua1N0b3JhZ2VJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50KSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgfVxuICAvKipcbiAgICogVXBsb2FkIGEgZmlsZSB0byBwcm9qZWN0IHN0b3JhZ2VcbiAgICogXG4gICAqIEBwYXJhbSBmaWxlIC0gRmlsZSwgQmxvYiwgb3IgQnVmZmVyIHRvIHVwbG9hZFxuICAgKiBAcGFyYW0gcGF0aCAtIERlc3RpbmF0aW9uIHBhdGggd2l0aGluIHByb2plY3Qgc3RvcmFnZSAoZXh0ZW5zaW9uIHdpbGwgYmUgYXV0by1jb3JyZWN0ZWQgdG8gbWF0Y2ggZmlsZSB0eXBlKVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyB1cHNlcnQgYW5kIHByb2dyZXNzIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHVwbG9hZCByZXNwb25zZSB3aXRoIHB1YmxpYyBVUkxcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIEV4dGVuc2lvbiBhdXRvbWF0aWNhbGx5IGNvcnJlY3RlZCB0byBtYXRjaCBhY3R1YWwgZmlsZSB0eXBlXG4gICAqIGNvbnN0IHsgcHVibGljVXJsIH0gPSBhd2FpdCBibGluay5zdG9yYWdlLnVwbG9hZChcbiAgICogICBwbmdGaWxlLFxuICAgKiAgIGBhdmF0YXJzLyR7dXNlci5pZH1gLCAvLyBObyBleHRlbnNpb24gbmVlZGVkIVxuICAgKiAgIHsgdXBzZXJ0OiB0cnVlIH1cbiAgICogKTtcbiAgICogLy8gSWYgZmlsZSBpcyBQTkcsIGZpbmFsIHBhdGggd2lsbCBiZTogYXZhdGFycy91c2VyMTIzLnBuZ1xuICAgKiBcbiAgICogLy8gT3Igd2l0aCBleHRlbnNpb24gKHdpbGwgYmUgY29ycmVjdGVkIGlmIHdyb25nKVxuICAgKiBjb25zdCB7IHB1YmxpY1VybCB9ID0gYXdhaXQgYmxpbmsuc3RvcmFnZS51cGxvYWQoXG4gICAqICAgcG5nRmlsZSxcbiAgICogICBgYXZhdGFycy8ke3VzZXIuaWR9LmpwZ2AsIC8vIFdyb25nIGV4dGVuc2lvblxuICAgKiAgIHsgdXBzZXJ0OiB0cnVlIH1cbiAgICogKTtcbiAgICogLy8gRmluYWwgcGF0aCB3aWxsIGJlOiBhdmF0YXJzL3VzZXIxMjMucG5nIChhdXRvLWNvcnJlY3RlZCEpXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdXBsb2FkKGZpbGUsIHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiRmlsZSBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGF0aCB8fCB0eXBlb2YgcGF0aCAhPT0gXCJzdHJpbmdcIiB8fCAhcGF0aC50cmltKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heFNpemUgPSA1MCAqIDEwMjQgKiAxMDI0O1xuICAgICAgbGV0IGZpbGVTaXplID0gMDtcbiAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSB8fCBmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBmaWxlU2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGZpbGVTaXplID0gZmlsZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoZmlsZVNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua1N0b3JhZ2VFcnJvcihgRmlsZSBzaXplICgke01hdGgucm91bmQoZmlsZVNpemUgLyAxMDI0IC8gMTAyNCl9TUIpIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUgKDUwTUIpYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvcnJlY3RlZFBhdGgsIGRldGVjdGVkQ29udGVudFR5cGUgfSA9IGF3YWl0IHRoaXMuZGV0ZWN0RmlsZVR5cGVBbmRDb3JyZWN0UGF0aChmaWxlLCBwYXRoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnVwbG9hZEZpbGUoXG4gICAgICAgIGAvYXBpL3N0b3JhZ2UvJHt0aGlzLmh0dHBDbGllbnQucHJvamVjdElkfS91cGxvYWRgLFxuICAgICAgICBmaWxlLFxuICAgICAgICBjb3JyZWN0ZWRQYXRoLFxuICAgICAgICAvLyBVc2UgY29ycmVjdGVkIHBhdGggd2l0aCBwcm9wZXIgZXh0ZW5zaW9uXG4gICAgICAgIHtcbiAgICAgICAgICBvblByb2dyZXNzOiBvcHRpb25zLm9uUHJvZ3Jlc3MsXG4gICAgICAgICAgY29udGVudFR5cGU6IGRldGVjdGVkQ29udGVudFR5cGVcbiAgICAgICAgICAvLyBQYXNzIGRldGVjdGVkIGNvbnRlbnQgdHlwZVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/LmRhdGE/LnB1YmxpY1VybCkge1xuICAgICAgICByZXR1cm4geyBwdWJsaWNVcmw6IHJlc3BvbnNlLmRhdGEuZGF0YS5wdWJsaWNVcmwgfTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuZGF0YT8ucHVibGljVXJsKSB7XG4gICAgICAgIHJldHVybiB7IHB1YmxpY1VybDogcmVzcG9uc2UuZGF0YS5wdWJsaWNVcmwgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua1N0b3JhZ2VFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBtaXNzaW5nIHB1YmxpY1VybFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtTdG9yYWdlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBcInN0YXR1c1wiIGluIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycm9yLnN0YXR1cztcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiRmlsZSBhbHJlYWR5IGV4aXN0cy5cIiwgNDA5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVyc1wiLCA0MDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXG4gICAgICAgIGBVcGxvYWQgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXRlY3QgZmlsZSB0eXBlIGZyb20gYWN0dWFsIGZpbGUgY29udGVudCBhbmQgY29ycmVjdCBwYXRoIGV4dGVuc2lvblxuICAgKiBUaGlzIGVuc3VyZXMgdGhlIHBhdGggZXh0ZW5zaW9uIGFsd2F5cyBtYXRjaGVzIHRoZSBhY3R1YWwgZmlsZSB0eXBlXG4gICAqL1xuICBhc3luYyBkZXRlY3RGaWxlVHlwZUFuZENvcnJlY3RQYXRoKGZpbGUsIG9yaWdpbmFsUGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmaWxlU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5nZXRGaWxlU2lnbmF0dXJlKGZpbGUpO1xuICAgICAgY29uc3QgZGV0ZWN0ZWRUeXBlID0gdGhpcy5kZXRlY3RGaWxlVHlwZUZyb21TaWduYXR1cmUoZmlsZVNpZ25hdHVyZSk7XG4gICAgICBsZXQgZGV0ZWN0ZWRDb250ZW50VHlwZSA9IGRldGVjdGVkVHlwZS5taW1lVHlwZTtcbiAgICAgIGxldCBkZXRlY3RlZEV4dGVuc2lvbiA9IGRldGVjdGVkVHlwZS5leHRlbnNpb247XG4gICAgICBpZiAoIWRldGVjdGVkQ29udGVudFR5cGUgJiYgZmlsZSBpbnN0YW5jZW9mIEZpbGUgJiYgZmlsZS50eXBlKSB7XG4gICAgICAgIGRldGVjdGVkQ29udGVudFR5cGUgPSBmaWxlLnR5cGU7XG4gICAgICAgIGRldGVjdGVkRXh0ZW5zaW9uID0gdGhpcy5nZXRFeHRlbnNpb25Gcm9tTWltZVR5cGUoZmlsZS50eXBlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGV0ZWN0ZWRDb250ZW50VHlwZSkge1xuICAgICAgICBkZXRlY3RlZENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgZGV0ZWN0ZWRFeHRlbnNpb24gPSBcImJpblwiO1xuICAgICAgfVxuICAgICAgY29uc3QgcGF0aFBhcnRzID0gb3JpZ2luYWxQYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGRpcmVjdG9yeSA9IHBhdGhQYXJ0cy5zbGljZSgwLCAtMSkuam9pbihcIi9cIik7XG4gICAgICBpZiAoIWZpbGVOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF0aDogZmlsZW5hbWUgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmFtZVdpdGhvdXRFeHQgPSBmaWxlTmFtZS5pbmNsdWRlcyhcIi5cIikgPyBmaWxlTmFtZS5zdWJzdHJpbmcoMCwgZmlsZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpKSA6IGZpbGVOYW1lO1xuICAgICAgY29uc3QgY29ycmVjdGVkRmlsZU5hbWUgPSBgJHtuYW1lV2l0aG91dEV4dH0uJHtkZXRlY3RlZEV4dGVuc2lvbn1gO1xuICAgICAgY29uc3QgY29ycmVjdGVkUGF0aCA9IGRpcmVjdG9yeSA/IGAke2RpcmVjdG9yeX0vJHtjb3JyZWN0ZWRGaWxlTmFtZX1gIDogY29ycmVjdGVkRmlsZU5hbWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb3JyZWN0ZWRQYXRoLFxuICAgICAgICBkZXRlY3RlZENvbnRlbnRUeXBlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb3JyZWN0ZWRQYXRoOiBvcmlnaW5hbFBhdGgsXG4gICAgICAgIGRldGVjdGVkQ29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGZldyBieXRlcyBvZiBhIGZpbGUgdG8gYW5hbHl6ZSBpdHMgc2lnbmF0dXJlXG4gICAqL1xuICBhc3luYyBnZXRGaWxlU2lnbmF0dXJlKGZpbGUpIHtcbiAgICBjb25zdCBieXRlc1RvUmVhZCA9IDEyO1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShmaWxlLnNsaWNlKDAsIGJ5dGVzVG9SZWFkKSk7XG4gICAgfVxuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSB8fCBmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgY29uc3Qgc2xpY2UgPSBmaWxlLnNsaWNlKDAsIGJ5dGVzVG9SZWFkKTtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgc2xpY2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGZpbGUgdHlwZSBmb3Igc2lnbmF0dXJlIGRldGVjdGlvblwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZWN0IGZpbGUgdHlwZSBmcm9tIGZpbGUgc2lnbmF0dXJlIChtYWdpYyBudW1iZXJzKVxuICAgKiBUaGlzIGlzIHRoZSBtb3N0IHJlbGlhYmxlIHdheSB0byBkZXRlY3QgYWN0dWFsIGZpbGUgdHlwZVxuICAgKi9cbiAgZGV0ZWN0RmlsZVR5cGVGcm9tU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGhleCA9IEFycmF5LmZyb20oc2lnbmF0dXJlKS5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0ge1xuICAgICAgLy8gSW1hZ2VzXG4gICAgICBcImZmZDhmZlwiOiB7IG1pbWVUeXBlOiBcImltYWdlL2pwZWdcIiwgZXh0ZW5zaW9uOiBcImpwZ1wiIH0sXG4gICAgICBcIjg5NTA0ZTQ3XCI6IHsgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsIGV4dGVuc2lvbjogXCJwbmdcIiB9LFxuICAgICAgXCI0NzQ5NDYzOFwiOiB7IG1pbWVUeXBlOiBcImltYWdlL2dpZlwiLCBleHRlbnNpb246IFwiZ2lmXCIgfSxcbiAgICAgIFwiNTI0OTQ2NDZcIjogeyBtaW1lVHlwZTogXCJpbWFnZS93ZWJwXCIsIGV4dGVuc2lvbjogXCJ3ZWJwXCIgfSxcbiAgICAgIC8vIFJJRkYgKFdlYlAgY29udGFpbmVyKVxuICAgICAgXCI0MjRkXCI6IHsgbWltZVR5cGU6IFwiaW1hZ2UvYm1wXCIsIGV4dGVuc2lvbjogXCJibXBcIiB9LFxuICAgICAgXCI0OTQ5MmEwMFwiOiB7IG1pbWVUeXBlOiBcImltYWdlL3RpZmZcIiwgZXh0ZW5zaW9uOiBcInRpZmZcIiB9LFxuICAgICAgXCI0ZDRkMDAyYVwiOiB7IG1pbWVUeXBlOiBcImltYWdlL3RpZmZcIiwgZXh0ZW5zaW9uOiBcInRpZmZcIiB9LFxuICAgICAgLy8gRG9jdW1lbnRzXG4gICAgICBcIjI1NTA0NDQ2XCI6IHsgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vcGRmXCIsIGV4dGVuc2lvbjogXCJwZGZcIiB9LFxuICAgICAgXCI1MDRiMDMwNFwiOiB7IG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiLCBleHRlbnNpb246IFwiemlwXCIgfSxcbiAgICAgIC8vIEFsc28gdXNlZCBieSBkb2N4LCB4bHN4XG4gICAgICBcImQwY2YxMWUwXCI6IHsgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vbXN3b3JkXCIsIGV4dGVuc2lvbjogXCJkb2NcIiB9LFxuICAgICAgLy8gQXVkaW9cbiAgICAgIFwiNDk0NDMzXCI6IHsgbWltZVR5cGU6IFwiYXVkaW8vbXBlZ1wiLCBleHRlbnNpb246IFwibXAzXCIgfSxcbiAgICAgIFwiNjY0YzYxNDNcIjogeyBtaW1lVHlwZTogXCJhdWRpby9mbGFjXCIsIGV4dGVuc2lvbjogXCJmbGFjXCIgfSxcbiAgICAgIFwiNGY2NzY3NTNcIjogeyBtaW1lVHlwZTogXCJhdWRpby9vZ2dcIiwgZXh0ZW5zaW9uOiBcIm9nZ1wiIH0sXG4gICAgICAvLyBWaWRlb1xuICAgICAgXCIwMDAwMDBcIjogeyBtaW1lVHlwZTogXCJ2aWRlby9tcDRcIiwgZXh0ZW5zaW9uOiBcIm1wNFwiIH0sXG4gICAgICAvLyBmdHlwIGJveFxuICAgICAgXCIxYTQ1ZGZhM1wiOiB7IG1pbWVUeXBlOiBcInZpZGVvL3dlYm1cIiwgZXh0ZW5zaW9uOiBcIndlYm1cIiB9LFxuICAgICAgLy8gVGV4dFxuICAgICAgXCJlZmJiYmZcIjogeyBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsIGV4dGVuc2lvbjogXCJ0eHRcIiB9XG4gICAgICAvLyBVVEYtOCBCT01cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW3NpZywgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMoc2lnbmF0dXJlcykpIHtcbiAgICAgIGlmIChoZXguc3RhcnRzV2l0aChzaWcpKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGV4LnN0YXJ0c1dpdGgoXCI1MjQ5NDY0NlwiKSAmJiBoZXguc3Vic3RyaW5nKDE2LCAyNCkgPT09IFwiNTc0NTQyNTBcIikge1xuICAgICAgcmV0dXJuIHsgbWltZVR5cGU6IFwiaW1hZ2Uvd2VicFwiLCBleHRlbnNpb246IFwid2VicFwiIH07XG4gICAgfVxuICAgIGlmIChoZXguc3Vic3RyaW5nKDgsIDE2KSA9PT0gXCI2Njc0Nzk3MFwiKSB7XG4gICAgICByZXR1cm4geyBtaW1lVHlwZTogXCJ2aWRlby9tcDRcIiwgZXh0ZW5zaW9uOiBcIm1wNFwiIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1pbWVUeXBlOiBcIlwiLCBleHRlbnNpb246IFwiXCIgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGZpbGUgZXh0ZW5zaW9uIGZyb20gTUlNRSB0eXBlIGFzIGZhbGxiYWNrXG4gICAqL1xuICBnZXRFeHRlbnNpb25Gcm9tTWltZVR5cGUobWltZVR5cGUpIHtcbiAgICBjb25zdCBtaW1lVG9FeHQgPSB7XG4gICAgICBcImltYWdlL2pwZWdcIjogXCJqcGdcIixcbiAgICAgIFwiaW1hZ2UvcG5nXCI6IFwicG5nXCIsXG4gICAgICBcImltYWdlL2dpZlwiOiBcImdpZlwiLFxuICAgICAgXCJpbWFnZS93ZWJwXCI6IFwid2VicFwiLFxuICAgICAgXCJpbWFnZS9ibXBcIjogXCJibXBcIixcbiAgICAgIFwiaW1hZ2Uvc3ZnK3htbFwiOiBcInN2Z1wiLFxuICAgICAgXCJhcHBsaWNhdGlvbi9wZGZcIjogXCJwZGZcIixcbiAgICAgIFwidGV4dC9wbGFpblwiOiBcInR4dFwiLFxuICAgICAgXCJ0ZXh0L2h0bWxcIjogXCJodG1sXCIsXG4gICAgICBcInRleHQvY3NzXCI6IFwiY3NzXCIsXG4gICAgICBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIjogXCJqc1wiLFxuICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IFwianNvblwiLFxuICAgICAgXCJhdWRpby9tcGVnXCI6IFwibXAzXCIsXG4gICAgICBcImF1ZGlvL3dhdlwiOiBcIndhdlwiLFxuICAgICAgXCJhdWRpby9vZ2dcIjogXCJvZ2dcIixcbiAgICAgIFwidmlkZW8vbXA0XCI6IFwibXA0XCIsXG4gICAgICBcInZpZGVvL3dlYm1cIjogXCJ3ZWJtXCIsXG4gICAgICBcImFwcGxpY2F0aW9uL3ppcFwiOiBcInppcFwiXG4gICAgfTtcbiAgICByZXR1cm4gbWltZVRvRXh0W21pbWVUeXBlXSB8fCBcImJpblwiO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBkb3dubG9hZCBVUkwgZm9yIGEgZmlsZSB0aGF0IHRyaWdnZXJzIGJyb3dzZXIgZG93bmxvYWRcbiAgICogXG4gICAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byB0aGUgZmlsZSBpbiBwcm9qZWN0IHN0b3JhZ2VcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBEb3dubG9hZCBvcHRpb25zIGluY2x1ZGluZyBjdXN0b20gZmlsZW5hbWVcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gZG93bmxvYWQgcmVzcG9uc2Ugd2l0aCBkb3dubG9hZCBVUkxcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIERvd25sb2FkIHdpdGggb3JpZ2luYWwgZmlsZW5hbWVcbiAgICogY29uc3QgeyBkb3dubG9hZFVybCwgZmlsZW5hbWUgfSA9IGF3YWl0IGJsaW5rLnN0b3JhZ2UuZG93bmxvYWQoJ2ltYWdlcy9waG90by5qcGcnKTtcbiAgICogd2luZG93Lm9wZW4oZG93bmxvYWRVcmwsICdfYmxhbmsnKTtcbiAgICogXG4gICAqIC8vIERvd25sb2FkIHdpdGggY3VzdG9tIGZpbGVuYW1lXG4gICAqIGNvbnN0IHsgZG93bmxvYWRVcmwgfSA9IGF3YWl0IGJsaW5rLnN0b3JhZ2UuZG93bmxvYWQoXG4gICAqICAgJ2ltYWdlcy9waG90by5qcGcnLFxuICAgKiAgIHsgZmlsZW5hbWU6ICdteS1waG90by5qcGcnIH1cbiAgICogKTtcbiAgICogXG4gICAqIC8vIENyZWF0ZSBkb3dubG9hZCBsaW5rIGluIFJlYWN0XG4gICAqIDxhIGhyZWY9e2Rvd25sb2FkVXJsfSBkb3dubG9hZD17ZmlsZW5hbWV9PkRvd25sb2FkIEltYWdlPC9hPlxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGRvd25sb2FkKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXBhdGggfHwgdHlwZW9mIHBhdGggIT09IFwic3RyaW5nXCIgfHwgIXBhdGgudHJpbSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua1N0b3JhZ2VFcnJvcihcIlBhdGggbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5yZXF1ZXN0KFxuICAgICAgICBgL2FwaS9zdG9yYWdlLyR7dGhpcy5odHRwQ2xpZW50LnByb2plY3RJZH0vZG93bmxvYWRgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIHNlYXJjaFBhcmFtczoge1xuICAgICAgICAgICAgcGF0aDogcGF0aC50cmltKCksXG4gICAgICAgICAgICAuLi5vcHRpb25zLmZpbGVuYW1lICYmIHsgZmlsZW5hbWU6IG9wdGlvbnMuZmlsZW5hbWUgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhPy5kb3dubG9hZFVybCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvd25sb2FkVXJsOiByZXNwb25zZS5kYXRhLmRvd25sb2FkVXJsLFxuICAgICAgICAgIGZpbGVuYW1lOiByZXNwb25zZS5kYXRhLmZpbGVuYW1lIHx8IG9wdGlvbnMuZmlsZW5hbWUgfHwgcGF0aC5zcGxpdChcIi9cIikucG9wKCkgfHwgXCJkb3dubG9hZFwiLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5kYXRhLmNvbnRlbnRUeXBlLFxuICAgICAgICAgIHNpemU6IHJlc3BvbnNlLmRhdGEuc2l6ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6IG1pc3NpbmcgZG93bmxvYWRVcmxcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rU3RvcmFnZUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgXCJzdGF0dXNcIiBpbiBlcnJvcikge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXM7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua1N0b3JhZ2VFcnJvcihcIkZpbGUgbm90IGZvdW5kXCIsIDQwNCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiSW52YWxpZCByZXF1ZXN0IHBhcmFtZXRlcnNcIiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFxuICAgICAgICBgRG93bmxvYWQgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgb25lIG9yIG1vcmUgZmlsZXMgZnJvbSBwcm9qZWN0IHN0b3JhZ2VcbiAgICogXG4gICAqIEBwYXJhbSBwYXRocyAtIEZpbGUgcGF0aHMgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGZpbGVzIGFyZSByZW1vdmVkXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBhd2FpdCBibGluay5zdG9yYWdlLnJlbW92ZSgnYXZhdGFycy91c2VyMS5wbmcnKTtcbiAgICogYXdhaXQgYmxpbmsuc3RvcmFnZS5yZW1vdmUoJ2ZpbGUxLnBkZicsICdmaWxlMi5wZGYnLCAnZmlsZTMucGRmJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKC4uLnBhdGhzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiQXQgbGVhc3Qgb25lIHBhdGggbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBpZiAoIXBhdGggfHwgdHlwZW9mIHBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxpbmtTdG9yYWdlRXJyb3IoXCJBbGwgcGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJlcXVlc3QoXG4gICAgICAgIGAvYXBpL3N0b3JhZ2UvJHt0aGlzLmh0dHBDbGllbnQucHJvamVjdElkfS9yZW1vdmVgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgIGJvZHk6IHsgcGF0aHMgfSxcbiAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtTdG9yYWdlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBcInN0YXR1c1wiIGluIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycm9yLnN0YXR1cztcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFwiSW52YWxpZCByZXF1ZXN0IHBhcmFtZXRlcnNcIiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rU3RvcmFnZUVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHJlbW92ZSBmaWxlczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Rvb2xzL2NvcmUudHNcbnZhciB3ZWJTZWFyY2ggPSBcIndlYl9zZWFyY2hcIjtcbnZhciBmZXRjaFVybCA9IFwiZmV0Y2hfdXJsXCI7XG52YXIgcnVuQ29kZSA9IFwicnVuX2NvZGVcIjtcbnZhciBjb3JlVG9vbHMgPSBbd2ViU2VhcmNoLCBmZXRjaFVybCwgcnVuQ29kZV07XG5cbi8vIHNyYy90b29scy9zYW5kYm94LnRzXG52YXIgcmVhZEZpbGUgPSBcInJlYWRfZmlsZVwiO1xudmFyIGxpc3REaXIgPSBcImxpc3RfZGlyXCI7XG52YXIgd3JpdGVGaWxlID0gXCJ3cml0ZV9maWxlXCI7XG52YXIgc2VhcmNoUmVwbGFjZSA9IFwic2VhcmNoX3JlcGxhY2VcIjtcbnZhciBncmVwID0gXCJncmVwXCI7XG52YXIgZ2xvYkZpbGVTZWFyY2ggPSBcImdsb2JfZmlsZV9zZWFyY2hcIjtcbnZhciBydW5UZXJtaW5hbENtZCA9IFwicnVuX3Rlcm1pbmFsX2NtZFwiO1xudmFyIGdldEhvc3QgPSBcImdldF9ob3N0XCI7XG52YXIgc2FuZGJveFRvb2xzID0gW1xuICByZWFkRmlsZSxcbiAgbGlzdERpcixcbiAgd3JpdGVGaWxlLFxuICBzZWFyY2hSZXBsYWNlLFxuICBncmVwLFxuICBnbG9iRmlsZVNlYXJjaCxcbiAgcnVuVGVybWluYWxDbWQsXG4gIGdldEhvc3Rcbl07XG5cbi8vIHNyYy90b29scy9kYi50c1xudmFyIGRiSW5zZXJ0ID0gXCJkYl9pbnNlcnRcIjtcbnZhciBkYkxpc3QgPSBcImRiX2xpc3RcIjtcbnZhciBkYkdldCA9IFwiZGJfZ2V0XCI7XG52YXIgZGJVcGRhdGUgPSBcImRiX3VwZGF0ZVwiO1xudmFyIGRiRGVsZXRlID0gXCJkYl9kZWxldGVcIjtcbnZhciBkYlRvb2xzID0gW2RiSW5zZXJ0LCBkYkxpc3QsIGRiR2V0LCBkYlVwZGF0ZSwgZGJEZWxldGVdO1xuXG4vLyBzcmMvdG9vbHMvc3RvcmFnZS50c1xudmFyIHN0b3JhZ2VVcGxvYWQgPSBcInN0b3JhZ2VfdXBsb2FkXCI7XG52YXIgc3RvcmFnZURvd25sb2FkID0gXCJzdG9yYWdlX2Rvd25sb2FkXCI7XG52YXIgc3RvcmFnZUxpc3QgPSBcInN0b3JhZ2VfbGlzdFwiO1xudmFyIHN0b3JhZ2VEZWxldGUgPSBcInN0b3JhZ2VfZGVsZXRlXCI7XG52YXIgc3RvcmFnZVB1YmxpY1VybCA9IFwic3RvcmFnZV9wdWJsaWNfdXJsXCI7XG52YXIgc3RvcmFnZU1vdmUgPSBcInN0b3JhZ2VfbW92ZVwiO1xudmFyIHN0b3JhZ2VDb3B5ID0gXCJzdG9yYWdlX2NvcHlcIjtcbnZhciBzdG9yYWdlVG9vbHMgPSBbXG4gIHN0b3JhZ2VVcGxvYWQsXG4gIHN0b3JhZ2VEb3dubG9hZCxcbiAgc3RvcmFnZUxpc3QsXG4gIHN0b3JhZ2VEZWxldGUsXG4gIHN0b3JhZ2VQdWJsaWNVcmwsXG4gIHN0b3JhZ2VNb3ZlLFxuICBzdG9yYWdlQ29weVxuXTtcblxuLy8gc3JjL3Rvb2xzL3JhZy50c1xudmFyIHJhZ1NlYXJjaCA9IFwicmFnX3NlYXJjaFwiO1xudmFyIHJhZ1Rvb2xzID0gW3JhZ1NlYXJjaF07XG5cbi8vIHNyYy90b29scy9tZWRpYS50c1xudmFyIGdlbmVyYXRlSW1hZ2UgPSBcImdlbmVyYXRlX2ltYWdlXCI7XG52YXIgZWRpdEltYWdlID0gXCJlZGl0X2ltYWdlXCI7XG52YXIgZ2VuZXJhdGVWaWRlbyA9IFwiZ2VuZXJhdGVfdmlkZW9cIjtcbnZhciBpbWFnZVRvVmlkZW8gPSBcImltYWdlX3RvX3ZpZGVvXCI7XG52YXIgbWVkaWFUb29scyA9IFtnZW5lcmF0ZUltYWdlLCBlZGl0SW1hZ2UsIGdlbmVyYXRlVmlkZW8sIGltYWdlVG9WaWRlb107XG5cbi8vIHNyYy90b29scy9pbmRleC50c1xuZnVuY3Rpb24gc2VyaWFsaXplVG9vbHModG9vbHMpIHtcbiAgcmV0dXJuIHRvb2xzO1xufVxuXG4vLyBzcmMvYWdlbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3BDb25kaXRpb25zKG1heFN0ZXBzLCBzdG9wV2hlbikge1xuICBpZiAoc3RvcFdoZW4gJiYgc3RvcFdoZW4ubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBzdG9wV2hlbjtcbiAgfVxuICBpZiAobWF4U3RlcHMgJiYgbWF4U3RlcHMgPiAwKSB7XG4gICAgcmV0dXJuIFt7IHR5cGU6IFwic3RlcF9jb3VudF9pc1wiLCBjb3VudDogbWF4U3RlcHMgfV07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbnZhciBBZ2VudCA9IGNsYXNzIHtcbiAgaHR0cENsaWVudCA9IG51bGw7XG4gIGNvbmZpZztcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBZ2VudCBpbnN0YW5jZS5cbiAgICogQXV0by1iaW5kcyB0byBkZWZhdWx0IGNsaWVudCBpZiBjcmVhdGVDbGllbnQoKSB3YXMgY2FsbGVkLlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZ2VudCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMubW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJBZ2VudCBtb2RlbCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5jb25maWcgPSBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmh0dHBDbGllbnQgPSBfZ2V0RGVmYXVsdEh0dHBDbGllbnQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEludGVybmFsOiBTZXQgdGhlIEhUVFAgY2xpZW50IChjYWxsZWQgYnkgQmxpbmtDbGllbnQpXG4gICAqL1xuICBfc2V0SHR0cENsaWVudChjbGllbnQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEludGVybmFsOiBHZXQgdGhlIGFnZW50IGNvbmZpZyBmb3IgQVBJIHJlcXVlc3RzXG4gICAqL1xuICBnZXRBZ2VudENvbmZpZygpIHtcbiAgICBjb25zdCB7IG1vZGVsLCBzeXN0ZW0sIGluc3RydWN0aW9ucywgdG9vbHMsIHdlYmhvb2tUb29scywgY2xpZW50VG9vbHMsIHRvb2xDaG9pY2UsIHN0b3BXaGVuLCBtYXhTdGVwcyB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qgc2VyaWFsaXplZFRvb2xzID0gdG9vbHMgPyBzZXJpYWxpemVUb29scyh0b29scykgOiB2b2lkIDA7XG4gICAgY29uc3Qgc3RvcENvbmRpdGlvbnMgPSBjcmVhdGVTdG9wQ29uZGl0aW9ucyhtYXhTdGVwcywgc3RvcFdoZW4pO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlbCxcbiAgICAgIHN5c3RlbTogc3lzdGVtIHx8IGluc3RydWN0aW9ucyxcbiAgICAgIHRvb2xzOiBzZXJpYWxpemVkVG9vbHMsXG4gICAgICB3ZWJob29rX3Rvb2xzOiB3ZWJob29rVG9vbHMsXG4gICAgICBjbGllbnRfdG9vbHM6IGNsaWVudFRvb2xzLFxuICAgICAgdG9vbF9jaG9pY2U6IHRvb2xDaG9pY2UsXG4gICAgICBzdG9wX3doZW46IHN0b3BDb25kaXRpb25zXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSByZXNwb25zZSAobm9uLXN0cmVhbWluZylcbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gR2VuZXJhdGlvbiBvcHRpb25zIChwcm9tcHQgb3IgbWVzc2FnZXMpXG4gICAqIEByZXR1cm5zIFByb21pc2U8QWdlbnRSZXNwb25zZT4gd2l0aCB0ZXh0LCBzdGVwcywgdXNhZ2UsIGFuZCBiaWxsaW5nXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBhZ2VudC5nZW5lcmF0ZSh7XG4gICAqICAgcHJvbXB0OiAnV2hhdCBpcyB0aGUgd2VhdGhlciBpbiBTYW4gRnJhbmNpc2NvPycsXG4gICAqIH0pXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC50ZXh0KVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuc3RlcHMpXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGUob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5odHRwQ2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBcIkFnZW50IG5vdCBpbml0aWFsaXplZC4gQ2FsbCBjcmVhdGVDbGllbnQoKSBmaXJzdCwgb3IgdXNlIHVzZUFnZW50KCkgaW4gUmVhY3QuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5wcm9tcHQgJiYgIW9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJFaXRoZXIgcHJvbXB0IG9yIG1lc3NhZ2VzIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcm9tcHQgJiYgb3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcInByb21wdCBhbmQgbWVzc2FnZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICBzdHJlYW06IGZhbHNlLFxuICAgICAgICBhZ2VudDogdGhpcy5nZXRBZ2VudENvbmZpZygpXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMucHJvbXB0KSB7XG4gICAgICAgIHJlcXVlc3RCb2R5LnByb21wdCA9IG9wdGlvbnMucHJvbXB0O1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICAgIHJlcXVlc3RCb2R5Lm1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNhbmRib3gpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkuc2FuZGJveF9pZCA9IHR5cGVvZiBvcHRpb25zLnNhbmRib3ggPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLnNhbmRib3ggOiBvcHRpb25zLnNhbmRib3guaWQ7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5haUFnZW50KHJlcXVlc3RCb2R5LCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltBZ2VudF0gZ2VuZXJhdGUgZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgQWdlbnQgZ2VuZXJhdGUgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdHJlYW0gYSByZXNwb25zZSAocmVhbC10aW1lKVxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTdHJlYW0gb3B0aW9ucyAocHJvbXB0IG9yIG1lc3NhZ2VzKVxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJlc3BvbnNlPiAtIEFJIFNESyBVSSBNZXNzYWdlIFN0cmVhbSBmb3IgdXNlQ2hhdCBjb21wYXRpYmlsaXR5XG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzdHJlYW0gPSBhd2FpdCBhZ2VudC5zdHJlYW0oe1xuICAgKiAgIHByb21wdDogJ1RlbGwgbWUgYSBzdG9yeScsXG4gICAqIH0pXG4gICAqIFxuICAgKiAvLyBQcm9jZXNzIHN0cmVhbVxuICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbS5ib2R5KSB7XG4gICAqICAgLy8gSGFuZGxlIGNodW5rXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBzdHJlYW0ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5odHRwQ2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBcIkFnZW50IG5vdCBpbml0aWFsaXplZC4gQ2FsbCBjcmVhdGVDbGllbnQoKSBmaXJzdCwgb3IgdXNlIHVzZUFnZW50KCkgaW4gUmVhY3QuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5wcm9tcHQgJiYgIW9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJFaXRoZXIgcHJvbXB0IG9yIG1lc3NhZ2VzIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcm9tcHQgJiYgb3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcInByb21wdCBhbmQgbWVzc2FnZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgIGFnZW50OiB0aGlzLmdldEFnZW50Q29uZmlnKClcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkucHJvbXB0ID0gb3B0aW9ucy5wcm9tcHQ7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkubWVzc2FnZXMgPSBvcHRpb25zLm1lc3NhZ2VzO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2FuZGJveCkge1xuICAgICAgICByZXF1ZXN0Qm9keS5zYW5kYm94X2lkID0gdHlwZW9mIG9wdGlvbnMuc2FuZGJveCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuc2FuZGJveCA6IG9wdGlvbnMuc2FuZGJveC5pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmh0dHBDbGllbnQuYWlBZ2VudFN0cmVhbShyZXF1ZXN0Qm9keSwgb3B0aW9ucy5zaWduYWwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0FnZW50XSBzdHJlYW0gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgQWdlbnQgc3RyZWFtIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhZ2VudCdzIG1vZGVsXG4gICAqL1xuICBnZXQgbW9kZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm1vZGVsO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFnZW50J3Mgc3lzdGVtIHByb21wdFxuICAgKi9cbiAgZ2V0IHN5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc3lzdGVtIHx8IHRoaXMuY29uZmlnLmluc3RydWN0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBhZ2VudCdzIHRvb2xzXG4gICAqL1xuICBnZXQgdG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnRvb2xzO1xuICB9XG59O1xuZnVuY3Rpb24gc3RlcENvdW50SXMoY291bnQpIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJzdGVwX2NvdW50X2lzXCIsIGNvdW50IH07XG59XG5cbi8vIHNyYy9haS50c1xudmFyIEJsaW5rQUlJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50KSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgfVxuICAvLyBTdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0cyBmb3IgdmFsaWRhdGlvblxuICBTVVBQT1JURURfSU1BR0VfRk9STUFUUyA9IFtcImpwZ1wiLCBcImpwZWdcIiwgXCJwbmdcIiwgXCJnaWZcIiwgXCJ3ZWJwXCJdO1xuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIGEgVVJMIGlzIGEgdmFsaWQgSFRUUFMgaW1hZ2UgVVJMXG4gICAqL1xuICB2YWxpZGF0ZUltYWdlVXJsKHVybCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSBcImh0dHBzOlwiKSB7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogXCJJbWFnZSBVUkxzIG11c3QgdXNlIEhUVFBTIHByb3RvY29sXCIgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBoYXNWYWxpZEV4dGVuc2lvbiA9IHRoaXMuU1VQUE9SVEVEX0lNQUdFX0ZPUk1BVFMuc29tZShcbiAgICAgICAgKGZvcm1hdCkgPT4gcGF0aG5hbWUuZW5kc1dpdGgoYC4ke2Zvcm1hdH1gKVxuICAgICAgKTtcbiAgICAgIGlmICghaGFzVmFsaWRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogYEltYWdlIFVSTCBtdXN0IGVuZCB3aXRoIGEgc3VwcG9ydGVkIGZvcm1hdDogJHt0aGlzLlNVUFBPUlRFRF9JTUFHRV9GT1JNQVRTLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogXCJJbnZhbGlkIFVSTCBmb3JtYXRcIiB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIG1lc3NhZ2VzIGZvciBpbWFnZSBjb250ZW50XG4gICAqL1xuICB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgbWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSwgbWVzc2FnZUluZGV4KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpKSB7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudC5mb3JFYWNoKChpdGVtLCBjb250ZW50SW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5pbWFnZSB8fCB0eXBlb2YgaXRlbS5pbWFnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChgTWVzc2FnZSAke21lc3NhZ2VJbmRleH0sIGNvbnRlbnQgJHtjb250ZW50SW5kZXh9OiBJbWFnZSBjb250ZW50IG11c3QgaGF2ZSBhIHZhbGlkIGltYWdlIFVSTGApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVJbWFnZVVybChpdGVtLmltYWdlKTtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChgTWVzc2FnZSAke21lc3NhZ2VJbmRleH0sIGNvbnRlbnQgJHtjb250ZW50SW5kZXh9OiAke3ZhbGlkYXRpb24uZXJyb3J9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsIGVycm9ycyB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgTUlNRSB0eXBlIGZvciBhdWRpbyBmb3JtYXRcbiAgICovXG4gIGdldE1pbWVUeXBlRm9yRm9ybWF0KGZvcm1hdCkge1xuICAgIGNvbnN0IG1pbWVUeXBlcyA9IHtcbiAgICAgIG1wMzogXCJhdWRpby9tcGVnXCIsXG4gICAgICBvcHVzOiBcImF1ZGlvL29wdXNcIixcbiAgICAgIGFhYzogXCJhdWRpby9hYWNcIixcbiAgICAgIGZsYWM6IFwiYXVkaW8vZmxhY1wiLFxuICAgICAgd2F2OiBcImF1ZGlvL3dhdlwiLFxuICAgICAgcGNtOiBcImF1ZGlvL3BjbVwiXG4gICAgfTtcbiAgICByZXR1cm4gbWltZVR5cGVzW2Zvcm1hdF0gfHwgXCJhdWRpby9tcGVnXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHRleHQgcmVzcG9uc2UgdXNpbmcgdGhlIEJsaW5rIEFJIGVuZ2luZS5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgZWl0aGVyOlxuICAgKiAgIC0gYHByb21wdGA6IGEgc2ltcGxlIHN0cmluZyBwcm9tcHRcbiAgICogICAtIE9SIGBtZXNzYWdlc2A6IGFuIGFycmF5IG9mIGNoYXQgbWVzc2FnZXMgZm9yIGNvbnZlcnNhdGlvblxuICAgKiAgIC0gUGx1cyBvcHRpb25hbCBtb2RlbCwgc2VhcmNoLCBtYXhTdGVwcywgZXhwZXJpbWVudGFsX2NvbnRpbnVlU3RlcHMsIG1heFRva2VucywgdGVtcGVyYXR1cmUsIHNpZ25hbCBwYXJhbWV0ZXJzXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBTaW1wbGUgcHJvbXB0XG4gICAqIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVUZXh0KHsgXG4gICAqICAgcHJvbXB0OiBcIldyaXRlIGEgcG9lbSBhYm91dCBjb2RpbmdcIiBcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBDaGF0IG1lc3NhZ2VzICh0ZXh0IG9ubHkpXG4gICAqIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVUZXh0KHtcbiAgICogICBtZXNzYWdlczogW1xuICAgKiAgICAgeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBcIllvdSBhcmUgYSBoZWxwZnVsIGFzc2lzdGFudFwiIH0sXG4gICAqICAgICB7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBcIkV4cGxhaW4gcXVhbnR1bSBjb21wdXRpbmdcIiB9XG4gICAqICAgXVxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIFdpdGggaW1hZ2UgY29udGVudFxuICAgKiBjb25zdCB7IHRleHQgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlVGV4dCh7XG4gICAqICAgbWVzc2FnZXM6IFtcbiAgICogICAgIHsgXG4gICAqICAgICAgIHJvbGU6IFwidXNlclwiLCBcbiAgICogICAgICAgY29udGVudDogW1xuICAgKiAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IFwiV2hhdCBkbyB5b3Ugc2VlIGluIHRoaXMgaW1hZ2U/XCIgfSxcbiAgICogICAgICAgICB7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9waG90by5qcGdcIiB9XG4gICAqICAgICAgIF1cbiAgICogICAgIH1cbiAgICogICBdXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gTWl4ZWQgY29udGVudCB3aXRoIG11bHRpcGxlIGltYWdlc1xuICAgKiBjb25zdCB7IHRleHQgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlVGV4dCh7XG4gICAqICAgbWVzc2FnZXM6IFtcbiAgICogICAgIHsgXG4gICAqICAgICAgIHJvbGU6IFwidXNlclwiLCBcbiAgICogICAgICAgY29udGVudDogW1xuICAgKiAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IFwiQ29tcGFyZSB0aGVzZSB0d28gaW1hZ2VzOlwiIH0sXG4gICAqICAgICAgICAgeyB0eXBlOiBcImltYWdlXCIsIGltYWdlOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vaW1hZ2UxLmpwZ1wiIH0sXG4gICAqICAgICAgICAgeyB0eXBlOiBcImltYWdlXCIsIGltYWdlOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vaW1hZ2UyLmpwZ1wiIH1cbiAgICogICAgICAgXVxuICAgKiAgICAgfVxuICAgKiAgIF1cbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBXaXRoIG9wdGlvbnNcbiAgICogY29uc3QgeyB0ZXh0LCB1c2FnZSB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVUZXh0KHtcbiAgICogICBwcm9tcHQ6IFwiU3VtbWFyaXplIHRoaXMgYXJ0aWNsZVwiLFxuICAgKiAgIG1vZGVsOiBcImdwdC00LjEtbWluaVwiLFxuICAgKiAgIG1heFRva2VuczogMTUwLFxuICAgKiAgIHRlbXBlcmF0dXJlOiAwLjdcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBXaXRoIHdlYiBzZWFyY2ggKE9wZW5BSSBtb2RlbHMgb25seSlcbiAgICogY29uc3QgeyB0ZXh0LCBzb3VyY2VzIH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVRleHQoe1xuICAgKiAgIHByb21wdDogXCJXaGF0IGFyZSB0aGUgbGF0ZXN0IGRldmVsb3BtZW50cyBpbiBBST9cIixcbiAgICogICBtb2RlbDogXCJncHQtNC4xLW1pbmlcIixcbiAgICogICBzZWFyY2g6IHRydWUgLy8gRW5hYmxlcyB3ZWIgc2VhcmNoXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gV2l0aCBhZHZhbmNlZCBtdWx0aS1zdGVwIGNvbmZpZ3VyYXRpb25cbiAgICogY29uc3QgeyB0ZXh0IH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVRleHQoe1xuICAgKiAgIHByb21wdDogXCJSZXNlYXJjaCBhbmQgYW5hbHl6ZSByZWNlbnQgdGVjaCB0cmVuZHNcIixcbiAgICogICBtb2RlbDogXCJncHQtNG9cIixcbiAgICogICBzZWFyY2g6IHRydWUsXG4gICAqICAgbWF4U3RlcHM6IDEwLCAvLyBBbGxvdyB1cCB0byAxMCByZWFzb25pbmcgc3RlcHNcbiAgICogICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogdHJ1ZSAvLyBFbmFibGUgY29udGludWVkIHJlYXNvbmluZ1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPFRleHRHZW5lcmF0aW9uUmVzcG9uc2U+IC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgdGV4dGA6IEdlbmVyYXRlZCB0ZXh0IHN0cmluZ1xuICAgKiAgIC0gYHVzYWdlYDogVG9rZW4gdXNhZ2UgaW5mb3JtYXRpb25cbiAgICogICAtIGBmaW5pc2hSZWFzb25gOiBXaHkgZ2VuZXJhdGlvbiBzdG9wcGVkIChcInN0b3BcIiwgXCJsZW5ndGhcIiwgZXRjLilcbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGV4dChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9tcHQgJiYgIW9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkVpdGhlciBwcm9tcHQgb3IgbWVzc2FnZXMgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZU1lc3NhZ2VzKG9wdGlvbnMubWVzc2FnZXMpO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoYE1lc3NhZ2UgdmFsaWRhdGlvbiBmYWlsZWQ6ICR7dmFsaWRhdGlvbi5lcnJvcnMuam9pbihcIjsgXCIpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgIHNlYXJjaDogb3B0aW9ucy5zZWFyY2gsXG4gICAgICAgIG1heFN0ZXBzOiBvcHRpb25zLm1heFN0ZXBzLFxuICAgICAgICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogb3B0aW9ucy5leHBlcmltZW50YWxfY29udGludWVTdGVwcyxcbiAgICAgICAgbWF4VG9rZW5zOiBvcHRpb25zLm1heFRva2VucyxcbiAgICAgICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMudGVtcGVyYXR1cmUsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkucHJvbXB0ID0gb3B0aW9ucy5wcm9tcHQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICByZXF1ZXN0Qm9keS5tZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXM7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5haVRleHQoXG4gICAgICAgIG9wdGlvbnMucHJvbXB0IHx8IFwiXCIsXG4gICAgICAgIHJlcXVlc3RCb2R5XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBUZXh0IGdlbmVyYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdHJlYW1zIHRleHQgZ2VuZXJhdGlvbiB3aXRoIHJlYWwtdGltZSB1cGRhdGVzIGFzIHRoZSBBSSBnZW5lcmF0ZXMgY29udGVudC5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2FtZSBhcyBnZW5lcmF0ZVRleHQ6IGVpdGhlciBgcHJvbXB0YCBvciBgbWVzc2FnZXNgIHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycyBpbmNsdWRpbmcgc2VhcmNoLCBtYXhTdGVwcywgZXhwZXJpbWVudGFsX2NvbnRpbnVlU3RlcHNcbiAgICogQHBhcmFtIG9uQ2h1bmsgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGVhY2ggdGV4dCBjaHVuayBhcyBpdCdzIGdlbmVyYXRlZFxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gU3RyZWFtIHdpdGggcHJvbXB0XG4gICAqIGF3YWl0IGJsaW5rLmFpLnN0cmVhbVRleHQoXG4gICAqICAgeyBwcm9tcHQ6IFwiV3JpdGUgYSBzaG9ydCBzdG9yeSBhYm91dCBzcGFjZSBleHBsb3JhdGlvblwiIH0sXG4gICAqICAgKGNodW5rKSA9PiB7XG4gICAqICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjaHVuayk7IC8vIFJlYWwtdGltZSBvdXRwdXRcbiAgICogICB9XG4gICAqICk7XG4gICAqIFxuICAgKiAvLyBTdHJlYW0gd2l0aCBtZXNzYWdlc1xuICAgKiBhd2FpdCBibGluay5haS5zdHJlYW1UZXh0KFxuICAgKiAgIHsgXG4gICAqICAgICBtZXNzYWdlczogW1xuICAgKiAgICAgICB7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IFwiWW91IGFyZSBhIGNyZWF0aXZlIHdyaXRlclwiIH0sXG4gICAqICAgICAgIHsgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IFwiV3JpdGUgYSBoYWlrdSBhYm91dCBwcm9ncmFtbWluZ1wiIH1cbiAgICogICAgIF1cbiAgICogICB9LFxuICAgKiAgIChjaHVuaykgPT4gdXBkYXRlVUkoY2h1bmspXG4gICAqICk7XG4gICAqIGBgYFxuICAgKiBcbiAgICogQHJldHVybnMgUHJvbWlzZTxUZXh0R2VuZXJhdGlvblJlc3BvbnNlPiAtIEZpbmFsIGNvbXBsZXRlIHJlc3BvbnNlIHdpdGggZnVsbCB0ZXh0IGFuZCBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgc3RyZWFtVGV4dChvcHRpb25zLCBvbkNodW5rKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9tcHQgJiYgIW9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkVpdGhlciBwcm9tcHQgb3IgbWVzc2FnZXMgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZU1lc3NhZ2VzKG9wdGlvbnMubWVzc2FnZXMpO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoYE1lc3NhZ2UgdmFsaWRhdGlvbiBmYWlsZWQ6ICR7dmFsaWRhdGlvbi5lcnJvcnMuam9pbihcIjsgXCIpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuc3RyZWFtQWlUZXh0KFxuICAgICAgICBvcHRpb25zLnByb21wdCB8fCBcIlwiLFxuICAgICAgICB7XG4gICAgICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXMsXG4gICAgICAgICAgc2VhcmNoOiBvcHRpb25zLnNlYXJjaCxcbiAgICAgICAgICBtYXhTdGVwczogb3B0aW9ucy5tYXhTdGVwcyxcbiAgICAgICAgICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogb3B0aW9ucy5leHBlcmltZW50YWxfY29udGludWVTdGVwcyxcbiAgICAgICAgICBtYXhUb2tlbnM6IG9wdGlvbnMubWF4VG9rZW5zLFxuICAgICAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLnRlbXBlcmF0dXJlLFxuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgfSxcbiAgICAgICAgb25DaHVua1xuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IHJlc3VsdC50ZXh0IHx8IFwiXCIsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0LmZpbmlzaFJlYXNvbiB8fCBcInN0b3BcIixcbiAgICAgICAgdXNhZ2U6IHJlc3VsdC51c2FnZSxcbiAgICAgICAgdG9vbENhbGxzOiByZXN1bHQudG9vbENhbGxzLFxuICAgICAgICB0b29sUmVzdWx0czogcmVzdWx0LnRvb2xSZXN1bHRzLFxuICAgICAgICBzb3VyY2VzOiByZXN1bHQuc291cmNlcyxcbiAgICAgICAgZmlsZXM6IHJlc3VsdC5maWxlcyxcbiAgICAgICAgcmVhc29uaW5nRGV0YWlsczogcmVzdWx0LnJlYXNvbmluZyxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXNwb25zZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBSUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcbiAgICAgICAgYFRleHQgc3RyZWFtaW5nIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHN0cnVjdHVyZWQgSlNPTiBvYmplY3RzIHVzaW5nIEFJIHdpdGggc2NoZW1hIHZhbGlkYXRpb24uXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYHByb21wdGA6IERlc2NyaXB0aW9uIG9mIHdoYXQgb2JqZWN0IHRvIGdlbmVyYXRlIChyZXF1aXJlZClcbiAgICogICAtIGBzY2hlbWFgOiBKU09OIFNjaGVtYSB0byB2YWxpZGF0ZSB0aGUgZ2VuZXJhdGVkIG9iamVjdFxuICAgKiAgIC0gYG91dHB1dGA6IFR5cGUgb2Ygb3V0cHV0IChcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiZW51bVwiKVxuICAgKiAgIC0gYGVudW1gOiBBcnJheSBvZiBhbGxvd2VkIHZhbHVlcyBmb3IgZW51bSBvdXRwdXRcbiAgICogICAtIFBsdXMgb3B0aW9uYWwgbW9kZWwsIHNpZ25hbCBwYXJhbWV0ZXJzXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBHZW5lcmF0ZSB1c2VyIHByb2ZpbGVcbiAgICogY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlT2JqZWN0KHtcbiAgICogICBwcm9tcHQ6IFwiR2VuZXJhdGUgYSB1c2VyIHByb2ZpbGUgZm9yIGEgc29mdHdhcmUgZGV2ZWxvcGVyXCIsXG4gICAqICAgc2NoZW1hOiB7XG4gICAqICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgKiAgICAgcHJvcGVydGllczoge1xuICAgKiAgICAgICBuYW1lOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICogICAgICAgYWdlOiB7IHR5cGU6IFwibnVtYmVyXCIgfSxcbiAgICogICAgICAgc2tpbGxzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0sXG4gICAqICAgICAgIGV4cGVyaWVuY2U6IHsgdHlwZTogXCJudW1iZXJcIiB9XG4gICAqICAgICB9LFxuICAgKiAgICAgcmVxdWlyZWQ6IFtcIm5hbWVcIiwgXCJza2lsbHNcIl1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8gR2VuZXJhdGUgYXJyYXkgb2YgaXRlbXNcbiAgICogY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlT2JqZWN0KHtcbiAgICogICBwcm9tcHQ6IFwiTGlzdCA1IHByb2dyYW1taW5nIGxhbmd1YWdlc1wiLFxuICAgKiAgIG91dHB1dDogXCJhcnJheVwiLFxuICAgKiAgIHNjaGVtYToge1xuICAgKiAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgKiAgICAgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIEdlbmVyYXRlIGVudW0gdmFsdWVcbiAgICogY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlT2JqZWN0KHtcbiAgICogICBwcm9tcHQ6IFwiQ2hvb3NlIHRoZSBiZXN0IHByb2dyYW1taW5nIGxhbmd1YWdlIGZvciB3ZWIgZGV2ZWxvcG1lbnRcIixcbiAgICogICBvdXRwdXQ6IFwiZW51bVwiLFxuICAgKiAgIGVudW06IFtcIkphdmFTY3JpcHRcIiwgXCJQeXRob25cIiwgXCJUeXBlU2NyaXB0XCIsIFwiR29cIl1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBcbiAgICogQHJldHVybnMgUHJvbWlzZTxPYmplY3RHZW5lcmF0aW9uUmVzcG9uc2U+IC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgb2JqZWN0YDogVGhlIGdlbmVyYXRlZCBhbmQgdmFsaWRhdGVkIEpTT04gb2JqZWN0L2FycmF5L2VudW1cbiAgICogICAtIGB1c2FnZWA6IFRva2VuIHVzYWdlIGluZm9ybWF0aW9uXG4gICAqICAgLSBgZmluaXNoUmVhc29uYDogV2h5IGdlbmVyYXRpb24gc3RvcHBlZFxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVPYmplY3Qob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvbXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJQcm9tcHQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5haU9iamVjdChcbiAgICAgICAgb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBvdXRwdXQ6IG9wdGlvbnMub3V0cHV0LFxuICAgICAgICAgIHNjaGVtYTogb3B0aW9ucy5zY2hlbWEsXG4gICAgICAgICAgZW51bTogb3B0aW9ucy5lbnVtLFxuICAgICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rQUlFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXG4gICAgICAgIGBPYmplY3QgZ2VuZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0cmVhbXMgc3RydWN0dXJlZCBvYmplY3QgZ2VuZXJhdGlvbiB3aXRoIHJlYWwtdGltZSBwYXJ0aWFsIHVwZGF0ZXMgYXMgdGhlIEFJIGJ1aWxkcyB0aGUgb2JqZWN0LlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTYW1lIGFzIGdlbmVyYXRlT2JqZWN0OiBwcm9tcHQsIHNjaGVtYSwgb3V0cHV0IHR5cGUsIGV0Yy5cbiAgICogQHBhcmFtIG9uUGFydGlhbCAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgcGFydGlhbCBvYmplY3QgdXBkYXRlcyBhcyB0aGV5J3JlIGdlbmVyYXRlZFxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gU3RyZWFtIG9iamVjdCBnZW5lcmF0aW9uIHdpdGggc2NoZW1hXG4gICAqIGF3YWl0IGJsaW5rLmFpLnN0cmVhbU9iamVjdChcbiAgICogICB7XG4gICAqICAgICBwcm9tcHQ6IFwiR2VuZXJhdGUgYSBkZXRhaWxlZCBwcm9kdWN0IGNhdGFsb2cgZW50cnlcIixcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgKiAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICAgICAgbmFtZTogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAqICAgICAgICAgcHJpY2U6IHsgdHlwZTogXCJudW1iZXJcIiB9LFxuICAgKiAgICAgICAgIGRlc2NyaXB0aW9uOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICogICAgICAgICBmZWF0dXJlczogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9LFxuICAgKiAgIChwYXJ0aWFsKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcIlBhcnRpYWwgdXBkYXRlOlwiLCBwYXJ0aWFsKTtcbiAgICogICAgIHVwZGF0ZVByb2R1Y3RGb3JtKHBhcnRpYWwpOyAvLyBVcGRhdGUgVUkgaW4gcmVhbC10aW1lXG4gICAqICAgfVxuICAgKiApO1xuICAgKiBgYGBcbiAgICogXG4gICAqIEByZXR1cm5zIFByb21pc2U8T2JqZWN0R2VuZXJhdGlvblJlc3BvbnNlPiAtIEZpbmFsIGNvbXBsZXRlIG9iamVjdCB3aXRoIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBzdHJlYW1PYmplY3Qob3B0aW9ucywgb25QYXJ0aWFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9tcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIlByb21wdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5zdHJlYW1BaU9iamVjdChcbiAgICAgICAgb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBvdXRwdXQ6IG9wdGlvbnMub3V0cHV0LFxuICAgICAgICAgIHNjaGVtYTogb3B0aW9ucy5zY2hlbWEsXG4gICAgICAgICAgZW51bTogb3B0aW9ucy5lbnVtLFxuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgfSxcbiAgICAgICAgb25QYXJ0aWFsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2JqZWN0OiByZXN1bHQub2JqZWN0IHx8IHt9LFxuICAgICAgICBmaW5pc2hSZWFzb246IFwic3RvcFwiLFxuICAgICAgICB1c2FnZTogcmVzdWx0LnVzYWdlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgT2JqZWN0IHN0cmVhbWluZyBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBpbWFnZXMgZnJvbSB0ZXh0IGRlc2NyaXB0aW9ucyB1c2luZyBBSSBpbWFnZSBtb2RlbHMuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYHByb21wdGA6IFRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGRlc2lyZWQgaW1hZ2UgKHJlcXVpcmVkLCB1cCB0byAxMDBrIGNoYXJhY3RlcnMpXG4gICAqICAgLSBgbW9kZWxgOiBBSSBtb2RlbCB0byB1c2UgKG9wdGlvbmFsKS4gQXZhaWxhYmxlIG1vZGVsczpcbiAgICogICAgICAgKipGYWwuYWkgTW9kZWxzIChSZWNvbW1lbmRlZCk6KipcbiAgICogICAgICAgLSBgXCJmYWwtYWkvbmFuby1iYW5hbmFcImAgKGRlZmF1bHQpIC0gR2VtaW5pIDIuNSBGbGFzaCBJbWFnZSAoRmFzdClcbiAgICogICAgICAgLSBgXCJmYWwtYWkvbmFuby1iYW5hbmEtcHJvXCJgIC0gR2VtaW5pIDMgUHJvIEltYWdlIChIaWdoIHF1YWxpdHkpXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL2dlbWluaS0yNS1mbGFzaC1pbWFnZVwiYCAtIEFsaWFzIGZvciBuYW5vLWJhbmFuYVxuICAgKiAgICAgICAtIGBcImZhbC1haS9nZW1pbmktMy1wcm8taW1hZ2UtcHJldmlld1wiYCAtIEFsaWFzIGZvciBuYW5vLWJhbmFuYS1wcm9cbiAgICogICAgICAgKipMZWdhY3kgR2VtaW5pIE1vZGVsczoqKlxuICAgKiAgICAgICAtIGBcImdlbWluaS0yLjUtZmxhc2gtaW1hZ2UtcHJldmlld1wiYCAtIERpcmVjdCBHZW1pbmkgQVBJXG4gICAqICAgICAgIC0gYFwiZ2VtaW5pLTMtcHJvLWltYWdlLXByZXZpZXdcImAgLSBEaXJlY3QgR2VtaW5pIEFQSVxuICAgKiAgIC0gYG5gOiBOdW1iZXIgb2YgaW1hZ2VzIHRvIGdlbmVyYXRlIChkZWZhdWx0OiAxKVxuICAgKiAgIC0gYHNpemVgOiBJbWFnZSBkaW1lbnNpb25zIChlLmcuLCBcIjEwMjR4MTAyNFwiLCBcIjUxMng1MTJcIilcbiAgICogICAtIFBsdXMgb3B0aW9uYWwgc2lnbmFsIHBhcmFtZXRlclxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gQmFzaWMgaW1hZ2UgZ2VuZXJhdGlvbiAodXNlcyBkZWZhdWx0IGZhc3QgbW9kZWwpXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVJbWFnZSh7XG4gICAqICAgcHJvbXB0OiBcIkEgc2VyZW5lIGxhbmRzY2FwZSB3aXRoIG1vdW50YWlucyBhbmQgYSBsYWtlIGF0IHN1bnNldFwiXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhcIkltYWdlIFVSTDpcIiwgZGF0YVswXS51cmwpO1xuICAgKiBcbiAgICogLy8gSGlnaCBxdWFsaXR5IGdlbmVyYXRpb24gd2l0aCBQcm8gbW9kZWxcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZUltYWdlKHtcbiAgICogICBwcm9tcHQ6IFwiQSBkZXRhaWxlZCBpbmZvZ3JhcGhpYyBhYm91dCBBSSB3aXRoIGNoYXJ0cyBhbmQgZGlhZ3JhbXNcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvbmFuby1iYW5hbmEtcHJvXCIsXG4gICAqICAgbjogMlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIEZhc3QgZ2VuZXJhdGlvbiB3aXRoIHNwZWNpZmljIHNpemVcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZUltYWdlKHtcbiAgICogICBwcm9tcHQ6IFwiQSBmdXR1cmlzdGljIGNpdHkgc2t5bGluZSB3aXRoIGZseWluZyBjYXJzXCIsXG4gICAqICAgbW9kZWw6IFwiZmFsLWFpL25hbm8tYmFuYW5hXCIsXG4gICAqICAgc2l6ZTogXCIxMDI0eDEwMjRcIixcbiAgICogICBuOiAzXG4gICAqIH0pO1xuICAgKiBkYXRhLmZvckVhY2goKGltZywgaSkgPT4gY29uc29sZS5sb2coYEltYWdlICR7aSsxfTpgLCBpbWcudXJsKSk7XG4gICAqIFxuICAgKiAvLyBVc2luZyBsZWdhY3kgR2VtaW5pIG1vZGVsXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVJbWFnZSh7XG4gICAqICAgcHJvbXB0OiBcIkEgY3V0ZSByb2JvdCBtYXNjb3QgZm9yIGEgdGVjaCBjb21wYW55XCIsXG4gICAqICAgbW9kZWw6IFwiZ2VtaW5pLTIuNS1mbGFzaC1pbWFnZS1wcmV2aWV3XCJcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBcbiAgICogQHJldHVybnMgUHJvbWlzZTxJbWFnZUdlbmVyYXRpb25SZXNwb25zZT4gLSBPYmplY3QgY29udGFpbmluZzpcbiAgICogICAtIGBkYXRhYDogQXJyYXkgb2YgZ2VuZXJhdGVkIGltYWdlcyB3aXRoIFVSTHNcbiAgICogICAtIGBjcmVhdGVkYDogVGltZXN0YW1wIG9mIGdlbmVyYXRpb25cbiAgICogICAtIGBtb2RlbGA6IFRoZSBtb2RlbCB1c2VkIGZvciBnZW5lcmF0aW9uXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUltYWdlKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb21wdCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiUHJvbXB0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuYWlJbWFnZShcbiAgICAgICAgb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBuOiBvcHRpb25zLm4sXG4gICAgICAgICAgc2l6ZTogb3B0aW9ucy5zaXplLFxuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGxldCBpbWFnZVJlc3BvbnNlO1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGE/LnJlc3VsdD8uZGF0YSkge1xuICAgICAgICBpbWFnZVJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmRhdGE/LmRhdGEpIHtcbiAgICAgICAgaW1hZ2VSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6IG1pc3NpbmcgaW1hZ2UgZGF0YVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbWFnZVJlc3BvbnNlLmRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDogZGF0YSBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gICAgICB9XG4gICAgICBpbWFnZVJlc3BvbnNlLmRhdGEgPSBpbWFnZVJlc3BvbnNlLmRhdGEubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB7IHVybDogaXRlbSB9O1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udXJsKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgaW1hZ2UgcmVzcG9uc2UgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbWFnZVJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgSW1hZ2UgZ2VuZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGV4aXN0aW5nIGltYWdlcyB1c2luZyBBSSBpbWFnZSBlZGl0aW5nIG1vZGVscyB3aXRoIHRleHQgcHJvbXB0cyBmb3IgaW1hZ2UtdG8taW1hZ2UgZWRpdGluZy5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgaW1hZ2VzYDogQXJyYXkgb2YgcHVibGljIGltYWdlIFVSTHMgdG8gbW9kaWZ5IChyZXF1aXJlZCwgdXAgdG8gNTAgaW1hZ2VzKVxuICAgKiAgIC0gYHByb21wdGA6IFRleHQgZGVzY3JpcHRpb24gb2YgZGVzaXJlZCBtb2RpZmljYXRpb25zIChyZXF1aXJlZCwgdXAgdG8gMTAwayBjaGFyYWN0ZXJzKVxuICAgKiAgIC0gYG1vZGVsYDogQUkgbW9kZWwgdG8gdXNlIChvcHRpb25hbCkuIEF2YWlsYWJsZSBlZGl0aW5nIG1vZGVsczpcbiAgICogICAgICAgKipGYWwuYWkgRWRpdGluZyBNb2RlbHMgKFJlY29tbWVuZGVkKToqKlxuICAgKiAgICAgICAtIGBcImZhbC1haS9uYW5vLWJhbmFuYS9lZGl0XCJgIChkZWZhdWx0KSAtIEZsYXNoIGVkaXRpbmcgKEZhc3QpXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL25hbm8tYmFuYW5hLXByby9lZGl0XCJgIC0gUHJvIGVkaXRpbmcgKEhpZ2ggcXVhbGl0eSlcbiAgICogICAgICAgLSBgXCJmYWwtYWkvZ2VtaW5pLTI1LWZsYXNoLWltYWdlL2VkaXRcImAgLSBBbGlhcyBmb3IgbmFuby1iYW5hbmEvZWRpdFxuICAgKiAgICAgICAtIGBcImZhbC1haS9nZW1pbmktMy1wcm8taW1hZ2UtcHJldmlldy9lZGl0XCJgIC0gQWxpYXMgZm9yIG5hbm8tYmFuYW5hLXByby9lZGl0XG4gICAqICAgICAgICoqTGVnYWN5IEdlbWluaSBNb2RlbHM6KipcbiAgICogICAgICAgLSBgXCJnZW1pbmktMi41LWZsYXNoLWltYWdlLXByZXZpZXdcImAgLSBEaXJlY3QgR2VtaW5pIEFQSVxuICAgKiAgICAgICAtIGBcImdlbWluaS0zLXByby1pbWFnZS1wcmV2aWV3XCJgIC0gRGlyZWN0IEdlbWluaSBBUElcbiAgICogICAtIGBuYDogTnVtYmVyIG9mIG91dHB1dCBpbWFnZXMgdG8gZ2VuZXJhdGUgKGRlZmF1bHQ6IDEpXG4gICAqICAgLSBQbHVzIG9wdGlvbmFsIHNpZ25hbCBwYXJhbWV0ZXJcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIEZhc3QgZWRpdGluZyB3aXRoIGRlZmF1bHQgbW9kZWxcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5tb2RpZnlJbWFnZSh7XG4gICAqICAgaW1hZ2VzOiBbXCJodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vcGhvdG8uanBnXCJdLFxuICAgKiAgIHByb21wdDogXCJtYWtlIGl0IGdyZWVuXCJcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBIaWdoIHF1YWxpdHkgZWRpdGluZyB3aXRoIFBybyBtb2RlbFxuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJsaW5rLmFpLm1vZGlmeUltYWdlKHtcbiAgICogICBpbWFnZXM6IFtcImh0dHBzOi8vc3RvcmFnZS5leGFtcGxlLmNvbS9sYW5kc2NhcGUuanBnXCJdLFxuICAgKiAgIHByb21wdDogXCJhZGQgYSB0cmVlIGluIHRoZSBiYWNrZ3JvdW5kXCIsXG4gICAqICAgbW9kZWw6IFwiZmFsLWFpL25hbm8tYmFuYW5hLXByby9lZGl0XCJcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBQcm9mZXNzaW9uYWwgaGVhZHNob3RzIGZyb20gY2FzdWFsIHBob3Rvc1xuICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJsaW5rLmFpLm1vZGlmeUltYWdlKHtcbiAgICogICBpbWFnZXM6IFtcbiAgICogICAgIFwiaHR0cHM6Ly9zdG9yYWdlLmV4YW1wbGUuY29tL3VzZXItcGhvdG8tMS5qcGdcIixcbiAgICogICAgIFwiaHR0cHM6Ly9zdG9yYWdlLmV4YW1wbGUuY29tL3VzZXItcGhvdG8tMi5qcGdcIlxuICAgKiAgIF0sXG4gICAqICAgcHJvbXB0OiBcIlRyYW5zZm9ybSBpbnRvIHByb2Zlc3Npb25hbCBidXNpbmVzcyBoZWFkc2hvdHMgd2l0aCBzdHVkaW8gbGlnaHRpbmdcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvbmFuby1iYW5hbmEvZWRpdFwiLFxuICAgKiAgIG46IDRcbiAgICogfSk7XG4gICAqIGRhdGEuZm9yRWFjaCgoaW1nLCBpKSA9PiBjb25zb2xlLmxvZyhgSGVhZHNob3QgJHtpKzF9OmAsIGltZy51cmwpKTtcbiAgICogXG4gICAqIC8vIEFydGlzdGljIHN0eWxlIHRyYW5zZm9ybWF0aW9uXG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYmxpbmsuYWkubW9kaWZ5SW1hZ2Uoe1xuICAgKiAgIGltYWdlczogW1wiaHR0cHM6Ly9zdG9yYWdlLmV4YW1wbGUuY29tL3BvcnRyYWl0LmpwZ1wiXSxcbiAgICogICBwcm9tcHQ6IFwiVHJhbnNmb3JtIGludG8gb2lsIHBhaW50aW5nIHN0eWxlIHdpdGggZHJhbWF0aWMgbGlnaHRpbmdcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvbmFuby1iYW5hbmEtcHJvL2VkaXRcIlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIEJhY2tncm91bmQgcmVwbGFjZW1lbnRcbiAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBibGluay5haS5tb2RpZnlJbWFnZSh7XG4gICAqICAgaW1hZ2VzOiBbXCJodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vcHJvZHVjdC5qcGdcIl0sXG4gICAqICAgcHJvbXB0OiBcIlJlbW92ZSBiYWNrZ3JvdW5kIGFuZCBwbGFjZSBvbiBjbGVhbiB3aGl0ZSBzdHVkaW8gYmFja2dyb3VuZFwiLFxuICAgKiAgIG46IDJcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBCYXRjaCBwcm9jZXNzaW5nIG11bHRpcGxlIHBob3Rvc1xuICAgKiBjb25zdCB1c2VyUGhvdG9zID0gW1xuICAgKiAgIFwiaHR0cHM6Ly9zdG9yYWdlLmV4YW1wbGUuY29tL3Bob3RvMS5qcGdcIixcbiAgICogICBcImh0dHBzOi8vc3RvcmFnZS5leGFtcGxlLmNvbS9waG90bzIuanBnXCIsXG4gICAqICAgXCJodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vcGhvdG8zLmpwZ1wiXG4gICAqIF07XG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYmxpbmsuYWkubW9kaWZ5SW1hZ2Uoe1xuICAgKiAgIGltYWdlczogdXNlclBob3RvcyxcbiAgICogICBwcm9tcHQ6IFwiQ29udmVydCB0byBibGFjayBhbmQgd2hpdGUgdmludGFnZSBzdHlsZSBwaG90b2dyYXBoc1wiXG4gICAqIH0pO1xuICAgKiBcbiAgICogLy8g8J+OqCBTdHlsZSBUcmFuc2ZlciAtIElNUE9SVEFOVDogUHJvdmlkZSBhbGwgaW1hZ2VzIGluIGFycmF5XG4gICAqIC8vIOKdjCBXUk9ORyAtIERvbid0IHJlZmVyZW5jZSBvdGhlciBpbWFnZXMgaW4gcHJvbXB0XG4gICAqIGNvbnN0IHdyb25nID0gYXdhaXQgYmxpbmsuYWkubW9kaWZ5SW1hZ2Uoe1xuICAgKiAgIGltYWdlczogW3VzZXJQaG90b1VybF0sXG4gICAqICAgcHJvbXB0OiBgQXBwbHkgaGFpcnN0eWxlIGZyb20gJHtyZWZlcmVuY2VVcmx9YFxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIOKchSBDT1JSRUNUIC0gUHJvdmlkZSBhbGwgaW1hZ2VzIGluIGFycmF5XG4gICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYmxpbmsuYWkubW9kaWZ5SW1hZ2Uoe1xuICAgKiAgIGltYWdlczogW3VzZXJQaG90b1VybCwgaGFpcnN0eWxlUmVmZXJlbmNlVXJsXSxcbiAgICogICBwcm9tcHQ6IFwiQXBwbHkgdGhlIGhhaXJzdHlsZSBmcm9tIHRoZSBzZWNvbmQgaW1hZ2UgdG8gdGhlIHBlcnNvbiBpbiB0aGUgZmlyc3QgaW1hZ2VcIlxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPEltYWdlR2VuZXJhdGlvblJlc3BvbnNlPiAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYGRhdGFgOiBBcnJheSBvZiBtb2RpZmllZCBpbWFnZXMgd2l0aCBVUkxzXG4gICAqICAgLSBgY3JlYXRlZGA6IFRpbWVzdGFtcCBvZiBnZW5lcmF0aW9uXG4gICAqICAgLSBgbW9kZWxgOiBUaGUgbW9kZWwgdXNlZCBmb3IgZWRpdGluZ1xuICAgKi9cbiAgYXN5bmMgbW9kaWZ5SW1hZ2Uob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvbXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJQcm9tcHQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuaW1hZ2VzIHx8ICFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW1hZ2VzKSB8fCBvcHRpb25zLmltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkltYWdlcyBhcnJheSBpcyByZXF1aXJlZCBhbmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBpbWFnZSBVUkxcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5pbWFnZXMubGVuZ3RoID4gNTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIk1heGltdW0gNTAgaW1hZ2VzIGFsbG93ZWRcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlSW1hZ2VVcmwob3B0aW9ucy5pbWFnZXNbaV0pO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoYEltYWdlICR7aSArIDF9OiAke3ZhbGlkYXRpb24uZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpSW1hZ2UoXG4gICAgICAgIG9wdGlvbnMucHJvbXB0LFxuICAgICAgICAvLyBOb24tbnVsbCBhc3NlcnRpb24gc2luY2Ugd2UgdmFsaWRhdGVkIGFib3ZlXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBpbWFnZXM6IG9wdGlvbnMuaW1hZ2VzLFxuICAgICAgICAgIG46IG9wdGlvbnMubixcbiAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBsZXQgaW1hZ2VSZXNwb25zZTtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhPy5yZXN1bHQ/LmRhdGEpIHtcbiAgICAgICAgaW1hZ2VSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGEucmVzdWx0O1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5kYXRhPy5kYXRhKSB7XG4gICAgICAgIGltYWdlUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBtaXNzaW5nIGltYWdlIGRhdGFcIik7XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW1hZ2VSZXNwb25zZS5kYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6IGRhdGEgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xuICAgICAgfVxuICAgICAgaW1hZ2VSZXNwb25zZS5kYXRhID0gaW1hZ2VSZXNwb25zZS5kYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4geyB1cmw6IGl0ZW0gfTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnVybCkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJJbnZhbGlkIGltYWdlIHJlc3BvbnNlIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW1hZ2VSZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBSUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcbiAgICAgICAgYEltYWdlIG1vZGlmaWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB2aWRlb3MgZnJvbSB0ZXh0IHByb21wdHMgb3IgaW1hZ2VzIHVzaW5nIEFJIHZpZGVvIGdlbmVyYXRpb24gbW9kZWxzLlxuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgY29udGFpbmluZzpcbiAgICogICAtIGBwcm9tcHRgOiBUZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSB2aWRlbyB0byBnZW5lcmF0ZSAocmVxdWlyZWQpXG4gICAqICAgLSBgbW9kZWxgOiBWaWRlbyBtb2RlbCB0byB1c2UgKG9wdGlvbmFsKS4gQXZhaWxhYmxlIG1vZGVsczpcbiAgICogICAgICAgKipUZXh0LXRvLVZpZGVvIE1vZGVsczoqKlxuICAgKiAgICAgICAtIGBcImZhbC1haS92ZW8zLjFcImAgLSBHb29nbGUgVmVvIDMuMSAoYmVzdCBxdWFsaXR5KVxuICAgKiAgICAgICAtIGBcImZhbC1haS92ZW8zLjEvZmFzdFwiYCAoZGVmYXVsdCkgLSBWZW8gMy4xIGZhc3QgbW9kZSAoZmFzdGVyLCBjaGVhcGVyKVxuICAgKiAgICAgICAtIGBcImZhbC1haS9zb3JhLTIvdGV4dC10by12aWRlby9wcm9cImAgLSBPcGVuQUkgU29yYSAyXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL2tsaW5nLXZpZGVvL3YyLjYvcHJvL3RleHQtdG8tdmlkZW9cImAgLSBLbGluZyAyLjZcbiAgICogICAgICAgKipJbWFnZS10by1WaWRlbyBNb2RlbHM6KipcbiAgICogICAgICAgLSBgXCJmYWwtYWkvdmVvMy4xL2ltYWdlLXRvLXZpZGVvXCJgIC0gVmVvIDMuMSBJMlZcbiAgICogICAgICAgLSBgXCJmYWwtYWkvdmVvMy4xL2Zhc3QvaW1hZ2UtdG8tdmlkZW9cImAgLSBWZW8gMy4xIGZhc3QgSTJWXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL3NvcmEtMi9pbWFnZS10by12aWRlby9wcm9cImAgLSBTb3JhIDIgSTJWXG4gICAqICAgICAgIC0gYFwiZmFsLWFpL2tsaW5nLXZpZGVvL3YyLjYvcHJvL2ltYWdlLXRvLXZpZGVvXCJgIC0gS2xpbmcgMi42IEkyVlxuICAgKiAgIC0gYGltYWdlX3VybGA6IFNvdXJjZSBpbWFnZSBVUkwgZm9yIGltYWdlLXRvLXZpZGVvIChyZXF1aXJlZCBmb3IgSTJWIG1vZGVscylcbiAgICogICAtIGBkdXJhdGlvbmA6IFZpZGVvIGR1cmF0aW9uIChcIjRzXCIsIFwiNXNcIiwgXCI2c1wiLCBcIjhzXCIsIFwiMTBzXCIsIFwiMTJzXCIpXG4gICAqICAgLSBgYXNwZWN0X3JhdGlvYDogQXNwZWN0IHJhdGlvIChcIjE2OjlcIiwgXCI5OjE2XCIsIFwiMToxXCIpXG4gICAqICAgLSBgcmVzb2x1dGlvbmA6IFJlc29sdXRpb24gKFwiNzIwcFwiLCBcIjEwODBwXCIpIC0gVmVvL1NvcmEgb25seVxuICAgKiAgIC0gYG5lZ2F0aXZlX3Byb21wdGA6IFdoYXQgdG8gYXZvaWQgaW4gZ2VuZXJhdGlvbiAtIFZlby9LbGluZyBvbmx5XG4gICAqICAgLSBgZ2VuZXJhdGVfYXVkaW9gOiBHZW5lcmF0ZSBhdWRpbyB3aXRoIHZpZGVvIChkZWZhdWx0OiB0cnVlKVxuICAgKiAgIC0gYHNlZWRgOiBGb3IgcmVwcm9kdWNpYmlsaXR5IC0gVmVvIG9ubHlcbiAgICogICAtIGBjZmdfc2NhbGVgOiBHdWlkYW5jZSBzY2FsZSAoMC0xKSAtIEtsaW5nIG9ubHlcbiAgICogICAtIFBsdXMgb3B0aW9uYWwgc2lnbmFsIHBhcmFtZXRlclxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gQmFzaWMgdGV4dC10by12aWRlbyBnZW5lcmF0aW9uICh1c2VzIGRlZmF1bHQgZmFzdCBtb2RlbClcbiAgICogY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlVmlkZW8oe1xuICAgKiAgIHByb21wdDogXCJBIHNlcmVuZSBzdW5zZXQgb3ZlciB0aGUgb2NlYW4gd2l0aCBnZW50bGUgd2F2ZXNcIlxuICAgKiB9KTtcbiAgICogY29uc29sZS5sb2coXCJWaWRlbyBVUkw6XCIsIHJlc3VsdC52aWRlby51cmwpO1xuICAgKiBcbiAgICogLy8gSGlnaCBxdWFsaXR5IHdpdGggVmVvIDMuMVxuICAgKiBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVWaWRlbyh7XG4gICAqICAgcHJvbXB0OiBcIkEgY2luZW1hdGljIHNob3Qgb2YgYSBmdXR1cmlzdGljIGNpdHkgYXQgbmlnaHRcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkvdmVvMy4xXCIsXG4gICAqICAgcmVzb2x1dGlvbjogXCIxMDgwcFwiLFxuICAgKiAgIGFzcGVjdF9yYXRpbzogXCIxNjo5XCJcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBJbWFnZS10by12aWRlbyBhbmltYXRpb25cbiAgICogY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlVmlkZW8oe1xuICAgKiAgIHByb21wdDogXCJBbmltYXRlIHRoaXMgaW1hZ2Ugd2l0aCBnZW50bGUgY2FtZXJhIG1vdmVtZW50XCIsXG4gICAqICAgbW9kZWw6IFwiZmFsLWFpL3ZlbzMuMS9mYXN0L2ltYWdlLXRvLXZpZGVvXCIsXG4gICAqICAgaW1hZ2VfdXJsOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vbXktaW1hZ2UuanBnXCIsXG4gICAqICAgZHVyYXRpb246IFwiNXNcIlxuICAgKiB9KTtcbiAgICogXG4gICAqIC8vIFVzaW5nIFNvcmEgMiBmb3IgY3JlYXRpdmUgdmlkZW9zXG4gICAqIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVZpZGVvKHtcbiAgICogICBwcm9tcHQ6IFwiQSBtYWdpY2FsIGZvcmVzdCB3aXRoIGdsb3dpbmcgZmlyZWZsaWVzXCIsXG4gICAqICAgbW9kZWw6IFwiZmFsLWFpL3NvcmEtMi90ZXh0LXRvLXZpZGVvL3Byb1wiLFxuICAgKiAgIGR1cmF0aW9uOiBcIjhzXCJcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBVc2luZyBLbGluZyBmb3IgZGV0YWlsZWQgdmlkZW9zXG4gICAqIGNvbnN0IHsgcmVzdWx0LCB1c2FnZSB9ID0gYXdhaXQgYmxpbmsuYWkuZ2VuZXJhdGVWaWRlbyh7XG4gICAqICAgcHJvbXB0OiBcIkEgcHJvZmVzc2lvbmFsIGNvb2tpbmcgdHV0b3JpYWwgc2NlbmVcIixcbiAgICogICBtb2RlbDogXCJmYWwtYWkva2xpbmctdmlkZW8vdjIuNi9wcm8vdGV4dC10by12aWRlb1wiLFxuICAgKiAgIG5lZ2F0aXZlX3Byb21wdDogXCJibHVyLCBkaXN0b3J0LCBsb3cgcXVhbGl0eVwiLFxuICAgKiAgIGNmZ19zY2FsZTogMC43XG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhcIkNyZWRpdHMgY2hhcmdlZDpcIiwgdXNhZ2U/LmNyZWRpdHNDaGFyZ2VkKTtcbiAgICogYGBgXG4gICAqIFxuICAgKiBAcmV0dXJucyBQcm9taXNlPFZpZGVvR2VuZXJhdGlvblJlc3BvbnNlPiAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYHJlc3VsdC52aWRlby51cmxgOiBVUkwgdG8gdGhlIGdlbmVyYXRlZCB2aWRlb1xuICAgKiAgIC0gYHJlc3VsdC52aWRlby5jb250ZW50X3R5cGVgOiBNSU1FIHR5cGUgKHZpZGVvL21wNClcbiAgICogICAtIGByZXN1bHQudmlkZW8uZmlsZV9uYW1lYDogR2VuZXJhdGVkIGZpbGVuYW1lXG4gICAqICAgLSBgcmVzdWx0LnZpZGVvLmZpbGVfc2l6ZWA6IEZpbGUgc2l6ZSBpbiBieXRlc1xuICAgKiAgIC0gYG1ldGFkYXRhYDogR2VuZXJhdGlvbiBtZXRhZGF0YSAocHJvamVjdElkLCB0aW1lc3RhbXAsIG1vZGVsKVxuICAgKiAgIC0gYHVzYWdlYDogQ3JlZGl0cyBjaGFyZ2VkIGFuZCBjb3N0IGluZm9ybWF0aW9uXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVZpZGVvKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb21wdCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiUHJvbXB0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaTJ2TW9kZWxzID0gW1xuICAgICAgICBcImZhbC1haS92ZW8zLjEvaW1hZ2UtdG8tdmlkZW9cIixcbiAgICAgICAgXCJmYWwtYWkvdmVvMy4xL2Zhc3QvaW1hZ2UtdG8tdmlkZW9cIixcbiAgICAgICAgXCJmYWwtYWkvc29yYS0yL2ltYWdlLXRvLXZpZGVvL3Byb1wiLFxuICAgICAgICBcImZhbC1haS9rbGluZy12aWRlby92Mi42L3Byby9pbWFnZS10by12aWRlb1wiXG4gICAgICBdO1xuICAgICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgaTJ2TW9kZWxzLmluY2x1ZGVzKG9wdGlvbnMubW9kZWwpICYmICFvcHRpb25zLmltYWdlX3VybCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiaW1hZ2VfdXJsIGlzIHJlcXVpcmVkIGZvciBpbWFnZS10by12aWRlbyBtb2RlbHNcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5pbWFnZV91cmwpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVJbWFnZVVybChvcHRpb25zLmltYWdlX3VybCk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihgSW52YWxpZCBpbWFnZV91cmw6ICR7dmFsaWRhdGlvbi5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuYWlWaWRlbyhcbiAgICAgICAgb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBpbWFnZV91cmw6IG9wdGlvbnMuaW1hZ2VfdXJsLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGFzcGVjdF9yYXRpbzogb3B0aW9ucy5hc3BlY3RfcmF0aW8sXG4gICAgICAgICAgcmVzb2x1dGlvbjogb3B0aW9ucy5yZXNvbHV0aW9uLFxuICAgICAgICAgIG5lZ2F0aXZlX3Byb21wdDogb3B0aW9ucy5uZWdhdGl2ZV9wcm9tcHQsXG4gICAgICAgICAgZ2VuZXJhdGVfYXVkaW86IG9wdGlvbnMuZ2VuZXJhdGVfYXVkaW8sXG4gICAgICAgICAgc2VlZDogb3B0aW9ucy5zZWVkLFxuICAgICAgICAgIGNmZ19zY2FsZTogb3B0aW9ucy5jZmdfc2NhbGUsXG4gICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKCFyZXNwb25zZS5kYXRhPy5yZXN1bHQ/LnZpZGVvPy51cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBtaXNzaW5nIHZpZGVvIFVSTFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgVmlkZW8gZ2VuZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRleHQgdG8gc3BlZWNoIHVzaW5nIEFJIHZvaWNlIHN5bnRoZXNpcyBtb2RlbHMuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYHRleHRgOiBUZXh0IGNvbnRlbnQgdG8gY29udmVydCB0byBzcGVlY2ggKHJlcXVpcmVkKVxuICAgKiAgIC0gYHZvaWNlYDogVm9pY2UgdG8gdXNlIChcImFsbG95XCIsIFwiZWNob1wiLCBcImZhYmxlXCIsIFwib255eFwiLCBcIm5vdmFcIiwgXCJzaGltbWVyXCIpXG4gICAqICAgLSBgcmVzcG9uc2VfZm9ybWF0YDogQXVkaW8gZm9ybWF0IChcIm1wM1wiLCBcIm9wdXNcIiwgXCJhYWNcIiwgXCJmbGFjXCIsIFwid2F2XCIsIFwicGNtXCIpXG4gICAqICAgLSBgc3BlZWRgOiBTcGVlY2ggc3BlZWQgKDAuMjUgdG8gNC4wLCBkZWZhdWx0OiAxLjApXG4gICAqICAgLSBQbHVzIG9wdGlvbmFsIG1vZGVsLCBzaWduYWwgcGFyYW1ldGVyc1xuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gQmFzaWMgdGV4dC10by1zcGVlY2hcbiAgICogY29uc3QgeyB1cmwgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlU3BlZWNoKHtcbiAgICogICB0ZXh0OiBcIkhlbGxvLCB3ZWxjb21lIHRvIG91ciBBSS1wb3dlcmVkIGFwcGxpY2F0aW9uIVwiXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhcIkF1ZGlvIFVSTDpcIiwgdXJsKTtcbiAgICogXG4gICAqIC8vIEN1c3RvbSB2b2ljZSBhbmQgZm9ybWF0XG4gICAqIGNvbnN0IHsgdXJsLCB2b2ljZSwgZm9ybWF0IH0gPSBhd2FpdCBibGluay5haS5nZW5lcmF0ZVNwZWVjaCh7XG4gICAqICAgdGV4dDogXCJUaGlzIGlzIGEgZGVtb25zdHJhdGlvbiBvZiBvdXIgc3BlZWNoIHN5bnRoZXNpcyBjYXBhYmlsaXRpZXMuXCIsXG4gICAqICAgdm9pY2U6IFwibm92YVwiLFxuICAgKiAgIHJlc3BvbnNlX2Zvcm1hdDogXCJ3YXZcIixcbiAgICogICBzcGVlZDogMS4yXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhgR2VuZXJhdGVkICR7Zm9ybWF0fSBhdWRpbyB3aXRoICR7dm9pY2V9IHZvaWNlOmAsIHVybCk7XG4gICAqIFxuICAgKiAvLyBTbG93LCBjbGVhciBzcGVlY2ggZm9yIGFjY2Vzc2liaWxpdHlcbiAgICogY29uc3QgeyB1cmwgfSA9IGF3YWl0IGJsaW5rLmFpLmdlbmVyYXRlU3BlZWNoKHtcbiAgICogICB0ZXh0OiBcIlBsZWFzZSBsaXN0ZW4gY2FyZWZ1bGx5IHRvIHRoZXNlIGltcG9ydGFudCBpbnN0cnVjdGlvbnMuXCIsXG4gICAqICAgdm9pY2U6IFwiZWNob1wiLFxuICAgKiAgIHNwZWVkOiAwLjhcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBcbiAgICogQHJldHVybnMgUHJvbWlzZTxTcGVlY2hHZW5lcmF0aW9uUmVzcG9uc2U+IC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgdXJsYDogVVJMIHRvIHRoZSBnZW5lcmF0ZWQgYXVkaW8gZmlsZVxuICAgKiAgIC0gYHZvaWNlYDogVm9pY2UgdXNlZCBmb3IgZ2VuZXJhdGlvblxuICAgKiAgIC0gYGZvcm1hdGA6IEF1ZGlvIGZvcm1hdFxuICAgKiAgIC0gYG1pbWVUeXBlYDogTUlNRSB0eXBlIG9mIHRoZSBhdWRpb1xuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVTcGVlY2gob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiVGV4dCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmFpU3BlZWNoKFxuICAgICAgICBvcHRpb25zLnRleHQsXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICB2b2ljZTogb3B0aW9ucy52b2ljZSxcbiAgICAgICAgICByZXNwb25zZV9mb3JtYXQ6IG9wdGlvbnMucmVzcG9uc2VfZm9ybWF0LFxuICAgICAgICAgIHNwZWVkOiBvcHRpb25zLnNwZWVkLFxuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGxldCBzcGVlY2hSZXNwb25zZTtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhPy5yZXN1bHQpIHtcbiAgICAgICAgc3BlZWNoUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuZGF0YT8udXJsKSB7XG4gICAgICAgIHNwZWVjaFJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDogbWlzc2luZyBzcGVlY2ggZGF0YVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3BlZWNoUmVzcG9uc2UudXJsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHNwZWVjaFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdXJsOiByZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgdm9pY2U6IG9wdGlvbnMudm9pY2UgfHwgXCJhbGxveVwiLFxuICAgICAgICAgICAgZm9ybWF0OiBvcHRpb25zLnJlc3BvbnNlX2Zvcm1hdCB8fCBcIm1wM1wiLFxuICAgICAgICAgICAgbWltZVR5cGU6IHRoaXMuZ2V0TWltZVR5cGVGb3JGb3JtYXQob3B0aW9ucy5yZXNwb25zZV9mb3JtYXQgfHwgXCJtcDNcIilcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmRhdGE/LmRhdGEpIHtcbiAgICAgICAgICBzcGVlY2hSZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogcmVzcG9uc2UuZGF0YS5kYXRhLFxuICAgICAgICAgICAgdm9pY2U6IG9wdGlvbnMudm9pY2UgfHwgXCJhbGxveVwiLFxuICAgICAgICAgICAgZm9ybWF0OiBvcHRpb25zLnJlc3BvbnNlX2Zvcm1hdCB8fCBcIm1wM1wiLFxuICAgICAgICAgICAgbWltZVR5cGU6IHRoaXMuZ2V0TWltZVR5cGVGb3JGb3JtYXQob3B0aW9ucy5yZXNwb25zZV9mb3JtYXQgfHwgXCJtcDNcIilcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDogbm8gYXVkaW8gVVJMIGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNwZWVjaFJlc3BvbnNlLnZvaWNlKSB7XG4gICAgICAgIHNwZWVjaFJlc3BvbnNlLnZvaWNlID0gb3B0aW9ucy52b2ljZSB8fCBcImFsbG95XCI7XG4gICAgICB9XG4gICAgICBpZiAoIXNwZWVjaFJlc3BvbnNlLmZvcm1hdCkge1xuICAgICAgICBzcGVlY2hSZXNwb25zZS5mb3JtYXQgPSBvcHRpb25zLnJlc3BvbnNlX2Zvcm1hdCB8fCBcIm1wM1wiO1xuICAgICAgfVxuICAgICAgaWYgKCFzcGVlY2hSZXNwb25zZS5taW1lVHlwZSkge1xuICAgICAgICBzcGVlY2hSZXNwb25zZS5taW1lVHlwZSA9IHRoaXMuZ2V0TWltZVR5cGVGb3JGb3JtYXQoc3BlZWNoUmVzcG9uc2UuZm9ybWF0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGVlY2hSZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBSUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcbiAgICAgICAgYFNwZWVjaCBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJhbnNjcmliZXMgYXVkaW8gY29udGVudCB0byB0ZXh0IHVzaW5nIEFJIHNwZWVjaCByZWNvZ25pdGlvbiBtb2RlbHMuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCBjb250YWluaW5nOlxuICAgKiAgIC0gYGF1ZGlvYDogQXVkaW8gaW5wdXQgYXMgVVJMIHN0cmluZywgYmFzZTY0IHN0cmluZywgb3IgbnVtYmVyIGFycmF5IGJ1ZmZlciAocmVxdWlyZWQpXG4gICAqICAgLSBgbGFuZ3VhZ2VgOiBMYW5ndWFnZSBjb2RlIGZvciB0cmFuc2NyaXB0aW9uIChlLmcuLCBcImVuXCIsIFwiZXNcIiwgXCJmclwiKVxuICAgKiAgIC0gYHJlc3BvbnNlX2Zvcm1hdGA6IE91dHB1dCBmb3JtYXQgKFwianNvblwiLCBcInRleHRcIiwgXCJzcnRcIiwgXCJ2ZXJib3NlX2pzb25cIiwgXCJ2dHRcIilcbiAgICogICAtIFBsdXMgb3B0aW9uYWwgbW9kZWwsIHNpZ25hbCBwYXJhbWV0ZXJzXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBUcmFuc2NyaWJlIGZyb20gVVJMXG4gICAqIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgYmxpbmsuYWkudHJhbnNjcmliZUF1ZGlvKHtcbiAgICogICBhdWRpbzogXCJodHRwczovL2V4YW1wbGUuY29tL21lZXRpbmctcmVjb3JkaW5nLm1wM1wiXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhcIlRyYW5zY3JpcHRpb246XCIsIHRleHQpO1xuICAgKiBcbiAgICogLy8gVHJhbnNjcmliZSB3aXRoIGxhbmd1YWdlIGhpbnRcbiAgICogY29uc3QgeyB0ZXh0LCBsYW5ndWFnZSB9ID0gYXdhaXQgYmxpbmsuYWkudHJhbnNjcmliZUF1ZGlvKHtcbiAgICogICBhdWRpbzogXCJodHRwczovL2V4YW1wbGUuY29tL3NwYW5pc2gtYXVkaW8ud2F2XCIsXG4gICAqICAgbGFuZ3VhZ2U6IFwiZXNcIlxuICAgKiB9KTtcbiAgICogY29uc29sZS5sb2coYFRyYW5zY3JpYmVkICR7bGFuZ3VhZ2V9OmAsIHRleHQpO1xuICAgKiBcbiAgICogLy8gVHJhbnNjcmliZSB3aXRoIHRpbWVzdGFtcHMgKHZlcmJvc2UgZm9ybWF0KVxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBibGluay5haS50cmFuc2NyaWJlQXVkaW8oe1xuICAgKiAgIGF1ZGlvOiBhdWRpb0ZpbGVVcmwsXG4gICAqICAgcmVzcG9uc2VfZm9ybWF0OiBcInZlcmJvc2VfanNvblwiXG4gICAqIH0pO1xuICAgKiByZXN1bHQuc2VnbWVudHM/LmZvckVhY2goc2VnbWVudCA9PiB7XG4gICAqICAgY29uc29sZS5sb2coYCR7c2VnbWVudC5zdGFydH1zIC0gJHtzZWdtZW50LmVuZH1zOiAke3NlZ21lbnQudGV4dH1gKTtcbiAgICogfSk7XG4gICAqIFxuICAgKiAvLyBUcmFuc2NyaWJlIGZyb20gYXVkaW8gYnVmZmVyXG4gICAqIGNvbnN0IGF1ZGlvQnVmZmVyID0gbmV3IEFycmF5KDEwMjQpLmZpbGwoMCk7IC8vIFlvdXIgYXVkaW8gZGF0YVxuICAgKiBjb25zdCB7IHRleHQgfSA9IGF3YWl0IGJsaW5rLmFpLnRyYW5zY3JpYmVBdWRpbyh7XG4gICAqICAgYXVkaW86IGF1ZGlvQnVmZmVyLFxuICAgKiAgIGxhbmd1YWdlOiBcImVuXCJcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBcbiAgICogQHJldHVybnMgUHJvbWlzZTxUcmFuc2NyaXB0aW9uUmVzcG9uc2U+IC0gT2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgLSBgdGV4dGA6IFRyYW5zY3JpYmVkIHRleHQgY29udGVudFxuICAgKiAgIC0gYHRyYW5zY3JpcHRgOiBBbGlhcyBmb3IgdGV4dFxuICAgKiAgIC0gYHNlZ21lbnRzYDogQXJyYXkgb2YgdGltZXN0YW1wZWQgc2VnbWVudHMgKGlmIHZlcmJvc2UgZm9ybWF0KVxuICAgKiAgIC0gYGxhbmd1YWdlYDogRGV0ZWN0ZWQgbGFuZ3VhZ2VcbiAgICogICAtIGBkdXJhdGlvbmA6IEF1ZGlvIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIGFzeW5jIHRyYW5zY3JpYmVBdWRpbyhvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy5hdWRpbykge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiQXVkaW8gaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5haVRyYW5zY3JpYmUoXG4gICAgICAgIG9wdGlvbnMuYXVkaW8sXG4gICAgICAgIHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSxcbiAgICAgICAgICByZXNwb25zZV9mb3JtYXQ6IG9wdGlvbnMucmVzcG9uc2VfZm9ybWF0LFxuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhPy5yZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEucmVzdWx0O1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5kYXRhPy50ZXh0IHx8IHJlc3BvbnNlLmRhdGE/LnRyYW5zY3JpcHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0ZXh0OiByZXNwb25zZS5kYXRhLnRleHQgfHwgcmVzcG9uc2UuZGF0YS50cmFuc2NyaXB0LFxuICAgICAgICAgIHRyYW5zY3JpcHQ6IHJlc3BvbnNlLmRhdGEudHJhbnNjcmlwdCB8fCByZXNwb25zZS5kYXRhLnRleHQsXG4gICAgICAgICAgLi4ucmVzcG9uc2UuZGF0YVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiBtaXNzaW5nIHRyYW5zY3JpcHRpb24gdGV4dFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQmxpbmtBSUVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcbiAgICAgICAgYEF1ZGlvIHRyYW5zY3JpcHRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFnZW50KG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLmFnZW50Py5tb2RlbCkge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFwiYWdlbnQubW9kZWwgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMucHJvbXB0ICYmICFvcHRpb25zLm1lc3NhZ2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua0FJRXJyb3IoXCJFaXRoZXIgcHJvbXB0IG9yIG1lc3NhZ2VzIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucHJvbXB0ICYmIG9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsaW5rQUlFcnJvcihcInByb21wdCBhbmQgbWVzc2FnZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUb29scyA9IG9wdGlvbnMuYWdlbnQudG9vbHMgPyBzZXJpYWxpemVUb29scyhvcHRpb25zLmFnZW50LnRvb2xzKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICBzdHJlYW06IG9wdGlvbnMuc3RyZWFtLFxuICAgICAgICBhZ2VudDoge1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLmFnZW50Lm1vZGVsLFxuICAgICAgICAgIHN5c3RlbTogb3B0aW9ucy5hZ2VudC5zeXN0ZW0sXG4gICAgICAgICAgdG9vbHM6IHNlcmlhbGl6ZWRUb29scyxcbiAgICAgICAgICB3ZWJob29rX3Rvb2xzOiBvcHRpb25zLmFnZW50LndlYmhvb2tfdG9vbHMsXG4gICAgICAgICAgY2xpZW50X3Rvb2xzOiBvcHRpb25zLmFnZW50LmNsaWVudF90b29scyxcbiAgICAgICAgICB0b29sX2Nob2ljZTogb3B0aW9ucy5hZ2VudC50b29sX2Nob2ljZSxcbiAgICAgICAgICBzdG9wX3doZW46IG9wdGlvbnMuYWdlbnQuc3RvcF93aGVuLFxuICAgICAgICAgIHByZXBhcmVfc3RlcDogb3B0aW9ucy5hZ2VudC5wcmVwYXJlX3N0ZXBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLnByb21wdCkge1xuICAgICAgICByZXF1ZXN0Qm9keS5wcm9tcHQgPSBvcHRpb25zLnByb21wdDtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlcykge1xuICAgICAgICByZXF1ZXN0Qm9keS5tZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXM7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaHR0cENsaWVudC5haUFnZW50U3RyZWFtKHJlcXVlc3RCb2R5LCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5haUFnZW50KHJlcXVlc3RCb2R5LCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCbGlua0FJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQmxpbmtBSUVycm9yKFxuICAgICAgICBgQWdlbnQgcmVxdWVzdCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBBZ2VudCBGYWN0b3J5XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXVzYWJsZSBBZ2VudCBpbnN0YW5jZSB3aXRoIHRoZSBWZXJjZWwgQUkgU0RLIHBhdHRlcm4uXG4gICAqIFxuICAgKiBUaGUgQWdlbnQgY2FuIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgcHJvbXB0czpcbiAgICogLSBgYWdlbnQuZ2VuZXJhdGUoeyBwcm9tcHQgfSlgIGZvciBub24tc3RyZWFtaW5nXG4gICAqIC0gYGFnZW50LnN0cmVhbSh7IHByb21wdCB9KWAgZm9yIHN0cmVhbWluZ1xuICAgKiBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZ2VudCBjb25maWd1cmF0aW9uIChtb2RlbCwgdG9vbHMsIHN5c3RlbSwgZXRjLilcbiAgICogQHJldHVybnMgQWdlbnQgaW5zdGFuY2VcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHdlYXRoZXJBZ2VudCA9IGJsaW5rLmFpLmNyZWF0ZUFnZW50KHtcbiAgICogICBtb2RlbDogJ2FudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTQnLFxuICAgKiAgIHN5c3RlbTogJ1lvdSBhcmUgYSBoZWxwZnVsIHdlYXRoZXIgYXNzaXN0YW50LicsXG4gICAqICAgdG9vbHM6IFt3ZWJTZWFyY2gsIGZldGNoVXJsXSxcbiAgICogICBtYXhTdGVwczogMTAsXG4gICAqIH0pXG4gICAqIFxuICAgKiAvLyBOb24tc3RyZWFtaW5nXG4gICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdlYXRoZXJBZ2VudC5nZW5lcmF0ZSh7XG4gICAqICAgcHJvbXB0OiAnV2hhdCBpcyB0aGUgd2VhdGhlciBpbiBTYW4gRnJhbmNpc2NvPycsXG4gICAqIH0pXG4gICAqIFxuICAgKiAvLyBTdHJlYW1pbmdcbiAgICogY29uc3Qgc3RyZWFtID0gYXdhaXQgd2VhdGhlckFnZW50LnN0cmVhbSh7XG4gICAqICAgcHJvbXB0OiAnVGVsbCBtZSBhYm91dCB3ZWF0aGVyIHBhdHRlcm5zJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBjcmVhdGVBZ2VudChvcHRpb25zKSB7XG4gICAgY29uc3QgYWdlbnQgPSBuZXcgQWdlbnQob3B0aW9ucyk7XG4gICAgYWdlbnQuX3NldEh0dHBDbGllbnQodGhpcy5odHRwQ2xpZW50KTtcbiAgICByZXR1cm4gYWdlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGFuIGV4aXN0aW5nIEFnZW50IGluc3RhbmNlIHRvIHRoaXMgY2xpZW50J3MgSFRUUCBjbGllbnQuXG4gICAqIFxuICAgKiBVc2VkIGludGVybmFsbHkgYnkgdXNlQWdlbnQoKSB3aGVuIGFuIEFnZW50IGluc3RhbmNlIGlzIHBhc3NlZC5cbiAgICogVGhpcyBhbGxvd3MgYWdlbnRzIGNyZWF0ZWQgd2l0aCBgbmV3IEFnZW50KClgIHRvIGJlIHVzZWQgd2l0aCB0aGUgaG9vay5cbiAgICogXG4gICAqIEBwYXJhbSBhZ2VudCAtIEV4aXN0aW5nIEFnZW50IGluc3RhbmNlXG4gICAqIEByZXR1cm5zIFRoZSBzYW1lIEFnZW50IGluc3RhbmNlICh3aXRoIGh0dHBDbGllbnQgc2V0KVxuICAgKi9cbiAgYmluZEFnZW50KGFnZW50KSB7XG4gICAgYWdlbnQuX3NldEh0dHBDbGllbnQodGhpcy5odHRwQ2xpZW50KTtcbiAgICByZXR1cm4gYWdlbnQ7XG4gIH1cbn07XG5cbi8vIHNyYy9kYXRhLnRzXG52YXIgQmxpbmtEYXRhSW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaHR0cENsaWVudCwgcHJvamVjdElkKSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDtcbiAgfVxuICBhc3luYyBleHRyYWN0RnJvbVVybCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2h1bmtpbmcgPSBmYWxzZSwgY2h1bmtTaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7IHVybCwgY2h1bmtpbmcsIGNodW5rU2l6ZSB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRhdGFFeHRyYWN0RnJvbVVybCh0aGlzLnByb2plY3RJZCwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIGNodW5raW5nID8gcmVzcG9uc2UuZGF0YS5jaHVua3MgOiByZXNwb25zZS5kYXRhLnRleHQ7XG4gIH1cbiAgYXN5bmMgZXh0cmFjdEZyb21CbG9iKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2h1bmtpbmcgPSBmYWxzZSwgY2h1bmtTaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRhdGFFeHRyYWN0RnJvbUJsb2IodGhpcy5wcm9qZWN0SWQsIGZpbGUsIGNodW5raW5nLCBjaHVua1NpemUpO1xuICAgIHJldHVybiBjaHVua2luZyA/IHJlc3BvbnNlLmRhdGEuY2h1bmtzIDogcmVzcG9uc2UuZGF0YS50ZXh0O1xuICB9XG4gIGFzeW5jIHNjcmFwZSh1cmwpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgdXJsLFxuICAgICAgZm9ybWF0czogW1wibWFya2Rvd25cIiwgXCJodG1sXCIsIFwibGlua3NcIiwgXCJleHRyYWN0XCIsIFwibWV0YWRhdGFcIl1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRhdGFTY3JhcGUodGhpcy5wcm9qZWN0SWQsIHJlcXVlc3QpO1xuICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjogZGF0YS5tYXJrZG93biB8fCBcIlwiLFxuICAgICAgaHRtbDogZGF0YS5odG1sIHx8IFwiXCIsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICB0aXRsZTogZGF0YS5tZXRhZGF0YT8udGl0bGUgfHwgXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGRhdGEubWV0YWRhdGE/LmRlc2NyaXB0aW9uIHx8IFwiXCIsXG4gICAgICAgIHVybDogZGF0YS5tZXRhZGF0YT8udXJsIHx8IHVybCxcbiAgICAgICAgZG9tYWluOiBkYXRhLm1ldGFkYXRhPy5kb21haW4gfHwgbmV3IFVSTCh1cmwpLmhvc3RuYW1lLFxuICAgICAgICBmYXZpY29uOiBkYXRhLm1ldGFkYXRhPy5mYXZpY29uLFxuICAgICAgICBpbWFnZTogZGF0YS5tZXRhZGF0YT8uaW1hZ2UsXG4gICAgICAgIGF1dGhvcjogZGF0YS5tZXRhZGF0YT8uYXV0aG9yLFxuICAgICAgICBwdWJsaXNoZWRUaW1lOiBkYXRhLm1ldGFkYXRhPy5wdWJsaXNoZWRUaW1lLFxuICAgICAgICBtb2RpZmllZFRpbWU6IGRhdGEubWV0YWRhdGE/Lm1vZGlmaWVkVGltZSxcbiAgICAgICAgdHlwZTogZGF0YS5tZXRhZGF0YT8udHlwZSxcbiAgICAgICAgc2l0ZU5hbWU6IGRhdGEubWV0YWRhdGE/LnNpdGVOYW1lLFxuICAgICAgICBsb2NhbGU6IGRhdGEubWV0YWRhdGE/LmxvY2FsZSxcbiAgICAgICAga2V5d29yZHM6IGRhdGEubWV0YWRhdGE/LmtleXdvcmRzIHx8IFtdXG4gICAgICB9LFxuICAgICAgbGlua3M6IGRhdGEubGlua3MgfHwgW10sXG4gICAgICBleHRyYWN0OiB7XG4gICAgICAgIHRpdGxlOiBkYXRhLmV4dHJhY3Q/LnRpdGxlIHx8IGRhdGEubWV0YWRhdGE/LnRpdGxlIHx8IFwiXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhLmV4dHJhY3Q/LmRlc2NyaXB0aW9uIHx8IGRhdGEubWV0YWRhdGE/LmRlc2NyaXB0aW9uIHx8IFwiXCIsXG4gICAgICAgIGhlYWRpbmdzOiBkYXRhLmV4dHJhY3Q/LmhlYWRpbmdzIHx8IFtdLFxuICAgICAgICB0ZXh0OiBkYXRhLmV4dHJhY3Q/LnRleHQgfHwgZGF0YS5tYXJrZG93biB8fCBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBzY3JlZW5zaG90KHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHsgdXJsLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGF0YVNjcmVlbnNob3QodGhpcy5wcm9qZWN0SWQsIHJlcXVlc3QpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLnVybDtcbiAgfVxuICBhc3luYyBmZXRjaChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGF0YUZldGNoKHRoaXMucHJvamVjdElkLCByZXF1ZXN0KTtcbiAgICBpZiAoXCJzdGF0dXNcIiBpbiByZXNwb25zZS5kYXRhICYmIFwiaGVhZGVyc1wiIGluIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQmxpbmtEYXRhRXJyb3IoXCJVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIGZldGNoIGVuZHBvaW50XCIpO1xuICB9XG4gIGFzeW5jIGZldGNoQXN5bmMocmVxdWVzdCkge1xuICAgIGNvbnN0IGFzeW5jUmVxdWVzdCA9IHsgLi4ucmVxdWVzdCwgYXN5bmM6IHRydWUgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5kYXRhRmV0Y2godGhpcy5wcm9qZWN0SWQsIGFzeW5jUmVxdWVzdCk7XG4gICAgaWYgKFwic3RhdHVzXCIgaW4gcmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnN0YXR1cyA9PT0gXCJ0cmlnZ2VyZWRcIikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIHRocm93IG5ldyBCbGlua0RhdGFFcnJvcihcIlVuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gYXN5bmMgZmV0Y2ggZW5kcG9pbnRcIik7XG4gIH1cbiAgYXN5bmMgc2VhcmNoKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplVHlwZSA9ICh0eXBlKSA9PiB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5ld3NcIjpcbiAgICAgICAgICByZXR1cm4gXCJud3NcIjtcbiAgICAgICAgY2FzZSBcImltYWdlc1wiOlxuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICByZXR1cm4gXCJpc2NoXCI7XG4gICAgICAgIGNhc2UgXCJ2aWRlb3NcIjpcbiAgICAgICAgY2FzZSBcInZpZGVvXCI6XG4gICAgICAgICAgcmV0dXJuIFwidmlkXCI7XG4gICAgICAgIGNhc2UgXCJzaG9wcGluZ1wiOlxuICAgICAgICBjYXNlIFwic2hvcFwiOlxuICAgICAgICAgIHJldHVybiBcInNob3BcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIHE6IHF1ZXJ5LFxuICAgICAgbG9jYXRpb246IG9wdGlvbnM/LmxvY2F0aW9uLFxuICAgICAgaGw6IG9wdGlvbnM/Lmxhbmd1YWdlIHx8IFwiZW5cIixcbiAgICAgIHRibTogbm9ybWFsaXplVHlwZShvcHRpb25zPy50eXBlKSxcbiAgICAgIG51bTogb3B0aW9ucz8ubGltaXRcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmRhdGFTZWFyY2godGhpcy5wcm9qZWN0SWQsIHJlcXVlc3QpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG59O1xuXG4vLyBzcmMvcmVhbHRpbWUtY29ubmVjdGlvbi50c1xudmFyIGdldFdlYlNvY2tldENsYXNzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBXZWJTb2NrZXQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBXUyA9IF9fcmVxdWlyZShcIndzXCIpO1xuICAgIHJldHVybiBXUztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQmxpbmtSZWFsdGltZUVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGF2YWlsYWJsZS4gSW5zdGFsbCBcIndzXCIgcGFja2FnZSBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudHMuJyk7XG4gIH1cbn07XG52YXIgUmVhbHRpbWVDb25uZWN0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCBwcm9qZWN0SWQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkO1xuICB9XG4gIHdlYnNvY2tldCA9IG51bGw7XG4gIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIGlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICByZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gIGhlYXJ0YmVhdFRpbWVyID0gbnVsbDtcbiAgcmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICBjb25uZWN0aW9uUHJvbWlzZSA9IG51bGw7XG4gIC8vIENoYW5uZWwgbWFuYWdlbWVudFxuICBjaGFubmVscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHBlbmRpbmdTdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gTWVzc2FnZSBxdWV1ZSBmb3Igd2hlbiBzb2NrZXQgbm90IHJlYWR5XG4gIG1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAvKipcbiAgICogQ2hlY2sgaWYgY29ubmVjdGlvbiBpcyByZWFkeVxuICAgKi9cbiAgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZCAmJiB0aGlzLndlYnNvY2tldD8ucmVhZHlTdGF0ZSA9PT0gMTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXG4gICAqL1xuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkICYmIHRoaXMud2Vic29ja2V0Py5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuY29ubmVjdFdlYlNvY2tldCgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEpvaW4gYSBjaGFubmVsIChzdWJzY3JpYmUpXG4gICAqL1xuICBhc3luYyBqb2luQ2hhbm5lbChjaGFubmVsTmFtZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgdGhpcy5jaGFubmVscy5zZXQoY2hhbm5lbE5hbWUsIHsgaGFuZGxlciwgb3B0aW9ucyB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShjaGFubmVsTmFtZSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMuZGVsZXRlKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgcmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJTdWJzY3JpcHRpb24gdGltZW91dCAtIG5vIGFja25vd2xlZGdtZW50IGZyb20gc2VydmVyXCIpKTtcbiAgICAgIH0sIDFlNCk7XG4gICAgICB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25zLnNldChjaGFubmVsTmFtZSwgeyByZXNvbHZlLCByZWplY3QsIHRpbWVvdXQgfSk7XG4gICAgICBjb25zdCBzdWJzY3JpYmVNZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiBcInN1YnNjcmliZVwiLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgY2hhbm5lbDogY2hhbm5lbE5hbWUsXG4gICAgICAgICAgdXNlcklkOiBvcHRpb25zLnVzZXJJZCxcbiAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZW5kUmF3KEpTT04uc3RyaW5naWZ5KHN1YnNjcmliZU1lc3NhZ2UpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5kZWxldGUoY2hhbm5lbE5hbWUpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmRlbGV0ZShjaGFubmVsTmFtZSk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIExlYXZlIGEgY2hhbm5lbCAodW5zdWJzY3JpYmUpXG4gICAqL1xuICBhc3luYyBsZWF2ZUNoYW5uZWwoY2hhbm5lbE5hbWUpIHtcbiAgICB0aGlzLmNoYW5uZWxzLmRlbGV0ZShjaGFubmVsTmFtZSk7XG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuZ2V0KGNoYW5uZWxOYW1lKTtcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmcudGltZW91dCk7XG4gICAgICBwZW5kaW5nLnJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiU3Vic2NyaXB0aW9uIGNhbmNlbGxlZFwiKSk7XG4gICAgICB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShjaGFubmVsTmFtZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLndlYnNvY2tldCAmJiB0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZU1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6IFwidW5zdWJzY3JpYmVcIixcbiAgICAgICAgcGF5bG9hZDogeyBjaGFubmVsOiBjaGFubmVsTmFtZSB9XG4gICAgICB9O1xuICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh1bnN1YnNjcmliZU1lc3NhZ2UpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hhbm5lbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0byBhIGNoYW5uZWxcbiAgICovXG4gIGFzeW5jIHNlbmQoY2hhbm5lbE5hbWUsIHR5cGUsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgIGNvbnN0IHB1Ymxpc2hNZXNzYWdlID0ge1xuICAgICAgdHlwZTogXCJwdWJsaXNoXCIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGNoYW5uZWw6IGNoYW5uZWxOYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhLFxuICAgICAgICB1c2VySWQ6IG9wdGlvbnMudXNlcklkLFxuICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuc2VuZFdpdGhSZXNwb25zZShKU09OLnN0cmluZ2lmeShwdWJsaXNoTWVzc2FnZSksIGNoYW5uZWxOYW1lKTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdCBhbmQgY2xlYW51cFxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5oZWFydGJlYXRUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZVF1ZXVlLmZvckVhY2goKHEpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChxLnRpbWVvdXQpO1xuICAgICAgcS5yZWplY3QobmV3IEJsaW5rUmVhbHRpbWVFcnJvcihcIkNvbm5lY3Rpb24gY2xvc2VkXCIpKTtcbiAgICB9KTtcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgIHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuZm9yRWFjaCgocGVuZGluZywgY2hhbm5lbCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmcudGltZW91dCk7XG4gICAgICBwZW5kaW5nLnJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiQ29ubmVjdGlvbiBjbG9zZWRcIikpO1xuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy53ZWJzb2NrZXQpIHtcbiAgICAgIHRoaXMud2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICB0aGlzLndlYnNvY2tldCA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgY291bnQgb2YgYWN0aXZlIGNoYW5uZWxzXG4gICAqL1xuICBnZXRDaGFubmVsQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHMuc2l6ZTtcbiAgfVxuICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgYXN5bmMgY29ubmVjdFdlYlNvY2tldCgpIHtcbiAgICBpZiAodGhpcy53ZWJzb2NrZXQgJiYgdGhpcy53ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc0Nvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiQ29ubmVjdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrQ29ubmVjdGlvbiwgMTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ29ubmVjdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuaXNDb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGh0dHBDbGllbnQgPSB0aGlzLmh0dHBDbGllbnQ7XG4gICAgICAgIGNvbnN0IGNvcmVVcmwgPSBodHRwQ2xpZW50LmNvcmVVcmwgfHwgXCJodHRwczovL2NvcmUuYmxpbmsubmV3XCI7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBjb3JlVXJsLnJlcGxhY2UoXCJodHRwczovL1wiLCBcIndzczovL1wiKS5yZXBsYWNlKFwiaHR0cDovL1wiLCBcIndzOi8vXCIpO1xuICAgICAgICBjb25zdCB3c1VybCA9IGAke2Jhc2VVcmx9P3Byb2plY3RfaWQ9JHt0aGlzLnByb2plY3RJZH1gO1xuICAgICAgICBjb25zb2xlLmxvZyhgXFx1ezFGNTE3fSBDb25uZWN0aW5nIHRvIHJlYWx0aW1lOiAke3dzVXJsfWApO1xuICAgICAgICBjb25zdCBXU0NsYXNzID0gZ2V0V2ViU29ja2V0Q2xhc3MoKTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQgPSBuZXcgV1NDbGFzcyh3c1VybCk7XG4gICAgICAgIGlmICghdGhpcy53ZWJzb2NrZXQpIHtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBXZWJTb2NrZXQgaW5zdGFuY2VcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFxcdXsxRjUxN30gQ29ubmVjdGVkIHRvIHJlYWx0aW1lIGZvciBwcm9qZWN0ICR7dGhpcy5wcm9qZWN0SWR9YCk7XG4gICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XG4gICAgICAgICAgdGhpcy5mbHVzaE1lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIFdlYlNvY2tldCBtZXNzYWdlOlwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndlYnNvY2tldC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBcXHV7MUY1MEN9IERpc2Nvbm5lY3RlZCBmcm9tIHJlYWx0aW1lIGZvciBwcm9qZWN0ICR7dGhpcy5wcm9qZWN0SWR9YCk7XG4gICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5yZWplY3RRdWV1ZWRNZXNzYWdlcyhuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkXCIpKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2ViU29ja2V0IGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgcmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoYFdlYlNvY2tldCBjb25uZWN0aW9uIGZhaWxlZCB0byAke3dzVXJsfWApKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMud2Vic29ja2V0Py5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJXZWJTb2NrZXQgY29ubmVjdGlvbiB0aW1lb3V0XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDFlNCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICByZWplY3QobmV3IEJsaW5rUmVhbHRpbWVFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBXZWJTb2NrZXQgY29ubmVjdGlvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IG1lc3NhZ2UucGF5bG9hZD8uY2hhbm5lbDtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgICBjb25zb2xlLmxvZyhgXFx1MjcwNSBXZWJTb2NrZXQgY29ubmVjdGVkOiAke21lc3NhZ2UucGF5bG9hZD8uc29ja2V0SWR9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN1YnNjcmliZWRcIjpcbiAgICAgICAgY29uc29sZS5sb2coYFxcdTI3MDUgU3Vic2NyaWJlZCB0byBjaGFubmVsOiAke2NoYW5uZWxOYW1lfWApO1xuICAgICAgICBjb25zdCBwZW5kaW5nU3ViID0gdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgICAgICBpZiAocGVuZGluZ1N1Yikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nU3ViLnRpbWVvdXQpO1xuICAgICAgICAgIHBlbmRpbmdTdWIucmVzb2x2ZSgpO1xuICAgICAgICAgIHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuZGVsZXRlKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJIYW5kbGVyID0gdGhpcy5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xuICAgICAgICBpZiAoc3ViSGFuZGxlcikge1xuICAgICAgICAgIHN1YkhhbmRsZXIuaGFuZGxlci5vblN1YnNjcmliZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNvbnN0IG1zZ0NoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmdldChtZXNzYWdlLnBheWxvYWQ/LmNoYW5uZWwpO1xuICAgICAgICBpZiAobXNnQ2hhbm5lbCkge1xuICAgICAgICAgIG1zZ0NoYW5uZWwuaGFuZGxlci5vbk1lc3NhZ2UobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmVzZW5jZVwiOlxuICAgICAgICBjb25zdCBwcmVzQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZ2V0KG1lc3NhZ2UucGF5bG9hZD8uY2hhbm5lbCk7XG4gICAgICAgIGlmIChwcmVzQ2hhbm5lbCkge1xuICAgICAgICAgIGNvbnN0IHVzZXJzID0gbWVzc2FnZS5wYXlsb2FkPy5kYXRhPy51c2VycyB8fCBbXTtcbiAgICAgICAgICBwcmVzQ2hhbm5lbC5oYW5kbGVyLm9uUHJlc2VuY2UodXNlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInB1Ymxpc2hlZFwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb25nXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFsdGltZSBlcnJvcjpcIiwgbWVzc2FnZS5wYXlsb2FkPy5lcnJvcik7XG4gICAgICAgIGNvbnN0IGVyckNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIGlmIChlcnJDaGFubmVsKSB7XG4gICAgICAgICAgZXJyQ2hhbm5lbC5oYW5kbGVyLm9uRXJyb3IobWVzc2FnZS5wYXlsb2FkPy5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVuZGluZ0VyciA9IHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbnMuZ2V0KGNoYW5uZWxOYW1lKTtcbiAgICAgICAgaWYgKHBlbmRpbmdFcnIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocGVuZGluZ0Vyci50aW1lb3V0KTtcbiAgICAgICAgICBwZW5kaW5nRXJyLnJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKGBTdWJzY3JpcHRpb24gZXJyb3I6ICR7bWVzc2FnZS5wYXlsb2FkPy5lcnJvcn1gKSk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9ucy5kZWxldGUoY2hhbm5lbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInVuc3Vic2NyaWJlZFwiOlxuICAgICAgICBjb25zb2xlLmxvZyhgXFx1Mjc0QyBVbnN1YnNjcmliZWQgZnJvbSBjaGFubmVsOiAke2NoYW5uZWxOYW1lfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBtZXNzYWdlIHR5cGU6XCIsIG1lc3NhZ2UudHlwZSk7XG4gICAgfVxuICB9XG4gIHNlbmRSYXcobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLndlYnNvY2tldCAmJiB0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICB0aGlzLndlYnNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiQ2Fubm90IHNlbmQgbWVzc2FnZTogV2ViU29ja2V0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICB9XG4gIHNlbmRXaXRoUmVzcG9uc2UobWVzc2FnZSwgY2hhbm5lbE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZVF1ZXVlLmZpbmRJbmRleCgocSkgPT4gcS5yZXNvbHZlID09PSByZXNvbHZlKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChuZXcgQmxpbmtSZWFsdGltZUVycm9yKFwiTWVzc2FnZSBzZW5kIHRpbWVvdXQgLSBubyByZXNwb25zZSBmcm9tIHNlcnZlclwiKSk7XG4gICAgICB9LCAxZTQpO1xuICAgICAgaWYgKHRoaXMud2Vic29ja2V0ICYmIHRoaXMud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09IFwicHVibGlzaGVkXCIgJiYgcmVzcG9uc2UucGF5bG9hZC5jaGFubmVsID09PSBjaGFubmVsTmFtZSkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5wYXlsb2FkLm1lc3NhZ2VJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5wYXlsb2FkLmVycm9yfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZVJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2goeyBtZXNzYWdlLCByZXNvbHZlLCByZWplY3QsIHRpbWVvdXQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmx1c2hNZXNzYWdlUXVldWUoKSB7XG4gICAgaWYgKCF0aGlzLndlYnNvY2tldCB8fCB0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSByZXR1cm47XG4gICAgY29uc3QgcXVldWUgPSBbLi4udGhpcy5tZXNzYWdlUXVldWVdO1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgcXVldWUuZm9yRWFjaCgocSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChxLm1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHEudGltZW91dCk7XG4gICAgICAgIHEucmVqZWN0KG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXCJGYWlsZWQgdG8gc2VuZCBxdWV1ZWQgbWVzc2FnZVwiKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVqZWN0UXVldWVkTWVzc2FnZXMoZXJyb3IpIHtcbiAgICBjb25zdCBxdWV1ZSA9IFsuLi50aGlzLm1lc3NhZ2VRdWV1ZV07XG4gICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICBxdWV1ZS5mb3JFYWNoKChxKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQocS50aW1lb3V0KTtcbiAgICAgIHEucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBzdGFydEhlYXJ0YmVhdCgpIHtcbiAgICBpZiAodGhpcy5oZWFydGJlYXRUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud2Vic29ja2V0ICYmIHRoaXMud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6IFwicGluZ1wiLCBwYXlsb2FkOiB7fSB9KSk7XG4gICAgICB9XG4gICAgfSwgMjVlMyk7XG4gIH1cbiAgc2NoZWR1bGVSZWNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hhbm5lbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XG4gICAgY29uc3QgYmFzZURlbGF5ID0gTWF0aC5taW4oM2U0LCBNYXRoLnBvdygyLCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSAqIDFlMyk7XG4gICAgY29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAqIDFlMztcbiAgICBjb25zdCBkZWxheSA9IGJhc2VEZWxheSArIGppdHRlcjtcbiAgICBjb25zb2xlLmxvZyhgXFx1ezFGNTA0fSBTY2hlZHVsaW5nIHJlY29ubmVjdCBhdHRlbXB0ICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gaW4gJHtNYXRoLnJvdW5kKGRlbGF5KX1tc2ApO1xuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBnbG9iYWxUaGlzLnNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2hhbm5lbHMuc2l6ZSA9PT0gMCkgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0V2ViU29ja2V0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdWJzY3JpYmVBbGxDaGFubmVscygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlY29ubmVjdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0sIGRlbGF5KTtcbiAgfVxuICBhc3luYyByZXN1YnNjcmliZUFsbENoYW5uZWxzKCkge1xuICAgIGNvbnNvbGUubG9nKGBcXHV7MUY1MDR9IFJlc3Vic2NyaWJpbmcgJHt0aGlzLmNoYW5uZWxzLnNpemV9IGNoYW5uZWxzLi4uYCk7XG4gICAgZm9yIChjb25zdCBbY2hhbm5lbE5hbWUsIHN1YnNjcmlwdGlvbl0gb2YgdGhpcy5jaGFubmVscykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlTWVzc2FnZSA9IHtcbiAgICAgICAgICB0eXBlOiBcInN1YnNjcmliZVwiLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWxOYW1lLFxuICAgICAgICAgICAgdXNlcklkOiBzdWJzY3JpcHRpb24ub3B0aW9ucy51c2VySWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogc3Vic2NyaXB0aW9uLm9wdGlvbnMubWV0YWRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLndlYnNvY2tldCAmJiB0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShzdWJzY3JpYmVNZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byByZXN1YnNjcmliZSB0byAke2NoYW5uZWxOYW1lfTpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVhbHRpbWUudHNcbnZhciBCbGlua1JlYWx0aW1lQ2hhbm5lbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbE5hbWUsIGNvbm5lY3Rpb24sIGh0dHBDbGllbnQsIHByb2plY3RJZCkge1xuICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBjaGFubmVsTmFtZTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gIH1cbiAgbWVzc2FnZUNhbGxiYWNrcyA9IFtdO1xuICBwcmVzZW5jZUNhbGxiYWNrcyA9IFtdO1xuICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgc3Vic2NyaWJlT3B0aW9ucyA9IHt9O1xuICAvKipcbiAgICogQ2hlY2sgaWYgY2hhbm5lbCBpcyByZWFkeSBmb3IgcHVibGlzaGluZ1xuICAgKi9cbiAgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1N1YnNjcmliZWQgJiYgdGhpcy5jb25uZWN0aW9uLmlzUmVhZHkoKTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaXNTdWJzY3JpYmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaWJlT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgIG9uTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gbWVzc2FnZSBjYWxsYmFjazpcIiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25QcmVzZW5jZTogKHVzZXJzKSA9PiB7XG4gICAgICAgIHRoaXMucHJlc2VuY2VDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2sodXNlcnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gcHJlc2VuY2UgY2FsbGJhY2s6XCIsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uU3Vic2NyaWJlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLmlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYENoYW5uZWwgJHt0aGlzLmNoYW5uZWxOYW1lfSBlcnJvcjpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uam9pbkNoYW5uZWwodGhpcy5jaGFubmVsTmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgdGhpcy5pc1N1YnNjcmliZWQgPSB0cnVlO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5pc1N1YnNjcmliZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmxlYXZlQ2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lKTtcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHR5cGUsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZCh0aGlzLmNoYW5uZWxOYW1lLCB0eXBlLCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBvbk1lc3NhZ2UoY2FsbGJhY2spIHtcbiAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvblByZXNlbmNlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVzZW5jZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnByZXNlbmNlQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5wcmVzZW5jZUNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0UHJlc2VuY2UoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnJlYWx0aW1lR2V0UHJlc2VuY2UodGhpcy5wcm9qZWN0SWQsIHRoaXMuY2hhbm5lbE5hbWUpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudXNlcnMgfHwgW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZ2V0IHByZXNlbmNlIGZvciBjaGFubmVsICR7dGhpcy5jaGFubmVsTmFtZX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRNZXNzYWdlcyhvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucmVhbHRpbWVHZXRNZXNzYWdlcyh0aGlzLnByb2plY3RJZCwge1xuICAgICAgICBjaGFubmVsOiB0aGlzLmNoYW5uZWxOYW1lLFxuICAgICAgICBsaW1pdDogb3B0aW9ucy5saW1pdCxcbiAgICAgICAgc3RhcnQ6IG9wdGlvbnMuYWZ0ZXIgfHwgXCItXCIsXG4gICAgICAgIGVuZDogb3B0aW9ucy5iZWZvcmUgfHwgXCIrXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWVzc2FnZXMgfHwgW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBCbGlua1JlYWx0aW1lRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZ2V0IG1lc3NhZ2VzIGZvciBjaGFubmVsICR7dGhpcy5jaGFubmVsTmFtZX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIHRoaXMuaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgdGhpcy5zdWJzY3JpYmVPcHRpb25zID0ge307XG4gICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5wcmVzZW5jZUNhbGxiYWNrcyA9IFtdO1xuICB9XG59O1xudmFyIEJsaW5rUmVhbHRpbWVJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCBwcm9qZWN0SWQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBSZWFsdGltZUNvbm5lY3Rpb24oaHR0cENsaWVudCwgcHJvamVjdElkKTtcbiAgfVxuICBjb25uZWN0aW9uO1xuICBjaGFubmVscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGhhbmRsZXJzID0ge307XG4gIGNoYW5uZWwobmFtZSkge1xuICAgIGlmICghdGhpcy5jaGFubmVscy5oYXMobmFtZSkpIHtcbiAgICAgIHRoaXMuY2hhbm5lbHMuc2V0KG5hbWUsIG5ldyBCbGlua1JlYWx0aW1lQ2hhbm5lbChuYW1lLCB0aGlzLmNvbm5lY3Rpb24sIHRoaXMuaHR0cENsaWVudCwgdGhpcy5wcm9qZWN0SWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHMuZ2V0KG5hbWUpO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZShjaGFubmVsTmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoY2hhbm5lbE5hbWUpO1xuICAgIGF3YWl0IGNoYW5uZWwuc3Vic2NyaWJlKG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5oYW5kbGVyc1tjaGFubmVsTmFtZV0gPz89IHtcbiAgICAgIG1zZ0hhbmRsZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgcHJlc0hhbmRsZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgc3Vic2NyaWJlZDogdHJ1ZVxuICAgIH07XG4gICAgc3RhdGUubXNnSGFuZGxlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICBjb25zdCBtZXNzYWdlVW5zdWIgPSBjaGFubmVsLm9uTWVzc2FnZShjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1lc3NhZ2VVbnN1YigpO1xuICAgICAgc3RhdGUubXNnSGFuZGxlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIGlmIChzdGF0ZS5tc2dIYW5kbGVycy5zaXplID09PSAwICYmIHN0YXRlLnByZXNIYW5kbGVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlcnNbY2hhbm5lbE5hbWVdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgcHVibGlzaChjaGFubmVsTmFtZSwgdHlwZSwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgcmV0dXJuIGNoYW5uZWwucHVibGlzaCh0eXBlLCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBwcmVzZW5jZShjaGFubmVsTmFtZSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoY2hhbm5lbE5hbWUpO1xuICAgIHJldHVybiBjaGFubmVsLmdldFByZXNlbmNlKCk7XG4gIH1cbiAgb25QcmVzZW5jZShjaGFubmVsTmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsKGNoYW5uZWxOYW1lKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuaGFuZGxlcnNbY2hhbm5lbE5hbWVdID8/PSB7XG4gICAgICBtc2dIYW5kbGVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIHByZXNIYW5kbGVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIHN1YnNjcmliZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBzdGF0ZS5wcmVzSGFuZGxlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICBjb25zdCBwcmVzZW5jZVVuc3ViID0gY2hhbm5lbC5vblByZXNlbmNlKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcHJlc2VuY2VVbnN1YigpO1xuICAgICAgc3RhdGUucHJlc0hhbmRsZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3RhdGUubXNnSGFuZGxlcnMuc2l6ZSA9PT0gMCAmJiBzdGF0ZS5wcmVzSGFuZGxlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBjaGFubmVsLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhhbmRsZXJzW2NoYW5uZWxOYW1lXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBhY3RpdmUgV2ViU29ja2V0IGNvbm5lY3Rpb25zIChzaG91bGQgYWx3YXlzIGJlIDAgb3IgMSlcbiAgICovXG4gIGdldENvbm5lY3Rpb25Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmlzUmVhZHkoKSA/IDEgOiAwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBhY3RpdmUgY2hhbm5lbHNcbiAgICovXG4gIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmdldENoYW5uZWxDb3VudCgpO1xuICB9XG59O1xuXG4vLyBzcmMvbm90aWZpY2F0aW9ucy50c1xudmFyIEJsaW5rTm90aWZpY2F0aW9uc0ltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBlbWFpbCB1c2luZyB0aGUgQmxpbmsgTm90aWZpY2F0aW9ucyBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGV0YWlscyBmb3IgdGhlIGVtYWlsLlxuICAgKiAgIC0gYHRvYDogVGhlIHJlY2lwaWVudCdzIGVtYWlsIGFkZHJlc3Mgb3IgYW4gYXJyYXkgb2YgYWRkcmVzc2VzLlxuICAgKiAgIC0gYHN1YmplY3RgOiBUaGUgc3ViamVjdCBsaW5lIG9mIHRoZSBlbWFpbC5cbiAgICogICAtIGBodG1sYDogVGhlIEhUTUwgYm9keSBvZiB0aGUgZW1haWwuIEZvciBiZXN0IHJlc3VsdHMgYWNyb3NzIGFsbCBlbWFpbFxuICAgKiAgICAgICAgICAgICBjbGllbnRzIChsaWtlIEdtYWlsLCBPdXRsb29rKSwgdXNlIGlubGluZSBDU1MgYW5kIHRhYmxlLWJhc2VkIGxheW91dHMuXG4gICAqICAgLSBgdGV4dGA6IEEgcGxhaW4tdGV4dCB2ZXJzaW9uIG9mIHRoZSBlbWFpbCBib2R5IChvcHRpb25hbCkuXG4gICAqICAgLSBgZnJvbWA6IEEgY3VzdG9tIHNlbmRlciBuYW1lIChlLmcuLCBcIkFjbWUgSW5jXCIpLiBUaGUgZW1haWwgYWRkcmVzcyB3aWxsXG4gICAqICAgICAgICAgICAgIGJlIGF1dG8tZ2VuZXJhdGVkIGJ5IHRoZSBwcm9qZWN0IChlLmcuLCBcIm5vcmVwbHlAcHJvamVjdC5ibGluay1lbWFpbC5jb21cIikuXG4gICAqICAgLSBgcmVwbHlUb2A6IEFuIGVtYWlsIGFkZHJlc3MgZm9yIHJlY2lwaWVudHMgdG8gcmVwbHkgdG8gKG9wdGlvbmFsKS5cbiAgICogICAtIGBjY2A6IEEgQ0MgcmVjaXBpZW50J3MgZW1haWwgYWRkcmVzcyBvciBhbiBhcnJheSBvZiBhZGRyZXNzZXMgKG9wdGlvbmFsKS5cbiAgICogICAtIGBiY2NgOiBBIEJDQyByZWNpcGllbnQncyBlbWFpbCBhZGRyZXNzIG9yIGFuIGFycmF5IG9mIGFkZHJlc3NlcyAob3B0aW9uYWwpLlxuICAgKiAgIC0gYGF0dGFjaG1lbnRzYDogQW4gYXJyYXkgb2Ygb2JqZWN0cyBmb3IgZmlsZXMgdG8gYXR0YWNoLCBlYWNoIHdpdGggYSBgdXJsYC5cbiAgICogICAgICAgICAgICAgICAgICAgIFRoZSBmaWxlIGF0IHRoZSBVUkwgd2lsbCBiZSBmZXRjaGVkIGFuZCBhdHRhY2hlZCBieSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBTZW5kIGEgc2ltcGxlIGVtYWlsXG4gICAqIGNvbnN0IHsgc3VjY2VzcywgbWVzc2FnZUlkIH0gPSBhd2FpdCBibGluay5ub3RpZmljYXRpb25zLmVtYWlsKHtcbiAgICogICB0bzogJ2N1c3RvbWVyQGV4YW1wbGUuY29tJyxcbiAgICogICBzdWJqZWN0OiAnWW91ciBvcmRlciBoYXMgc2hpcHBlZCEnLFxuICAgKiAgIGh0bWw6ICc8aDE+T3JkZXIgQ29uZmlybWF0aW9uPC9oMT48cD5Zb3VyIG9yZGVyICMxMjM0NSBpcyBvbiBpdHMgd2F5LjwvcD4nXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBTZW5kIGFuIGVtYWlsIHdpdGggYXR0YWNobWVudHMgYW5kIGEgY3VzdG9tIGZyb20gbmFtZVxuICAgKiBjb25zdCB7IHN1Y2Nlc3MgfSA9IGF3YWl0IGJsaW5rLm5vdGlmaWNhdGlvbnMuZW1haWwoe1xuICAgKiAgIHRvOiBbJ3RlYW1AZXhhbXBsZS5jb20nLCAnbWFuYWdlckBleGFtcGxlLmNvbSddLFxuICAgKiAgIHN1YmplY3Q6ICdOZXcgSW52b2ljZScsXG4gICAqICAgZnJvbTogJ0JsaW5rIEludm9pY2luZycsXG4gICAqICAgaHRtbDogJzxwPlBsZWFzZSBmaW5kIHRoZSBpbnZvaWNlIGF0dGFjaGVkLjwvcD4nLFxuICAgKiAgIGF0dGFjaG1lbnRzOiBbXG4gICAqICAgICB7IHVybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vaW52b2ljZS5wZGYnLCBmaWxlbmFtZTogJ2ludm9pY2UucGRmJyB9XG4gICAqICAgXVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0YXR1cyBvZiB0aGUgZW1haWwgc2VuZC5cbiAgICogICAtIGBzdWNjZXNzYDogQSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGVtYWlsIHdhcyBzZW50IHN1Y2Nlc3NmdWxseS5cbiAgICogICAtIGBtZXNzYWdlSWRgOiBUaGUgdW5pcXVlIElEIG9mIHRoZSBtZXNzYWdlIGZyb20gdGhlIGVtYWlsIHByb3ZpZGVyLlxuICAgKi9cbiAgYXN5bmMgZW1haWwocGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcGFyYW1zLnRvIHx8ICFwYXJhbXMuc3ViamVjdCB8fCAhcGFyYW1zLmh0bWwgJiYgIXBhcmFtcy50ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBCbGlua05vdGlmaWNhdGlvbnNFcnJvcignVGhlIFwidG9cIiwgXCJzdWJqZWN0XCIsIGFuZCBlaXRoZXIgXCJodG1sXCIgb3IgXCJ0ZXh0XCIgZmllbGRzIGFyZSByZXF1aXJlZC4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnBvc3QoYC9hcGkvbm90aWZpY2F0aW9ucy8ke3RoaXMuaHR0cENsaWVudC5wcm9qZWN0SWR9L2VtYWlsYCwgcGFyYW1zKTtcbiAgICAgIGlmICghcmVzcG9uc2UuZGF0YSB8fCB0eXBlb2YgcmVzcG9uc2UuZGF0YS5zdWNjZXNzICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aHJvdyBuZXcgQmxpbmtOb3RpZmljYXRpb25zRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gZW1haWwgQVBJXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJsaW5rTm90aWZpY2F0aW9uc0Vycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2UgfHwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICB0aHJvdyBuZXcgQmxpbmtOb3RpZmljYXRpb25zRXJyb3IoYEZhaWxlZCB0byBzZW5kIGVtYWlsOiAke2Vycm9yTWVzc2FnZX1gLCBlcnJvci5yZXNwb25zZT8uc3RhdHVzLCBlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2FuYWx5dGljcy50c1xudmFyIFNFU1NJT05fRFVSQVRJT04gPSAzMCAqIDYwICogMWUzO1xudmFyIE1BWF9CQVRDSF9TSVpFID0gMTA7XG52YXIgQkFUQ0hfVElNRU9VVCA9IDNlMztcbnZhciBNQVhfU1RSSU5HX0xFTkdUSCA9IDI1NjtcbnZhciBCbGlua0FuYWx5dGljc0ltcGwgPSBjbGFzcyB7XG4gIGh0dHBDbGllbnQ7XG4gIHByb2plY3RJZDtcbiAgcXVldWUgPSBbXTtcbiAgdGltZXIgPSBudWxsO1xuICBlbmFibGVkID0gdHJ1ZTtcbiAgdXNlcklkID0gbnVsbDtcbiAgdXNlckVtYWlsID0gbnVsbDtcbiAgaGFzVHJhY2tlZFBhZ2V2aWV3ID0gZmFsc2U7XG4gIHV0bVBhcmFtcyA9IHt9O1xuICBwZXJzaXN0ZWRBdHRyaWJ1dGlvbiA9IHt9O1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCBwcm9qZWN0SWQpIHtcbiAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkO1xuICAgIGlmICghaXNXZWIpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmF2aWdhdG9yLmRvTm90VHJhY2sgPT09IFwiMVwiKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2FkUGVyc2lzdGVkQXR0cmlidXRpb24oKTtcbiAgICB0aGlzLmNhcHR1cmVVVE1QYXJhbXMoKTtcbiAgICB0aGlzLmxvYWRRdWV1ZSgpO1xuICAgIHRoaXMudHJhY2tQYWdldmlldygpO1xuICAgIHRoaXMuc2V0dXBSb3V0ZUNoYW5nZUxpc3RlbmVyKCk7XG4gICAgdGhpcy5zZXR1cFVubG9hZExpc3RlbmVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHByb2plY3Qtc2NvcGVkIHN0b3JhZ2Uga2V5IGZvciBhbmFseXRpY3NcbiAgICovXG4gIGdldFN0b3JhZ2VLZXkoc3VmZml4KSB7XG4gICAgcmV0dXJuIGBibGlua0FuYWx5dGljcyR7c3VmZml4fV8ke3RoaXMucHJvamVjdElkfWA7XG4gIH1cbiAgLyoqXG4gICAqIExvZyBhIGN1c3RvbSBhbmFseXRpY3MgZXZlbnRcbiAgICovXG4gIGxvZyhldmVudE5hbWUsIGRhdGEgPSB7fSkge1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFpc1dlYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudCA9IHRoaXMuYnVpbGRFdmVudChldmVudE5hbWUsIGRhdGEpO1xuICAgIHRoaXMuZW5xdWV1ZShldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGUgYW5hbHl0aWNzIHRyYWNraW5nXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbnVwIGFuYWx5dGljcyBpbnN0YW5jZSAocmVtb3ZlIGZyb20gZ2xvYmFsIHRyYWNraW5nKVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93Ll9fYmxpbmtBbmFseXRpY3NJbnN0YW5jZXM/LmRlbGV0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBhbmFseXRpY3MgdHJhY2tpbmdcbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbmFseXRpY3MgaXMgZW5hYmxlZFxuICAgKi9cbiAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlciBJRCBmb3IgYW5hbHl0aWNzIGV2ZW50c1xuICAgKi9cbiAgc2V0VXNlcklkKHVzZXJJZCkge1xuICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHVzZXIgZW1haWwgZm9yIGFuYWx5dGljcyBldmVudHNcbiAgICovXG4gIHNldFVzZXJFbWFpbChlbWFpbCkge1xuICAgIHRoaXMudXNlckVtYWlsID0gZW1haWw7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIHBlcnNpc3RlZCBhdHRyaWJ1dGlvbiBkYXRhXG4gICAqL1xuICBjbGVhckF0dHJpYnV0aW9uKCkge1xuICAgIHRoaXMucGVyc2lzdGVkQXR0cmlidXRpb24gPSB7fTtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiQXR0cmlidXRpb25cIikpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgYnVpbGRFdmVudCh0eXBlLCBkYXRhID0ge30pIHtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSB0aGlzLmdldE9yQ3JlYXRlU2Vzc2lvbklkKCk7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuZGV0ZWN0Q2hhbm5lbCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgdGltZXN0YW1wOiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCksXG4gICAgICBwcm9qZWN0X2lkOiB0aGlzLnByb2plY3RJZCxcbiAgICAgIHVzZXJfaWQ6IHRoaXMudXNlcklkLFxuICAgICAgdXNlcl9lbWFpbDogdGhpcy51c2VyRW1haWwsXG4gICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgICBwYXRobmFtZTogZ2V0TG9jYXRpb25QYXRobmFtZSgpLFxuICAgICAgcmVmZXJyZXI6IGdldERvY3VtZW50UmVmZXJyZXIoKSxcbiAgICAgIHNjcmVlbl93aWR0aDogZ2V0V2luZG93SW5uZXJXaWR0aCgpLFxuICAgICAgY2hhbm5lbCxcbiAgICAgIHV0bV9zb3VyY2U6IHRoaXMudXRtUGFyYW1zLnV0bV9zb3VyY2UgfHwgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbi51dG1fc291cmNlIHx8IG51bGwsXG4gICAgICB1dG1fbWVkaXVtOiB0aGlzLnV0bVBhcmFtcy51dG1fbWVkaXVtIHx8IHRoaXMucGVyc2lzdGVkQXR0cmlidXRpb24udXRtX21lZGl1bSB8fCBudWxsLFxuICAgICAgdXRtX2NhbXBhaWduOiB0aGlzLnV0bVBhcmFtcy51dG1fY2FtcGFpZ24gfHwgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbi51dG1fY2FtcGFpZ24gfHwgbnVsbCxcbiAgICAgIHV0bV9jb250ZW50OiB0aGlzLnV0bVBhcmFtcy51dG1fY29udGVudCB8fCB0aGlzLnBlcnNpc3RlZEF0dHJpYnV0aW9uLnV0bV9jb250ZW50IHx8IG51bGwsXG4gICAgICB1dG1fdGVybTogdGhpcy51dG1QYXJhbXMudXRtX3Rlcm0gfHwgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbi51dG1fdGVybSB8fCBudWxsLFxuICAgICAgLi4udGhpcy5zYW5pdGl6ZURhdGEoZGF0YSlcbiAgICB9O1xuICB9XG4gIHNhbml0aXplRGF0YShkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiBNQVhfU1RSSU5HX0xFTkdUSCA/IGRhdGEuc2xpY2UoMCwgTUFYX1NUUklOR19MRU5HVEggLSAzKSArIFwiLi4uXCIgOiBkYXRhO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5zYW5pdGl6ZURhdGEoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGVucXVldWUoZXZlbnQpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goZXZlbnQpO1xuICAgIHRoaXMucGVyc2lzdFF1ZXVlKCk7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID49IE1BWF9CQVRDSF9TSVpFKSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy50aW1lcikge1xuICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaCgpLCBCQVRDSF9USU1FT1VUKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmx1c2goKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMucXVldWUuc2xpY2UoMCwgTUFYX0JBVENIX1NJWkUpO1xuICAgIHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLnNsaWNlKE1BWF9CQVRDSF9TSVpFKTtcbiAgICB0aGlzLnBlcnNpc3RRdWV1ZSgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdChgL2FwaS9hbmFseXRpY3MvJHt0aGlzLnByb2plY3RJZH0vbG9nYCwgeyBldmVudHMgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMucXVldWUgPSBbLi4uZXZlbnRzLCAuLi50aGlzLnF1ZXVlXTtcbiAgICAgIHRoaXMucGVyc2lzdFF1ZXVlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgQkFUQ0hfVElNRU9VVCk7XG4gICAgfVxuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXRPckNyZWF0ZVNlc3Npb25JZCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiU2Vzc2lvblwiKSk7XG4gICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSBzZXNzaW9uLmxhc3RBY3Rpdml0eUF0ID4gU0VTU0lPTl9EVVJBVElPTikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU5ld1Nlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLmxhc3RBY3Rpdml0eUF0ID0gbm93O1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmdldFN0b3JhZ2VLZXkoXCJTZXNzaW9uXCIpLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XG4gICAgICAgIHJldHVybiBzZXNzaW9uLmlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTmV3U2Vzc2lvbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNyZWF0ZU5ld1Nlc3Npb24oKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByYW5kb21JZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICAgIGlkOiBgc2Vzc18ke25vd31fJHtyYW5kb21JZH1gLFxuICAgICAgc3RhcnRlZEF0OiBub3csXG4gICAgICBsYXN0QWN0aXZpdHlBdDogbm93XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiU2Vzc2lvblwiKSwgSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbikpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4gc2Vzc2lvbi5pZDtcbiAgfVxuICBsb2FkUXVldWUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuZ2V0U3RvcmFnZUtleShcIlF1ZXVlXCIpKTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgQkFUQ0hfVElNRU9VVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB9XG4gIH1cbiAgcGVyc2lzdFF1ZXVlKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiUXVldWVcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5nZXRTdG9yYWdlS2V5KFwiUXVldWVcIiksIEpTT04uc3RyaW5naWZ5KHRoaXMucXVldWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgdHJhY2tQYWdldmlldygpIHtcbiAgICBpZiAoIXRoaXMuaGFzVHJhY2tlZFBhZ2V2aWV3KSB7XG4gICAgICB0aGlzLmxvZyhcInBhZ2V2aWV3XCIpO1xuICAgICAgdGhpcy5oYXNUcmFja2VkUGFnZXZpZXcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBzZXR1cFJvdXRlQ2hhbmdlTGlzdGVuZXIoKSB7XG4gICAgaWYgKCFpc1dlYikgcmV0dXJuO1xuICAgIGlmICghd2luZG93Ll9fYmxpbmtBbmFseXRpY3NTZXR1cCkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxQdXNoU3RhdGUgPSBoaXN0b3J5LnB1c2hTdGF0ZTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsUmVwbGFjZVN0YXRlID0gaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG4gICAgICBjb25zdCBhbmFseXRpY3NJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgd2luZG93Ll9fYmxpbmtBbmFseXRpY3NJbnN0YW5jZXMgPSBhbmFseXRpY3NJbnN0YW5jZXM7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIG9yaWdpbmFsUHVzaFN0YXRlLmFwcGx5KGhpc3RvcnksIGFyZ3MpO1xuICAgICAgICBhbmFseXRpY3NJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmxvZyhcInBhZ2V2aWV3XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBvcmlnaW5hbFJlcGxhY2VTdGF0ZS5hcHBseShoaXN0b3J5LCBhcmdzKTtcbiAgICAgICAgYW5hbHl0aWNzSW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLmlzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5sb2coXCJwYWdldmlld1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgKCkgPT4ge1xuICAgICAgICBhbmFseXRpY3NJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmxvZyhcInBhZ2V2aWV3XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5fX2JsaW5rQW5hbHl0aWNzU2V0dXAgPSB0cnVlO1xuICAgIH1cbiAgICB3aW5kb3cuX19ibGlua0FuYWx5dGljc0luc3RhbmNlcz8uYWRkKHRoaXMpO1xuICB9XG4gIHNldHVwVW5sb2FkTGlzdGVuZXIoKSB7XG4gICAgaWYgKCFpc1dlYiB8fCAhaGFzV2luZG93KCkpIHJldHVybjtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfSk7XG4gIH1cbiAgY2FwdHVyZVVUTVBhcmFtcygpIHtcbiAgICBpZiAoIWlzV2ViKSByZXR1cm47XG4gICAgY29uc3Qgc2VhcmNoID0gZ2V0TG9jYXRpb25TZWFyY2goKTtcbiAgICBpZiAoIXNlYXJjaCkge1xuICAgICAgdGhpcy51dG1QYXJhbXMgPSB7fTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgIHRoaXMudXRtUGFyYW1zID0ge1xuICAgICAgdXRtX3NvdXJjZTogdXJsUGFyYW1zLmdldChcInV0bV9zb3VyY2VcIiksXG4gICAgICB1dG1fbWVkaXVtOiB1cmxQYXJhbXMuZ2V0KFwidXRtX21lZGl1bVwiKSxcbiAgICAgIHV0bV9jYW1wYWlnbjogdXJsUGFyYW1zLmdldChcInV0bV9jYW1wYWlnblwiKSxcbiAgICAgIHV0bV9jb250ZW50OiB1cmxQYXJhbXMuZ2V0KFwidXRtX2NvbnRlbnRcIiksXG4gICAgICB1dG1fdGVybTogdXJsUGFyYW1zLmdldChcInV0bV90ZXJtXCIpXG4gICAgfTtcbiAgICBjb25zdCBoYXNOZXdQYXJhbXMgPSBPYmplY3QudmFsdWVzKHRoaXMudXRtUGFyYW1zKS5zb21lKCh2KSA9PiB2ICE9PSBudWxsKTtcbiAgICBpZiAoaGFzTmV3UGFyYW1zKSB7XG4gICAgICB0aGlzLnBlcnNpc3RBdHRyaWJ1dGlvbigpO1xuICAgIH1cbiAgfVxuICBsb2FkUGVyc2lzdGVkQXR0cmlidXRpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuZ2V0U3RvcmFnZUtleShcIkF0dHJpYnV0aW9uXCIpKTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMucGVyc2lzdGVkQXR0cmlidXRpb24gPSB7fTtcbiAgICB9XG4gIH1cbiAgcGVyc2lzdEF0dHJpYnV0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGlvbiA9IHtcbiAgICAgICAgLi4udGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbixcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMudXRtUGFyYW1zKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPT0gbnVsbClcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuZ2V0U3RvcmFnZUtleShcIkF0dHJpYnV0aW9uXCIpLCBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGlvbikpO1xuICAgICAgdGhpcy5wZXJzaXN0ZWRBdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBkZXRlY3RDaGFubmVsKCkge1xuICAgIGNvbnN0IHJlZmVycmVyID0gZ2V0RG9jdW1lbnRSZWZlcnJlcigpO1xuICAgIGNvbnN0IHV0bU1lZGl1bSA9IHRoaXMudXRtUGFyYW1zLnV0bV9tZWRpdW07XG4gICAgdGhpcy51dG1QYXJhbXMudXRtX3NvdXJjZTtcbiAgICBpZiAodXRtTWVkaXVtKSB7XG4gICAgICBpZiAodXRtTWVkaXVtID09PSBcImNwY1wiIHx8IHV0bU1lZGl1bSA9PT0gXCJwcGNcIikgcmV0dXJuIFwiUGFpZCBTZWFyY2hcIjtcbiAgICAgIGlmICh1dG1NZWRpdW0gPT09IFwiZW1haWxcIikgcmV0dXJuIFwiRW1haWxcIjtcbiAgICAgIGlmICh1dG1NZWRpdW0gPT09IFwic29jaWFsXCIpIHJldHVybiBcIlNvY2lhbFwiO1xuICAgICAgaWYgKHV0bU1lZGl1bSA9PT0gXCJyZWZlcnJhbFwiKSByZXR1cm4gXCJSZWZlcnJhbFwiO1xuICAgICAgaWYgKHV0bU1lZGl1bSA9PT0gXCJkaXNwbGF5XCIpIHJldHVybiBcIkRpc3BsYXlcIjtcbiAgICAgIGlmICh1dG1NZWRpdW0gPT09IFwiYWZmaWxpYXRlXCIpIHJldHVybiBcIkFmZmlsaWF0ZVwiO1xuICAgIH1cbiAgICBpZiAoIXJlZmVycmVyKSByZXR1cm4gXCJEaXJlY3RcIjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVmZXJyZXJVcmwgPSBuZXcgVVJMKHJlZmVycmVyKTtcbiAgICAgIGNvbnN0IHJlZmVycmVyRG9tYWluID0gcmVmZXJyZXJVcmwuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICgvZ29vZ2xlXFwufGJpbmdcXC58eWFob29cXC58ZHVja2R1Y2tnb1xcLnxiYWlkdVxcLnx5YW5kZXhcXC4vLnRlc3QocmVmZXJyZXJEb21haW4pKSB7XG4gICAgICAgIHJldHVybiBcIk9yZ2FuaWMgU2VhcmNoXCI7XG4gICAgICB9XG4gICAgICBpZiAoL2ZhY2Vib29rXFwufHR3aXR0ZXJcXC58bGlua2VkaW5cXC58aW5zdGFncmFtXFwufHlvdXR1YmVcXC58dGlrdG9rXFwufHJlZGRpdFxcLi8udGVzdChyZWZlcnJlckRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIFwiU29jaWFsXCI7XG4gICAgICB9XG4gICAgICBpZiAoL21haWxcXC58b3V0bG9va1xcLnxnbWFpbFxcLi8udGVzdChyZWZlcnJlckRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIFwiRW1haWxcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlJlZmVycmFsXCI7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJEaXJlY3RcIjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jb25uZWN0b3JzLnRzXG52YXIgQmxpbmtDb25uZWN0b3JzSW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaHR0cENsaWVudCkge1xuICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gIH1cbiAgYXN5bmMgc3RhdHVzKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuY29ubmVjdG9yU3RhdHVzKHByb3ZpZGVyKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBleGVjdXRlKHByb3ZpZGVyLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuY29ubmVjdG9yRXhlY3V0ZShwcm92aWRlciwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbiAgYXN5bmMgc2F2ZUFwaUtleShwcm92aWRlciwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmNvbm5lY3RvclNhdmVBcGlLZXkocHJvdmlkZXIsIHJlcXVlc3QpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG59O1xuXG4vLyBzcmMvZnVuY3Rpb25zLnRzXG52YXIgQmxpbmtGdW5jdGlvbnNJbXBsID0gY2xhc3Mge1xuICBodHRwQ2xpZW50O1xuICBwcm9qZWN0SWQ7XG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQsIHByb2plY3RJZCwgX2dldFRva2VuKSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwcm9qZWN0IHN1ZmZpeCBmcm9tIHRoZSBmdWxsIHByb2plY3QgSUQuXG4gICAqIFByb2plY3QgSURzIGFyZSBmb3JtYXR0ZWQgYXM6IHByal94eHh4eFxuICAgKiBUaGUgc3VmZml4IGlzIHRoZSBsYXN0IDggY2hhcmFjdGVycyB1c2VkIGluIGZ1bmN0aW9uIFVSTHMuXG4gICAqL1xuICBnZXRQcm9qZWN0U3VmZml4KCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3RJZC5zbGljZSgtOCk7XG4gIH1cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBmdWxsIGZ1bmN0aW9uIFVSTFxuICAgKi9cbiAgYnVpbGRGdW5jdGlvblVybChmdW5jdGlvblNsdWcsIHNlYXJjaFBhcmFtcykge1xuICAgIGNvbnN0IHN1ZmZpeCA9IHRoaXMuZ2V0UHJvamVjdFN1ZmZpeCgpO1xuICAgIGNvbnN0IGJhc2VVcmwgPSBgaHR0cHM6Ly8ke3N1ZmZpeH0tLSR7ZnVuY3Rpb25TbHVnfS5mdW5jdGlvbnMuYmxpbmsubmV3YDtcbiAgICBpZiAoIXNlYXJjaFBhcmFtcyB8fCBPYmplY3Qua2V5cyhzZWFyY2hQYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgT2JqZWN0LmVudHJpZXMoc2VhcmNoUGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfVxuICBhc3luYyBpbnZva2UoZnVuY3Rpb25TbHVnLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IG1ldGhvZCA9IFwiUE9TVFwiLCBib2R5LCBoZWFkZXJzID0ge30sIHNlYXJjaFBhcmFtcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkRnVuY3Rpb25VcmwoZnVuY3Rpb25TbHVnLCBzZWFyY2hQYXJhbXMpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5yZXF1ZXN0KHVybCwgeyBtZXRob2QsIGJvZHksIGhlYWRlcnMgfSk7XG4gICAgcmV0dXJuIHsgZGF0YTogcmVzLmRhdGEsIHN0YXR1czogcmVzLnN0YXR1cywgaGVhZGVyczogcmVzLmhlYWRlcnMgfTtcbiAgfVxufTtcblxuLy8gc3JjL3JhZy50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gdm9pZCAwKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydENvbGxlY3Rpb24oYXBpKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGFwaS5pZCxcbiAgICBuYW1lOiBhcGkubmFtZSxcbiAgICBkZXNjcmlwdGlvbjogYXBpLmRlc2NyaXB0aW9uLFxuICAgIGVtYmVkZGluZ01vZGVsOiBhcGkuZW1iZWRkaW5nX21vZGVsLFxuICAgIGVtYmVkZGluZ0RpbWVuc2lvbnM6IGFwaS5lbWJlZGRpbmdfZGltZW5zaW9ucyxcbiAgICBpbmRleE1ldHJpYzogYXBpLmluZGV4X21ldHJpYyxcbiAgICBjaHVua01heFRva2VuczogYXBpLmNodW5rX21heF90b2tlbnMsXG4gICAgY2h1bmtPdmVybGFwVG9rZW5zOiBhcGkuY2h1bmtfb3ZlcmxhcF90b2tlbnMsXG4gICAgZG9jdW1lbnRDb3VudDogYXBpLmRvY3VtZW50X2NvdW50LFxuICAgIGNodW5rQ291bnQ6IGFwaS5jaHVua19jb3VudCxcbiAgICBzaGFyZWQ6IGFwaS5zaGFyZWQsXG4gICAgY3JlYXRlZEF0OiBhcGkuY3JlYXRlZF9hdCxcbiAgICB1cGRhdGVkQXQ6IGFwaS51cGRhdGVkX2F0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0RG9jdW1lbnQoYXBpKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGFwaS5pZCxcbiAgICBjb2xsZWN0aW9uSWQ6IGFwaS5jb2xsZWN0aW9uX2lkLFxuICAgIGZpbGVuYW1lOiBhcGkuZmlsZW5hbWUsXG4gICAgc291cmNlVHlwZTogYXBpLnNvdXJjZV90eXBlLFxuICAgIHNvdXJjZVVybDogYXBpLnNvdXJjZV91cmwsXG4gICAgY29udGVudFR5cGU6IGFwaS5jb250ZW50X3R5cGUsXG4gICAgZmlsZVNpemU6IGFwaS5maWxlX3NpemUsXG4gICAgc3RhdHVzOiBhcGkuc3RhdHVzLFxuICAgIGVycm9yTWVzc2FnZTogYXBpLmVycm9yX21lc3NhZ2UsXG4gICAgcHJvY2Vzc2luZ1N0YXJ0ZWRBdDogYXBpLnByb2Nlc3Npbmdfc3RhcnRlZF9hdCxcbiAgICBwcm9jZXNzaW5nQ29tcGxldGVkQXQ6IGFwaS5wcm9jZXNzaW5nX2NvbXBsZXRlZF9hdCxcbiAgICBjaHVua0NvdW50OiBhcGkuY2h1bmtfY291bnQsXG4gICAgdG9rZW5Db3VudDogYXBpLnRva2VuX2NvdW50LFxuICAgIG1ldGFkYXRhOiBhcGkubWV0YWRhdGEsXG4gICAgY3JlYXRlZEF0OiBhcGkuY3JlYXRlZF9hdCxcbiAgICB1cGRhdGVkQXQ6IGFwaS51cGRhdGVkX2F0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UGFydGlhbERvY3VtZW50KGFwaSwgb3B0aW9ucykge1xuICBsZXQgc291cmNlVHlwZSA9IFwidGV4dFwiO1xuICBpZiAob3B0aW9ucy51cmwpIHNvdXJjZVR5cGUgPSBcInVybFwiO1xuICBpZiAob3B0aW9ucy5maWxlKSBzb3VyY2VUeXBlID0gXCJmaWxlXCI7XG4gIHJldHVybiB7XG4gICAgaWQ6IGFwaS5pZCB8fCBcIlwiLFxuICAgIGNvbGxlY3Rpb25JZDogYXBpLmNvbGxlY3Rpb25faWQgfHwgb3B0aW9ucy5jb2xsZWN0aW9uSWQgfHwgXCJcIixcbiAgICBmaWxlbmFtZTogYXBpLmZpbGVuYW1lIHx8IG9wdGlvbnMuZmlsZW5hbWUsXG4gICAgc291cmNlVHlwZTogYXBpLnNvdXJjZV90eXBlIHx8IHNvdXJjZVR5cGUsXG4gICAgc291cmNlVXJsOiBhcGkuc291cmNlX3VybCA/PyBvcHRpb25zLnVybCA/PyBudWxsLFxuICAgIGNvbnRlbnRUeXBlOiBhcGkuY29udGVudF90eXBlID8/IG9wdGlvbnMuZmlsZT8uY29udGVudFR5cGUgPz8gbnVsbCxcbiAgICBmaWxlU2l6ZTogYXBpLmZpbGVfc2l6ZSA/PyBudWxsLFxuICAgIHN0YXR1czogYXBpLnN0YXR1cyB8fCBcInBlbmRpbmdcIixcbiAgICBlcnJvck1lc3NhZ2U6IGFwaS5lcnJvcl9tZXNzYWdlID8/IG51bGwsXG4gICAgcHJvY2Vzc2luZ1N0YXJ0ZWRBdDogYXBpLnByb2Nlc3Npbmdfc3RhcnRlZF9hdCA/PyBudWxsLFxuICAgIHByb2Nlc3NpbmdDb21wbGV0ZWRBdDogYXBpLnByb2Nlc3NpbmdfY29tcGxldGVkX2F0ID8/IG51bGwsXG4gICAgY2h1bmtDb3VudDogYXBpLmNodW5rX2NvdW50ID8/IDAsXG4gICAgdG9rZW5Db3VudDogYXBpLnRva2VuX2NvdW50ID8/IG51bGwsXG4gICAgbWV0YWRhdGE6IGFwaS5tZXRhZGF0YSB8fCBvcHRpb25zLm1ldGFkYXRhIHx8IHt9LFxuICAgIGNyZWF0ZWRBdDogYXBpLmNyZWF0ZWRfYXQgfHwgKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogYXBpLnVwZGF0ZWRfYXQgfHwgYXBpLmNyZWF0ZWRfYXQgfHwgKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0U2VhcmNoUmVzdWx0KGFwaSkge1xuICByZXR1cm4ge1xuICAgIGNodW5rSWQ6IGFwaS5jaHVua19pZCxcbiAgICBkb2N1bWVudElkOiBhcGkuZG9jdW1lbnRfaWQsXG4gICAgZmlsZW5hbWU6IGFwaS5maWxlbmFtZSxcbiAgICBjb250ZW50OiBhcGkuY29udGVudCxcbiAgICBzY29yZTogYXBpLnNjb3JlLFxuICAgIGNodW5rSW5kZXg6IGFwaS5jaHVua19pbmRleCxcbiAgICBtZXRhZGF0YTogYXBpLm1ldGFkYXRhXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0U2VhcmNoUmVzcG9uc2UoYXBpKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdWx0czogYXBpLnJlc3VsdHMubWFwKGNvbnZlcnRTZWFyY2hSZXN1bHQpLFxuICAgIHF1ZXJ5OiBhcGkucXVlcnksXG4gICAgY29sbGVjdGlvbklkOiBhcGkuY29sbGVjdGlvbl9pZCxcbiAgICB0b3RhbFJlc3VsdHM6IGFwaS50b3RhbF9yZXN1bHRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0QUlTZWFyY2hTb3VyY2UoYXBpKSB7XG4gIHJldHVybiB7XG4gICAgZG9jdW1lbnRJZDogYXBpLmRvY3VtZW50X2lkLFxuICAgIGZpbGVuYW1lOiBhcGkuZmlsZW5hbWUsXG4gICAgY2h1bmtJZDogYXBpLmNodW5rX2lkLFxuICAgIGV4Y2VycHQ6IGFwaS5leGNlcnB0LFxuICAgIHNjb3JlOiBhcGkuc2NvcmVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBSVNlYXJjaFJlc3VsdChhcGkpIHtcbiAgcmV0dXJuIHtcbiAgICBhbnN3ZXI6IGFwaS5hbnN3ZXIsXG4gICAgc291cmNlczogYXBpLnNvdXJjZXMubWFwKGNvbnZlcnRBSVNlYXJjaFNvdXJjZSksXG4gICAgcXVlcnk6IGFwaS5xdWVyeSxcbiAgICBtb2RlbDogYXBpLm1vZGVsLFxuICAgIHVzYWdlOiB7XG4gICAgICBpbnB1dFRva2VuczogYXBpLnVzYWdlLmlucHV0X3Rva2VucyxcbiAgICAgIG91dHB1dFRva2VuczogYXBpLnVzYWdlLm91dHB1dF90b2tlbnNcbiAgICB9XG4gIH07XG59XG52YXIgQmxpbmtSQUdJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50KSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB0aGlzLnByb2plY3RJZCA9IGh0dHBDbGllbnQucHJvamVjdElkO1xuICB9XG4gIHByb2plY3RJZDtcbiAgLyoqXG4gICAqIEJ1aWxkIFVSTCB3aXRoIHByb2plY3RfaWQgcHJlZml4XG4gICAqL1xuICB1cmwocGF0aCkge1xuICAgIHJldHVybiBgL2FwaS9yYWcvJHt0aGlzLnByb2plY3RJZH0ke3BhdGh9YDtcbiAgfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENvbGxlY3Rpb25zXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBSQUcgY29sbGVjdGlvblxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgYm9keSA9IHJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucy5kZXNjcmlwdGlvbixcbiAgICAgIGVtYmVkZGluZ19tb2RlbDogb3B0aW9ucy5lbWJlZGRpbmdNb2RlbCxcbiAgICAgIGVtYmVkZGluZ19kaW1lbnNpb25zOiBvcHRpb25zLmVtYmVkZGluZ0RpbWVuc2lvbnMsXG4gICAgICBpbmRleF9tZXRyaWM6IG9wdGlvbnMuaW5kZXhNZXRyaWMsXG4gICAgICBjaHVua19tYXhfdG9rZW5zOiBvcHRpb25zLmNodW5rTWF4VG9rZW5zLFxuICAgICAgY2h1bmtfb3ZlcmxhcF90b2tlbnM6IG9wdGlvbnMuY2h1bmtPdmVybGFwVG9rZW5zLFxuICAgICAgc2hhcmVkOiBvcHRpb25zLnNoYXJlZFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnBvc3QodGhpcy51cmwoXCIvY29sbGVjdGlvbnNcIiksIGJvZHkpO1xuICAgIHJldHVybiBjb252ZXJ0Q29sbGVjdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBhbGwgY29sbGVjdGlvbnMgYWNjZXNzaWJsZSB0byB0aGUgY3VycmVudCB1c2VyXG4gICAqL1xuICBhc3luYyBsaXN0Q29sbGVjdGlvbnMoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZ2V0KHRoaXMudXJsKFwiL2NvbGxlY3Rpb25zXCIpKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5jb2xsZWN0aW9ucy5tYXAoY29udmVydENvbGxlY3Rpb24pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBzcGVjaWZpYyBjb2xsZWN0aW9uIGJ5IElEXG4gICAqL1xuICBhc3luYyBnZXRDb2xsZWN0aW9uKGNvbGxlY3Rpb25JZCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmdldCh0aGlzLnVybChgL2NvbGxlY3Rpb25zLyR7Y29sbGVjdGlvbklkfWApKTtcbiAgICByZXR1cm4gY29udmVydENvbGxlY3Rpb24ocmVzcG9uc2UuZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGNvbGxlY3Rpb24gYW5kIGFsbCBpdHMgZG9jdW1lbnRzXG4gICAqL1xuICBhc3luYyBkZWxldGVDb2xsZWN0aW9uKGNvbGxlY3Rpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuaHR0cENsaWVudC5kZWxldGUodGhpcy51cmwoYC9jb2xsZWN0aW9ucy8ke2NvbGxlY3Rpb25JZH1gKSk7XG4gIH1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBEb2N1bWVudHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogVXBsb2FkIGEgZG9jdW1lbnQgZm9yIHByb2Nlc3NpbmdcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVwbG9hZCB0ZXh0IGNvbnRlbnRcbiAgICogY29uc3QgZG9jID0gYXdhaXQgYmxpbmsucmFnLnVwbG9hZCh7XG4gICAqICAgY29sbGVjdGlvbk5hbWU6ICdkb2NzJyxcbiAgICogICBmaWxlbmFtZTogJ25vdGVzLnR4dCcsXG4gICAqICAgY29udGVudDogJ015IGRvY3VtZW50IGNvbnRlbnQuLi4nXG4gICAqIH0pXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVcGxvYWQgZnJvbSBVUkxcbiAgICogY29uc3QgZG9jID0gYXdhaXQgYmxpbmsucmFnLnVwbG9hZCh7XG4gICAqICAgY29sbGVjdGlvbklkOiAnY29sX2FiYzEyMycsXG4gICAqICAgZmlsZW5hbWU6ICdhcnRpY2xlLmh0bWwnLFxuICAgKiAgIHVybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vYXJ0aWNsZSdcbiAgICogfSlcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVwbG9hZCBhIGZpbGUgKGJhc2U2NClcbiAgICogY29uc3QgZG9jID0gYXdhaXQgYmxpbmsucmFnLnVwbG9hZCh7XG4gICAqICAgY29sbGVjdGlvbk5hbWU6ICdkb2NzJyxcbiAgICogICBmaWxlbmFtZTogJ3JlcG9ydC5wZGYnLFxuICAgKiAgIGZpbGU6IHsgZGF0YTogYmFzZTY0RGF0YSwgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9wZGYnIH1cbiAgICogfSlcbiAgICovXG4gIGFzeW5jIHVwbG9hZChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmNvbGxlY3Rpb25JZCAmJiAhb3B0aW9ucy5jb2xsZWN0aW9uTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGVjdGlvbklkIG9yIGNvbGxlY3Rpb25OYW1lIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gcmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgIGNvbGxlY3Rpb25faWQ6IG9wdGlvbnMuY29sbGVjdGlvbklkLFxuICAgICAgY29sbGVjdGlvbl9uYW1lOiBvcHRpb25zLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgZmlsZW5hbWU6IG9wdGlvbnMuZmlsZW5hbWUsXG4gICAgICBjb250ZW50OiBvcHRpb25zLmNvbnRlbnQsXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGFcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5maWxlKSB7XG4gICAgICBib2R5LmZpbGUgPSB7XG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZmlsZS5kYXRhLFxuICAgICAgICBjb250ZW50X3R5cGU6IG9wdGlvbnMuZmlsZS5jb250ZW50VHlwZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdCh0aGlzLnVybChcIi9kb2N1bWVudHNcIiksIGJvZHkpO1xuICAgIHJldHVybiBjb252ZXJ0UGFydGlhbERvY3VtZW50KHJlc3BvbnNlLmRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZG9jdW1lbnQgc3RhdHVzIGFuZCBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0RG9jdW1lbnQoZG9jdW1lbnRJZCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LmdldCh0aGlzLnVybChgL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9YCkpO1xuICAgIHJldHVybiBjb252ZXJ0RG9jdW1lbnQocmVzcG9uc2UuZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3QgZG9jdW1lbnRzLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGNvbGxlY3Rpb24gb3Igc3RhdHVzXG4gICAqL1xuICBhc3luYyBsaXN0RG9jdW1lbnRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgICBpZiAob3B0aW9ucz8uY29sbGVjdGlvbklkKSBwYXJhbXMuY29sbGVjdGlvbl9pZCA9IG9wdGlvbnMuY29sbGVjdGlvbklkO1xuICAgIGlmIChvcHRpb25zPy5zdGF0dXMpIHBhcmFtcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMCA/IGA/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykudG9TdHJpbmcoKX1gIDogXCJcIjtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5nZXQoXG4gICAgICB0aGlzLnVybChgL2RvY3VtZW50cyR7cXVlcnlTdHJpbmd9YClcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmRvY3VtZW50cy5tYXAoY29udmVydERvY3VtZW50KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZG9jdW1lbnQgYW5kIGl0cyBjaHVua3NcbiAgICovXG4gIGFzeW5jIGRlbGV0ZURvY3VtZW50KGRvY3VtZW50SWQpIHtcbiAgICBhd2FpdCB0aGlzLmh0dHBDbGllbnQuZGVsZXRlKHRoaXMudXJsKGAvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH1gKSk7XG4gIH1cbiAgLyoqXG4gICAqIFdhaXQgZm9yIGEgZG9jdW1lbnQgdG8gZmluaXNoIHByb2Nlc3NpbmdcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRvYyA9IGF3YWl0IGJsaW5rLnJhZy51cGxvYWQoeyAuLi4gfSlcbiAgICogY29uc3QgcmVhZHlEb2MgPSBhd2FpdCBibGluay5yYWcud2FpdEZvclJlYWR5KGRvYy5pZClcbiAgICogY29uc29sZS5sb2coYFByb2Nlc3NlZCAke3JlYWR5RG9jLmNodW5rQ291bnR9IGNodW5rc2ApXG4gICAqL1xuICBhc3luYyB3YWl0Rm9yUmVhZHkoZG9jdW1lbnRJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGltZW91dE1zID0gMTJlNCwgcG9sbEludGVydmFsTXMgPSAyZTMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnQgPCB0aW1lb3V0TXMpIHtcbiAgICAgIGNvbnN0IGRvYyA9IGF3YWl0IHRoaXMuZ2V0RG9jdW1lbnQoZG9jdW1lbnRJZCk7XG4gICAgICBpZiAoZG9jLnN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9XG4gICAgICBpZiAoZG9jLnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRG9jdW1lbnQgcHJvY2Vzc2luZyBmYWlsZWQ6ICR7ZG9jLmVycm9yTWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHBvbGxJbnRlcnZhbE1zKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgRG9jdW1lbnQgcHJvY2Vzc2luZyB0aW1lb3V0IGFmdGVyICR7dGltZW91dE1zfW1zYCk7XG4gIH1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTZWFyY2hcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogU2VhcmNoIGZvciBzaW1pbGFyIGNodW5rcyB1c2luZyB2ZWN0b3Igc2ltaWxhcml0eVxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVzdWx0cyA9IGF3YWl0IGJsaW5rLnJhZy5zZWFyY2goe1xuICAgKiAgIGNvbGxlY3Rpb25OYW1lOiAnZG9jcycsXG4gICAqICAgcXVlcnk6ICdIb3cgZG8gSSBjb25maWd1cmUgYXV0aGVudGljYXRpb24/JyxcbiAgICogICBtYXhSZXN1bHRzOiA1XG4gICAqIH0pXG4gICAqL1xuICBhc3luYyBzZWFyY2gob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5jb2xsZWN0aW9uSWQgJiYgIW9wdGlvbnMuY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbGxlY3Rpb25JZCBvciBjb2xsZWN0aW9uTmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICBjb2xsZWN0aW9uX2lkOiBvcHRpb25zLmNvbGxlY3Rpb25JZCxcbiAgICAgIGNvbGxlY3Rpb25fbmFtZTogb3B0aW9ucy5jb2xsZWN0aW9uTmFtZSxcbiAgICAgIHF1ZXJ5OiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgbWF4X3Jlc3VsdHM6IG9wdGlvbnMubWF4UmVzdWx0cyxcbiAgICAgIHNjb3JlX3RocmVzaG9sZDogb3B0aW9ucy5zY29yZVRocmVzaG9sZCxcbiAgICAgIGZpbHRlcnM6IG9wdGlvbnMuZmlsdGVycyxcbiAgICAgIGluY2x1ZGVfY29udGVudDogb3B0aW9ucy5pbmNsdWRlQ29udGVudFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnBvc3QodGhpcy51cmwoXCIvc2VhcmNoXCIpLCBib2R5KTtcbiAgICByZXR1cm4gY29udmVydFNlYXJjaFJlc3BvbnNlKHJlc3BvbnNlLmRhdGEpO1xuICB9XG4gIGFzeW5jIGFpU2VhcmNoKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuY29sbGVjdGlvbklkICYmICFvcHRpb25zLmNvbGxlY3Rpb25OYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsZWN0aW9uSWQgb3IgY29sbGVjdGlvbk5hbWUgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSByZW1vdmVVbmRlZmluZWQoe1xuICAgICAgY29sbGVjdGlvbl9pZDogb3B0aW9ucy5jb2xsZWN0aW9uSWQsXG4gICAgICBjb2xsZWN0aW9uX25hbWU6IG9wdGlvbnMuY29sbGVjdGlvbk5hbWUsXG4gICAgICBxdWVyeTogb3B0aW9ucy5xdWVyeSxcbiAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgbWF4X2NvbnRleHRfY2h1bmtzOiBvcHRpb25zLm1heENvbnRleHRDaHVua3MsXG4gICAgICBzY29yZV90aHJlc2hvbGQ6IG9wdGlvbnMuc2NvcmVUaHJlc2hvbGQsXG4gICAgICBzeXN0ZW1fcHJvbXB0OiBvcHRpb25zLnN5c3RlbVByb21wdCxcbiAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5zdHJlYW0pIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IHRoaXMuaHR0cENsaWVudC5yYWdBaVNlYXJjaFN0cmVhbShib2R5LCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UyLmJvZHk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnBvc3QodGhpcy51cmwoXCIvYWktc2VhcmNoXCIpLCBib2R5KTtcbiAgICByZXR1cm4gY29udmVydEFJU2VhcmNoUmVzdWx0KHJlc3BvbnNlLmRhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvc2FuZGJveC50c1xudmFyIFNBTkRCT1hfVEVNUExBVEVTID0gW1xuICBcImRldnRvb2xzLWJhc2VcIixcbiAgLy8gTm9kZSAyMiArIEJ1biArIFB5dGhvbiArIEdpdCArIHJpcGdyZXAgKERFRkFVTFQpXG4gIFwibmV4dGpzLWFwcFwiLFxuICAvLyBOZXh0LmpzICsgVGFpbHdpbmQgKyBzaGFkY24gVUkgKE5vZGUpXG4gIFwibmV4dGpzLWFwcC1idW5cIixcbiAgLy8gTmV4dC5qcyArIFRhaWx3aW5kICsgc2hhZGNuIFVJIChCdW4pXG4gIFwidml0ZS1yZWFjdFwiLFxuICAvLyBWaXRlICsgUmVhY3QgKyBUYWlsd2luZCArIHNoYWRjbiAoTm9kZSlcbiAgXCJ2aXRlLXJlYWN0LWJ1blwiLFxuICAvLyBWaXRlICsgUmVhY3QgKyBUYWlsd2luZCArIHNoYWRjbiAoQnVuKVxuICBcImV4cG8tYXBwXCIsXG4gIC8vIEV4cG8gKyBSZWFjdCBOYXRpdmVcbiAgXCJkZXNrdG9wXCIsXG4gIC8vIEVsZWN0cm9uICsgVml0ZSArIFJlYWN0XG4gIFwiY2xhdWRlLWNvZGVcIlxuICAvLyBOb2RlIDIxICsgUHl0aG9uICsgR2l0ICsgcmlwZ3JlcFxuXTtcbnZhciBTYW5kYm94Q29ubmVjdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIHNhbmRib3hJZDtcbiAgY29uc3RydWN0b3Ioc2FuZGJveElkLCBjYXVzZSkge1xuICAgIHN1cGVyKGBGYWlsZWQgdG8gY29ubmVjdCB0byBzYW5kYm94ICR7c2FuZGJveElkfWApO1xuICAgIHRoaXMubmFtZSA9IFwiU2FuZGJveENvbm5lY3Rpb25FcnJvclwiO1xuICAgIHRoaXMuc2FuZGJveElkID0gc2FuZGJveElkO1xuICAgIGlmIChjYXVzZSkge1xuICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIH1cbiAgfVxufTtcbnZhciBTYW5kYm94SW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaWQsIHRlbXBsYXRlLCBob3N0UGF0dGVybikge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgdGhpcy5ob3N0UGF0dGVybiA9IGhvc3RQYXR0ZXJuO1xuICB9XG4gIGdldEhvc3QocG9ydCkge1xuICAgIHJldHVybiB0aGlzLmhvc3RQYXR0ZXJuLnJlcGxhY2UoXCJ7cG9ydH1cIiwgU3RyaW5nKHBvcnQpKTtcbiAgfVxufTtcbnZhciBNQVhfUkVUUklFUyA9IDM7XG52YXIgSU5JVElBTF9SRVRSWV9ERUxBWV9NUyA9IDI1MDtcbnZhciBCbGlua1NhbmRib3hJbXBsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50KSB7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB0aGlzLnByb2plY3RJZCA9IGh0dHBDbGllbnQucHJvamVjdElkO1xuICB9XG4gIHByb2plY3RJZDtcbiAgLyoqXG4gICAqIEJ1aWxkIFVSTCB3aXRoIHByb2plY3RfaWQgcHJlZml4XG4gICAqL1xuICB1cmwocGF0aCkge1xuICAgIHJldHVybiBgL2FwaS9zYW5kYm94LyR7dGhpcy5wcm9qZWN0SWR9JHtwYXRofWA7XG4gIH1cbiAgYXN5bmMgY3JlYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICB0ZW1wbGF0ZTogb3B0aW9ucy50ZW1wbGF0ZSxcbiAgICAgIHRpbWVvdXRfbXM6IG9wdGlvbnMudGltZW91dE1zLFxuICAgICAgbWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGEsXG4gICAgICBzZWNyZXRzOiBvcHRpb25zLnNlY3JldHNcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5odHRwQ2xpZW50LnBvc3QodGhpcy51cmwoXCIvY3JlYXRlXCIpLCBib2R5KTtcbiAgICBjb25zdCB7IGlkLCB0ZW1wbGF0ZSwgaG9zdF9wYXR0ZXJuIH0gPSByZXNwb25zZS5kYXRhO1xuICAgIHJldHVybiBuZXcgU2FuZGJveEltcGwoaWQsIHRlbXBsYXRlLCBob3N0X3BhdHRlcm4pO1xuICB9XG4gIGFzeW5jIGNvbm5lY3Qoc2FuZGJveElkLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgbGFzdEVycm9yO1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgTUFYX1JFVFJJRVM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICBzYW5kYm94X2lkOiBzYW5kYm94SWQsXG4gICAgICAgICAgdGltZW91dF9tczogb3B0aW9ucy50aW1lb3V0TXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucG9zdCh0aGlzLnVybChcIi9jb25uZWN0XCIpLCBib2R5KTtcbiAgICAgICAgY29uc3QgeyBpZCwgdGVtcGxhdGUsIGhvc3RfcGF0dGVybiB9ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBTYW5kYm94SW1wbChpZCwgdGVtcGxhdGUsIGhvc3RfcGF0dGVybik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbU2FuZGJveF0gQ29ubmVjdCBhdHRlbXB0ICR7YXR0ZW1wdCArIDF9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgaWYgKGxhc3RFcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiNDA0XCIpIHx8IGxhc3RFcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwibm90IGZvdW5kXCIpIHx8IGxhc3RFcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwidW5hdXRob3JpemVkXCIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNhbmRib3hDb25uZWN0aW9uRXJyb3Ioc2FuZGJveElkLCBsYXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRlbXB0IDwgTUFYX1JFVFJJRVMgLSAxKSB7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBJTklUSUFMX1JFVFJZX0RFTEFZX01TICogTWF0aC5wb3coMiwgYXR0ZW1wdCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGBbU2FuZGJveF0gQWxsICR7TUFYX1JFVFJJRVN9IGNvbm5lY3Rpb24gYXR0ZW1wdHMgZmFpbGVkIGZvciBzYW5kYm94ICR7c2FuZGJveElkfWApO1xuICAgIHRocm93IG5ldyBTYW5kYm94Q29ubmVjdGlvbkVycm9yKHNhbmRib3hJZCwgbGFzdEVycm9yKTtcbiAgfVxuICBhc3luYyBraWxsKHNhbmRib3hJZCkge1xuICAgIGF3YWl0IHRoaXMuaHR0cENsaWVudC5wb3N0KHRoaXMudXJsKFwiL2tpbGxcIiksIHsgc2FuZGJveF9pZDogc2FuZGJveElkIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgZGVmYXVsdENsaWVudCA9IG51bGw7XG5mdW5jdGlvbiBnZXREZWZhdWx0Q2xpZW50KCkge1xuICBpZiAoIWRlZmF1bHRDbGllbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIk5vIEJsaW5rIGNsaWVudCBpbml0aWFsaXplZC4gQ2FsbCBjcmVhdGVDbGllbnQoKSBmaXJzdCBiZWZvcmUgdXNpbmcgQWdlbnQgb3Igb3RoZXIgU0RLIGZlYXR1cmVzLlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdENsaWVudDtcbn1cbmZ1bmN0aW9uIF9nZXREZWZhdWx0SHR0cENsaWVudCgpIHtcbiAgcmV0dXJuIGdldERlZmF1bHRDbGllbnQoKS5faHR0cENsaWVudDtcbn1cbnZhciBCbGlua0NsaWVudEltcGwgPSBjbGFzcyB7XG4gIGF1dGg7XG4gIGRiO1xuICBzdG9yYWdlO1xuICBhaTtcbiAgZGF0YTtcbiAgcmVhbHRpbWU7XG4gIG5vdGlmaWNhdGlvbnM7XG4gIGFuYWx5dGljcztcbiAgY29ubmVjdG9ycztcbiAgZnVuY3Rpb25zO1xuICByYWc7XG4gIHNhbmRib3g7XG4gIC8qKiBAaW50ZXJuYWwgSFRUUCBjbGllbnQgZm9yIEFnZW50IGF1dG8tYmluZGluZyAqL1xuICBfaHR0cENsaWVudDtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgaWYgKChjb25maWcuc2VjcmV0S2V5IHx8IGNvbmZpZy5zZXJ2aWNlVG9rZW4pICYmIGlzQnJvd3Nlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VjcmV0S2V5L3NlcnZpY2VUb2tlbiBpcyBzZXJ2ZXItb25seS4gRG8gbm90IHByb3ZpZGUgaXQgaW4gYnJvd3Nlci9SZWFjdCBOYXRpdmUgY2xpZW50cy5cIik7XG4gICAgfVxuICAgIHRoaXMuYXV0aCA9IG5ldyBCbGlua0F1dGgoY29uZmlnKTtcbiAgICB0aGlzLl9odHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnQoXG4gICAgICBjb25maWcsXG4gICAgICAoKSA9PiB0aGlzLmF1dGguZ2V0VG9rZW4oKSxcbiAgICAgICgpID0+IHRoaXMuYXV0aC5nZXRWYWxpZFRva2VuKClcbiAgICApO1xuICAgIHRoaXMuZGIgPSBuZXcgQmxpbmtEYXRhYmFzZSh0aGlzLl9odHRwQ2xpZW50KTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgQmxpbmtTdG9yYWdlSW1wbCh0aGlzLl9odHRwQ2xpZW50KTtcbiAgICB0aGlzLmFpID0gbmV3IEJsaW5rQUlJbXBsKHRoaXMuX2h0dHBDbGllbnQpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBCbGlua0RhdGFJbXBsKHRoaXMuX2h0dHBDbGllbnQsIGNvbmZpZy5wcm9qZWN0SWQpO1xuICAgIHRoaXMucmVhbHRpbWUgPSBuZXcgQmxpbmtSZWFsdGltZUltcGwodGhpcy5faHR0cENsaWVudCwgY29uZmlnLnByb2plY3RJZCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zID0gbmV3IEJsaW5rTm90aWZpY2F0aW9uc0ltcGwodGhpcy5faHR0cENsaWVudCk7XG4gICAgdGhpcy5hbmFseXRpY3MgPSBuZXcgQmxpbmtBbmFseXRpY3NJbXBsKHRoaXMuX2h0dHBDbGllbnQsIGNvbmZpZy5wcm9qZWN0SWQpO1xuICAgIHRoaXMuY29ubmVjdG9ycyA9IG5ldyBCbGlua0Nvbm5lY3RvcnNJbXBsKHRoaXMuX2h0dHBDbGllbnQpO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gbmV3IEJsaW5rRnVuY3Rpb25zSW1wbChcbiAgICAgIHRoaXMuX2h0dHBDbGllbnQsXG4gICAgICBjb25maWcucHJvamVjdElkLFxuICAgICAgKCkgPT4gdGhpcy5hdXRoLmdldFZhbGlkVG9rZW4oKVxuICAgICk7XG4gICAgdGhpcy5yYWcgPSBuZXcgQmxpbmtSQUdJbXBsKHRoaXMuX2h0dHBDbGllbnQpO1xuICAgIHRoaXMuc2FuZGJveCA9IG5ldyBCbGlua1NhbmRib3hJbXBsKHRoaXMuX2h0dHBDbGllbnQpO1xuICAgIHRoaXMuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZWQoKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuaXNBdXRoZW50aWNhdGVkICYmIHN0YXRlLnVzZXIpIHtcbiAgICAgICAgdGhpcy5hbmFseXRpY3Muc2V0VXNlcklkKHN0YXRlLnVzZXIuaWQpO1xuICAgICAgICB0aGlzLmFuYWx5dGljcy5zZXRVc2VyRW1haWwoc3RhdGUudXNlci5lbWFpbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFuYWx5dGljcy5zZXRVc2VySWQobnVsbCk7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzLnNldFVzZXJFbWFpbChudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChjb25maWcpIHtcbiAgaWYgKCFjb25maWcucHJvamVjdElkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJvamVjdElkIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBCbGlua0NsaWVudEltcGwoY29uZmlnKTtcbiAgZGVmYXVsdENsaWVudCA9IGNsaWVudDtcbiAgcmV0dXJuIGNsaWVudDtcbn1cblxuZXhwb3J0IHsgQWdlbnQsIEFzeW5jU3RvcmFnZUFkYXB0ZXIsIEJsaW5rQUlJbXBsLCBCbGlua0FuYWx5dGljc0ltcGwsIEJsaW5rQ29ubmVjdG9yc0ltcGwsIEJsaW5rRGF0YUltcGwsIEJsaW5rRGF0YWJhc2UsIEJsaW5rUkFHSW1wbCwgQmxpbmtSZWFsdGltZUNoYW5uZWwsIEJsaW5rUmVhbHRpbWVJbXBsLCBCbGlua1NhbmRib3hJbXBsLCBCbGlua1N0b3JhZ2VJbXBsLCBCbGlua1RhYmxlLCBOb09wU3RvcmFnZUFkYXB0ZXIsIFNBTkRCT1hfVEVNUExBVEVTLCBTYW5kYm94Q29ubmVjdGlvbkVycm9yLCBXZWJTdG9yYWdlQWRhcHRlciwgY29yZVRvb2xzLCBjcmVhdGVDbGllbnQsIGRiRGVsZXRlLCBkYkdldCwgZGJJbnNlcnQsIGRiTGlzdCwgZGJUb29scywgZGJVcGRhdGUsIGVkaXRJbWFnZSwgZmV0Y2hVcmwsIGdlbmVyYXRlSW1hZ2UsIGdlbmVyYXRlVmlkZW8sIGdldERlZmF1bHRDbGllbnQsIGdldERlZmF1bHRTdG9yYWdlQWRhcHRlciwgZ2V0SG9zdCwgZ2xvYkZpbGVTZWFyY2gsIGdyZXAsIGltYWdlVG9WaWRlbywgaXNCcm93c2VyLCBpc0Rlbm8sIGlzTm9kZSwgaXNSZWFjdE5hdGl2ZSwgaXNTZXJ2ZXIsIGlzV2ViLCBsaXN0RGlyLCBtZWRpYVRvb2xzLCBwbGF0Zm9ybSwgcmFnU2VhcmNoLCByYWdUb29scywgcmVhZEZpbGUsIHJ1bkNvZGUsIHJ1blRlcm1pbmFsQ21kLCBzYW5kYm94VG9vbHMsIHNlYXJjaFJlcGxhY2UsIHNlcmlhbGl6ZVRvb2xzLCBzdGVwQ291bnRJcywgc3RvcmFnZUNvcHksIHN0b3JhZ2VEZWxldGUsIHN0b3JhZ2VEb3dubG9hZCwgc3RvcmFnZUxpc3QsIHN0b3JhZ2VNb3ZlLCBzdG9yYWdlUHVibGljVXJsLCBzdG9yYWdlVG9vbHMsIHN0b3JhZ2VVcGxvYWQsIHdlYlNlYXJjaCwgd3JpdGVGaWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blinkdotnew/sdk/dist/index.mjs\n");

/***/ })

};
;